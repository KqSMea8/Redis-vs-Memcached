<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - redis.info - src/networking.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - networking.c<span style="font-size: 80%;"> (source / <a href="networking.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">redis.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">908</td>
            <td class="headerCovTableEntry">1109</td>
            <td class="headerCovTableEntryMed">81.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-11-29 23:16:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">69</td>
            <td class="headerCovTableEntry">79</td>
            <td class="headerCovTableEntryMed">87.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
<span class="lineNum">       3 </span>            :  * All rights reserved.
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *   * Redistributions of source code must retain the above copyright notice,
<span class="lineNum">       9 </span>            :  *     this list of conditions and the following disclaimer.
<span class="lineNum">      10 </span>            :  *   * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      11 </span>            :  *     notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      12 </span>            :  *     documentation and/or other materials provided with the distribution.
<span class="lineNum">      13 </span>            :  *   * Neither the name of Redis nor the names of its contributors may be used
<span class="lineNum">      14 </span>            :  *     to endorse or promote products derived from this software without
<span class="lineNum">      15 </span>            :  *     specific prior written permission.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      18 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      19 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      20 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      21 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      22 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      23 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      24 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      25 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      26 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      27 </span>            :  * POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      28 </span>            :  */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;server.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;atomicvar.h&quot;
<span class="lineNum">      32 </span>            : #include &lt;sys/uio.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : static void setProtocolError(const char *errstr, client *c);
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : /* Return the size consumed from the allocator, for the specified SDS string,
<a name="39"><span class="lineNum">      39 </span>            :  * including internal fragmentation. This function is used in order to compute</a>
<span class="lineNum">      40 </span>            :  * the client output buffer size. */
<span class="lineNum">      41 </span><span class="lineCov">     420273 : size_t sdsZmallocSize(sds s) {</span>
<span class="lineNum">      42 </span><span class="lineCov">     420273 :     void *sh = sdsAllocPtr(s);</span>
<span class="lineNum">      43 </span><span class="lineCov">     420273 :     return zmalloc_size(sh);</span>
<span class="lineNum">      44 </span>            : }
<span class="lineNum">      45 </span>            : 
<a name="46"><span class="lineNum">      46 </span>            : /* Return the amount of memory used by the sds string at object-&gt;ptr</a>
<span class="lineNum">      47 </span>            :  * for a string object. */
<span class="lineNum">      48 </span><span class="lineCov">     420273 : size_t getStringObjectSdsUsedMemory(robj *o) {</span>
<span class="lineNum">      49 </span><span class="lineCov">     420273 :     serverAssertWithInfo(NULL,o,o-&gt;type == OBJ_STRING);</span>
<span class="lineNum">      50 </span><span class="lineCov">     420273 :     switch(o-&gt;encoding) {</span>
<span class="lineNum">      51 </span><span class="lineCov">     270132 :     case OBJ_ENCODING_RAW: return sdsZmallocSize(o-&gt;ptr);</span>
<span class="lineNum">      52 </span><span class="lineCov">     150141 :     case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);</span>
<span class="lineNum">      53 </span>            :     default: return 0; /* Just integer encoding for now. */
<span class="lineNum">      54 </span>            :     }
<span class="lineNum">      55 </span>            : }
<a name="56"><span class="lineNum">      56 </span>            : </a>
<span class="lineNum">      57 </span>            : /* Client.reply list dup and free methods. */
<span class="lineNum">      58 </span><span class="lineCov">        252 : void *dupClientReplyValue(void *o) {</span>
<span class="lineNum">      59 </span><span class="lineCov">        252 :     clientReplyBlock *old = o;</span>
<span class="lineNum">      60 </span><span class="lineCov">        252 :     clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old-&gt;size);</span>
<span class="lineNum">      61 </span><span class="lineCov">        504 :     memcpy(buf, o, sizeof(clientReplyBlock) + old-&gt;size);</span>
<span class="lineNum">      62 </span><span class="lineCov">        252 :     return buf;</span>
<a name="63"><span class="lineNum">      63 </span>            : }</a>
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span><span class="lineCov">      46658 : void freeClientReplyValue(void *o) {</span>
<span class="lineNum">      66 </span><span class="lineCov">      46658 :     zfree(o);</span>
<a name="67"><span class="lineNum">      67 </span><span class="lineCov">      46658 : }</span></a>
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span><span class="lineCov">         48 : int listMatchObjects(void *a, void *b) {</span>
<span class="lineNum">      70 </span><span class="lineCov">         48 :     return equalStringObjects(a,b);</span>
<span class="lineNum">      71 </span>            : }
<span class="lineNum">      72 </span>            : 
<a name="73"><span class="lineNum">      73 </span>            : /* This function links the client to the global linked list of clients.</a>
<span class="lineNum">      74 </span>            :  * unlinkClient() does the opposite, among other things. */
<span class="lineNum">      75 </span><span class="lineCov">       3034 : void linkClient(client *c) {</span>
<span class="lineNum">      76 </span><span class="lineCov">       3034 :     listAddNodeTail(server.clients,c);</span>
<span class="lineNum">      77 </span>            :     /* Note that we remember the linked list node where the client is stored,
<span class="lineNum">      78 </span>            :      * this way removing the client in unlinkClient() will not require
<span class="lineNum">      79 </span>            :      * a linear scan, but just a constant time operation. */
<span class="lineNum">      80 </span><span class="lineCov">       3034 :     c-&gt;client_list_node = listLast(server.clients);</span>
<span class="lineNum">      81 </span><span class="lineCov">       3034 :     uint64_t id = htonu64(c-&gt;id);</span>
<span class="lineNum">      82 </span><span class="lineCov">       3034 :     raxInsert(server.clients_index,(unsigned char*)&amp;id,sizeof(id),c,NULL);</span>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">       3034 : }</span></a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineCov">       4363 : client *createClient(int fd) {</span>
<span class="lineNum">      86 </span><span class="lineCov">       4363 :     client *c = zmalloc(sizeof(client));</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     /* passing -1 as fd it is possible to create a non connected client.
<span class="lineNum">      89 </span>            :      * This is useful since all the commands needs to be executed
<span class="lineNum">      90 </span>            :      * in the context of a client. When commands are executed in other
<span class="lineNum">      91 </span>            :      * contexts (for instance a Lua script) we need a non connected client. */
<span class="lineNum">      92 </span><span class="lineCov">       4363 :     if (fd != -1) {</span>
<span class="lineNum">      93 </span><span class="lineCov">       2909 :         anetNonBlock(NULL,fd);</span>
<span class="lineNum">      94 </span><span class="lineCov">       2909 :         anetEnableTcpNoDelay(NULL,fd);</span>
<span class="lineNum">      95 </span><span class="lineCov">       2909 :         if (server.tcpkeepalive)</span>
<span class="lineNum">      96 </span><span class="lineCov">       2909 :             anetKeepAlive(NULL,fd,server.tcpkeepalive);</span>
<span class="lineNum">      97 </span><span class="lineCov">       2909 :         if (aeCreateFileEvent(server.el,fd,AE_READABLE,</span>
<span class="lineNum">      98 </span>            :             readQueryFromClient, c) == AE_ERR)
<span class="lineNum">      99 </span>            :         {
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :             close(fd);</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :             zfree(c);</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :             return NULL;</span>
<span class="lineNum">     103 </span>            :         }
<span class="lineNum">     104 </span>            :     }
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span><span class="lineCov">       4363 :     selectDb(c,0);</span>
<span class="lineNum">     107 </span><span class="lineCov">       4363 :     uint64_t client_id;</span>
<span class="lineNum">     108 </span><span class="lineCov">       4363 :     atomicGetIncr(server.next_client_id,client_id,1);</span>
<span class="lineNum">     109 </span><span class="lineCov">       4363 :     c-&gt;id = client_id;</span>
<span class="lineNum">     110 </span><span class="lineCov">       4363 :     c-&gt;fd = fd;</span>
<span class="lineNum">     111 </span><span class="lineCov">       4363 :     c-&gt;name = NULL;</span>
<span class="lineNum">     112 </span><span class="lineCov">       4363 :     c-&gt;bufpos = 0;</span>
<span class="lineNum">     113 </span><span class="lineCov">       4363 :     c-&gt;qb_pos = 0;</span>
<span class="lineNum">     114 </span><span class="lineCov">       4363 :     c-&gt;querybuf = sdsempty();</span>
<span class="lineNum">     115 </span><span class="lineCov">       4363 :     c-&gt;pending_querybuf = sdsempty();</span>
<span class="lineNum">     116 </span><span class="lineCov">       4363 :     c-&gt;querybuf_peak = 0;</span>
<span class="lineNum">     117 </span><span class="lineCov">       4363 :     c-&gt;reqtype = 0;</span>
<span class="lineNum">     118 </span><span class="lineCov">       4363 :     c-&gt;argc = 0;</span>
<span class="lineNum">     119 </span><span class="lineCov">       4363 :     c-&gt;argv = NULL;</span>
<span class="lineNum">     120 </span><span class="lineCov">       4363 :     c-&gt;cmd = c-&gt;lastcmd = NULL;</span>
<span class="lineNum">     121 </span><span class="lineCov">       4363 :     c-&gt;multibulklen = 0;</span>
<span class="lineNum">     122 </span><span class="lineCov">       4363 :     c-&gt;bulklen = -1;</span>
<span class="lineNum">     123 </span><span class="lineCov">       4363 :     c-&gt;sentlen = 0;</span>
<span class="lineNum">     124 </span><span class="lineCov">       4363 :     c-&gt;flags = 0;</span>
<span class="lineNum">     125 </span><span class="lineCov">       4363 :     c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span>
<span class="lineNum">     126 </span><span class="lineCov">       4363 :     c-&gt;authenticated = 0;</span>
<span class="lineNum">     127 </span><span class="lineCov">       4363 :     c-&gt;replstate = REPL_STATE_NONE;</span>
<span class="lineNum">     128 </span><span class="lineCov">       4363 :     c-&gt;repl_put_online_on_ack = 0;</span>
<span class="lineNum">     129 </span><span class="lineCov">       4363 :     c-&gt;reploff = 0;</span>
<span class="lineNum">     130 </span><span class="lineCov">       4363 :     c-&gt;read_reploff = 0;</span>
<span class="lineNum">     131 </span><span class="lineCov">       4363 :     c-&gt;repl_ack_off = 0;</span>
<span class="lineNum">     132 </span><span class="lineCov">       4363 :     c-&gt;repl_ack_time = 0;</span>
<span class="lineNum">     133 </span><span class="lineCov">       4363 :     c-&gt;slave_listening_port = 0;</span>
<span class="lineNum">     134 </span><span class="lineCov">       4363 :     c-&gt;slave_ip[0] = '\0';</span>
<span class="lineNum">     135 </span><span class="lineCov">       4363 :     c-&gt;slave_capa = SLAVE_CAPA_NONE;</span>
<span class="lineNum">     136 </span><span class="lineCov">       4363 :     c-&gt;reply = listCreate();</span>
<span class="lineNum">     137 </span><span class="lineCov">       4363 :     c-&gt;reply_bytes = 0;</span>
<span class="lineNum">     138 </span><span class="lineCov">       4363 :     c-&gt;obuf_soft_limit_reached_time = 0;</span>
<span class="lineNum">     139 </span><span class="lineCov">       4363 :     listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span>
<span class="lineNum">     140 </span><span class="lineCov">       4363 :     listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span>
<span class="lineNum">     141 </span><span class="lineCov">       4363 :     c-&gt;btype = BLOCKED_NONE;</span>
<span class="lineNum">     142 </span><span class="lineCov">       4363 :     c-&gt;bpop.timeout = 0;</span>
<span class="lineNum">     143 </span><span class="lineCov">       4363 :     c-&gt;bpop.keys = dictCreate(&amp;objectKeyHeapPointerValueDictType,NULL);</span>
<span class="lineNum">     144 </span><span class="lineCov">       4363 :     c-&gt;bpop.target = NULL;</span>
<span class="lineNum">     145 </span><span class="lineCov">       4363 :     c-&gt;bpop.xread_group = NULL;</span>
<span class="lineNum">     146 </span><span class="lineCov">       4363 :     c-&gt;bpop.xread_consumer = NULL;</span>
<span class="lineNum">     147 </span><span class="lineCov">       4363 :     c-&gt;bpop.xread_group_noack = 0;</span>
<span class="lineNum">     148 </span><span class="lineCov">       4363 :     c-&gt;bpop.numreplicas = 0;</span>
<span class="lineNum">     149 </span><span class="lineCov">       4363 :     c-&gt;bpop.reploffset = 0;</span>
<span class="lineNum">     150 </span><span class="lineCov">       4363 :     c-&gt;woff = 0;</span>
<span class="lineNum">     151 </span><span class="lineCov">       4363 :     c-&gt;watched_keys = listCreate();</span>
<span class="lineNum">     152 </span><span class="lineCov">       4363 :     c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,NULL);</span>
<span class="lineNum">     153 </span><span class="lineCov">       4363 :     c-&gt;pubsub_patterns = listCreate();</span>
<span class="lineNum">     154 </span><span class="lineCov">       4363 :     c-&gt;peerid = NULL;</span>
<span class="lineNum">     155 </span><span class="lineCov">       4363 :     c-&gt;client_list_node = NULL;</span>
<span class="lineNum">     156 </span><span class="lineCov">       4363 :     listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span>
<span class="lineNum">     157 </span><span class="lineCov">       4363 :     listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span>
<span class="lineNum">     158 </span><span class="lineCov">       4363 :     if (fd != -1) linkClient(c);</span>
<span class="lineNum">     159 </span><span class="lineCov">       4363 :     initClientMultiState(c);</span>
<span class="lineNum">     160 </span><span class="lineCov">       4363 :     return c;</span>
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /* This funciton puts the client in the queue of clients that should write
<span class="lineNum">     164 </span>            :  * their output buffers to the socket. Note that it does not *yet* install
<span class="lineNum">     165 </span>            :  * the write handler, to start clients are put in a queue of clients that need
<span class="lineNum">     166 </span>            :  * to write, so we try to do that before returning in the event loop (see the
<span class="lineNum">     167 </span>            :  * handleClientsWithPendingWrites() function).
<a name="168"><span class="lineNum">     168 </span>            :  * If we fail and there is more data to write, compared to what the socket</a>
<span class="lineNum">     169 </span>            :  * buffers can hold, then we'll really install the handler. */
<span class="lineNum">     170 </span><span class="lineCov">   25402795 : void clientInstallWriteHandler(client *c) {</span>
<span class="lineNum">     171 </span>            :     /* Schedule the client to write the output buffers to the socket only
<span class="lineNum">     172 </span>            :      * if not already done and, for slaves, if the slave can actually receive
<span class="lineNum">     173 </span>            :      * writes at this stage. */
<span class="lineNum">     174 </span><span class="lineCov">   25402795 :     if (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span>
<span class="lineNum">     175 </span><span class="lineCov">   25402795 :         (c-&gt;replstate == REPL_STATE_NONE ||</span>
<span class="lineNum">     176 </span><span class="lineCov">    3442873 :          (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</span>
<span class="lineNum">     177 </span>            :     {
<span class="lineNum">     178 </span>            :         /* Here instead of installing the write handler, we just flag the
<span class="lineNum">     179 </span>            :          * client and put it into a list of clients that have something
<span class="lineNum">     180 </span>            :          * to write to the socket. This way before re-entering the event
<span class="lineNum">     181 </span>            :          * loop, we can try to directly write to the client sockets avoiding
<span class="lineNum">     182 </span>            :          * a system call. We'll only really install the write handler if
<span class="lineNum">     183 </span>            :          * we'll not be able to write the whole reply at once. */
<span class="lineNum">     184 </span><span class="lineCov">   25402685 :         c-&gt;flags |= CLIENT_PENDING_WRITE;</span>
<span class="lineNum">     185 </span><span class="lineCov">   25402685 :         listAddNodeHead(server.clients_pending_write,c);</span>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span><span class="lineCov">   25402795 : }</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /* This function is called every time we are going to transmit new data
<span class="lineNum">     190 </span>            :  * to the client. The behavior is the following:
<span class="lineNum">     191 </span>            :  *
<span class="lineNum">     192 </span>            :  * If the client should receive new data (normal clients will) the function
<span class="lineNum">     193 </span>            :  * returns C_OK, and make sure to install the write handler in our event
<span class="lineNum">     194 </span>            :  * loop so that when the socket is writable new data gets written.
<span class="lineNum">     195 </span>            :  *
<span class="lineNum">     196 </span>            :  * If the client should not receive new data, because it is a fake client
<span class="lineNum">     197 </span>            :  * (used to load AOF in memory), a master or because the setup of the write
<span class="lineNum">     198 </span>            :  * handler failed, the function returns C_ERR.
<span class="lineNum">     199 </span>            :  *
<span class="lineNum">     200 </span>            :  * The function may return C_OK without actually installing the write
<span class="lineNum">     201 </span>            :  * event handler in the following cases:
<span class="lineNum">     202 </span>            :  *
<span class="lineNum">     203 </span>            :  * 1) The event handler should already be installed since the output buffer
<span class="lineNum">     204 </span>            :  *    already contains something.
<span class="lineNum">     205 </span>            :  * 2) The client is a slave but not yet online, so we want to just accumulate
<span class="lineNum">     206 </span>            :  *    writes in the buffer but not actually sending them yet.
<span class="lineNum">     207 </span>            :  *
<span class="lineNum">     208 </span>            :  * Typically gets called every time a reply is built, before adding more
<a name="209"><span class="lineNum">     209 </span>            :  * data to the clients output buffers. If the function returns C_ERR no</a>
<span class="lineNum">     210 </span>            :  * data should be appended to the output buffers. */
<span class="lineNum">     211 </span><span class="lineCov">  274387087 : int prepareClientToWrite(client *c) {</span>
<span class="lineNum">     212 </span>            :     /* If it's the Lua client we always return ok without installing any
<span class="lineNum">     213 </span>            :      * handler since there is no socket at all. */
<span class="lineNum">     214 </span><span class="lineCov">  274387087 :     if (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) return C_OK;</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :     /* CLIENT REPLY OFF / SKIP handling: don't send replies. */
<span class="lineNum">     217 </span><span class="lineCov">  272714646 :     if (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :     /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
<span class="lineNum">     220 </span>            :      * is set. */
<span class="lineNum">     221 </span><span class="lineCov">  272714646 :     if ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span>
<span class="lineNum">     222 </span>            :         !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) return C_ERR;
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">  241977735 :     if (c-&gt;fd &lt;= 0) return C_ERR; /* Fake client for AOF loading. */</span>
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :     /* Schedule the client to write the output buffers to the socket, unless
<span class="lineNum">     227 </span>            :      * it should already be setup to do so (it has already pending data). */
<span class="lineNum">     228 </span><span class="lineCov">   25402795 :     if (!clientHasPendingReplies(c)) clientInstallWriteHandler(c);</span>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            :     /* Authorize the caller to queue in the output buffer of this client. */
<span class="lineNum">     231 </span>            :     return C_OK;
<span class="lineNum">     232 </span>            : }
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /* -----------------------------------------------------------------------------
<span class="lineNum">     235 </span>            :  * Low level functions to add more data to output buffers.
<a name="236"><span class="lineNum">     236 </span>            :  * -------------------------------------------------------------------------- */</a>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineCov">  236133681 : int _addReplyToBuffer(client *c, const char *s, size_t len) {</span>
<span class="lineNum">     239 </span><span class="lineCov">  236133681 :     size_t available = sizeof(c-&gt;buf)-c-&gt;bufpos;</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineCov">  236133681 :     if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) return C_OK;</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :     /* If there already are entries in the reply list, we cannot
<span class="lineNum">     244 </span>            :      * add anything more to the static buffer. */
<span class="lineNum">     245 </span><span class="lineCov">  236133681 :     if (listLength(c-&gt;reply) &gt; 0) return C_ERR;</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :     /* Check that the buffer has enough space available for this string. */
<span class="lineNum">     248 </span><span class="lineCov">  131220170 :     if (len &gt; available) return C_ERR;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">  131215369 :     memcpy(c-&gt;buf+c-&gt;bufpos,s,len);</span>
<span class="lineNum">     251 </span><span class="lineCov">  131215369 :     c-&gt;bufpos+=len;</span>
<span class="lineNum">     252 </span><span class="lineCov">  131215369 :     return C_OK;</span>
<a name="253"><span class="lineNum">     253 </span>            : }</a>
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span><span class="lineCov">  104918312 : void _addReplyStringToList(client *c, const char *s, size_t len) {</span>
<span class="lineNum">     256 </span><span class="lineCov">  104918312 :     if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) return;</span>
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span><span class="lineCov">  104918312 :     listNode *ln = listLast(c-&gt;reply);</span>
<span class="lineNum">     259 </span><span class="lineCov">  104918312 :     clientReplyBlock *tail = ln? listNodeValue(ln): NULL;</span>
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :     /* Note that 'tail' may be NULL even if we have a tail node, becuase when
<span class="lineNum">     262 </span>            :      * addDeferredMultiBulkLength() is used, it sets a dummy node to NULL just
<span class="lineNum">     263 </span>            :      * fo fill it later, when the size of the bulk length is set. */
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :     /* Append to tail string when possible. */
<span class="lineNum">     266 </span><span class="lineCov">  104913511 :     if (tail) {</span>
<span class="lineNum">     267 </span>            :         /* Copy the part we can fit into the tail, and leave the rest for a
<span class="lineNum">     268 </span>            :          * new node */
<span class="lineNum">     269 </span><span class="lineCov">  104907610 :         size_t avail = tail-&gt;size - tail-&gt;used;</span>
<span class="lineNum">     270 </span><span class="lineCov">  104907610 :         size_t copy = avail &gt;= len? len: avail;</span>
<span class="lineNum">     271 </span><span class="lineCov">  104907610 :         memcpy(tail-&gt;buf + tail-&gt;used, s, copy);</span>
<span class="lineNum">     272 </span><span class="lineCov">  104907610 :         tail-&gt;used += copy;</span>
<span class="lineNum">     273 </span><span class="lineCov">  104907610 :         s += copy;</span>
<span class="lineNum">     274 </span><span class="lineCov">  104907610 :         len -= copy;</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span><span class="lineCov">  104918312 :     if (len) {</span>
<span class="lineNum">     277 </span>            :         /* Create a new node, make sure it is allocated to at
<span class="lineNum">     278 </span>            :          * least PROTO_REPLY_CHUNK_BYTES */
<span class="lineNum">     279 </span><span class="lineCov">      40350 :         size_t size = len &lt; PROTO_REPLY_CHUNK_BYTES? PROTO_REPLY_CHUNK_BYTES: len;</span>
<span class="lineNum">     280 </span><span class="lineCov">      40350 :         tail = zmalloc(size + sizeof(clientReplyBlock));</span>
<span class="lineNum">     281 </span>            :         /* take over the allocation's internal fragmentation */
<span class="lineNum">     282 </span><span class="lineCov">      40350 :         tail-&gt;size = zmalloc_usable(tail) - sizeof(clientReplyBlock);</span>
<span class="lineNum">     283 </span><span class="lineCov">      40350 :         tail-&gt;used = len;</span>
<span class="lineNum">     284 </span><span class="lineCov">      40350 :         memcpy(tail-&gt;buf, s, len);</span>
<span class="lineNum">     285 </span><span class="lineCov">      40350 :         listAddNodeTail(c-&gt;reply, tail);</span>
<span class="lineNum">     286 </span><span class="lineCov">      40350 :         c-&gt;reply_bytes += tail-&gt;size;</span>
<span class="lineNum">     287 </span>            :     }
<span class="lineNum">     288 </span><span class="lineCov">  104918312 :     asyncCloseClientOnOutputBufferLimitReached(c);</span>
<span class="lineNum">     289 </span>            : }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* -----------------------------------------------------------------------------
<span class="lineNum">     292 </span>            :  * Higher level functions to queue data on the client output buffer.
<span class="lineNum">     293 </span>            :  * The following functions are the ones that commands implementations will call.
<span class="lineNum">     294 </span>            :  * -------------------------------------------------------------------------- */
<a name="295"><span class="lineNum">     295 </span>            : </a>
<span class="lineNum">     296 </span>            : /* Add the object 'obj' string representation to the client output buffer. */
<span class="lineNum">     297 </span><span class="lineCov">  243457839 : void addReply(client *c, robj *obj) {</span>
<span class="lineNum">     298 </span><span class="lineCov">  243457839 :     if (prepareClientToWrite(c) != C_OK) return;</span>
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">  205723726 :     if (sdsEncodedObject(obj)) {</span>
<span class="lineNum">     301 </span><span class="lineCov">  403087496 :         if (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != C_OK)</span>
<span class="lineNum">     302 </span><span class="lineCov">  202677248 :             _addReplyStringToList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span>
<span class="lineNum">     303 </span><span class="lineCov">    4179978 :     } else if (obj-&gt;encoding == OBJ_ENCODING_INT) {</span>
<span class="lineNum">     304 </span>            :         /* For integer encoded strings we just convert it into a string
<span class="lineNum">     305 </span>            :          * using our optimized function, and attach the resulting string
<span class="lineNum">     306 </span>            :          * to the output buffer. */
<span class="lineNum">     307 </span><span class="lineCov">    4179978 :         char buf[32];</span>
<span class="lineNum">     308 </span><span class="lineCov">    4179978 :         size_t len = ll2string(buf,sizeof(buf),(long)obj-&gt;ptr);</span>
<span class="lineNum">     309 </span><span class="lineCov">    4179978 :         if (_addReplyToBuffer(c,buf,len) != C_OK)</span>
<span class="lineNum">     310 </span><span class="lineCov">     227474 :             _addReplyStringToList(c,buf,len);</span>
<span class="lineNum">     311 </span>            :     } else {
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :         serverPanic(&quot;Wrong obj-&gt;encoding in addReply()&quot;);</span>
<span class="lineNum">     313 </span>            :     }
<span class="lineNum">     314 </span>            : }
<span class="lineNum">     315 </span>            : 
<a name="316"><span class="lineNum">     316 </span>            : /* Add the SDS 's' string to the client output buffer, as a side effect</a>
<span class="lineNum">     317 </span>            :  * the SDS string is freed. */
<span class="lineNum">     318 </span><span class="lineCov">     961383 : void addReplySds(client *c, sds s) {</span>
<span class="lineNum">     319 </span><span class="lineCov">     961383 :     if (prepareClientToWrite(c) != C_OK) {</span>
<span class="lineNum">     320 </span>            :         /* The caller expects the sds to be free'd. */
<span class="lineNum">     321 </span><span class="lineCov">        939 :         sdsfree(s);</span>
<span class="lineNum">     322 </span><span class="lineCov">        939 :         return;</span>
<span class="lineNum">     323 </span>            :     }
<span class="lineNum">     324 </span><span class="lineCov">    1920888 :     if (_addReplyToBuffer(c,s,sdslen(s)) != C_OK)</span>
<span class="lineNum">     325 </span><span class="lineCov">    1736434 :         _addReplyStringToList(c,s,sdslen(s));</span>
<span class="lineNum">     326 </span><span class="lineCov">     960444 :     sdsfree(s);</span>
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /* This low level function just adds whatever protocol you send it to the
<span class="lineNum">     330 </span>            :  * client buffer, trying the static buffer initially, and using the string
<span class="lineNum">     331 </span>            :  * of objects if not possible.
<span class="lineNum">     332 </span>            :  *
<span class="lineNum">     333 </span>            :  * It is efficient because does not create an SDS object nor an Redis object
<span class="lineNum">     334 </span>            :  * if not needed. The object will only be created by calling
<a name="335"><span class="lineNum">     335 </span>            :  * _addReplyStringToList() if we fail to extend the existing tail object</a>
<span class="lineNum">     336 </span>            :  * in the list of objects. */
<span class="lineNum">     337 </span><span class="lineCov">   29961643 : void addReplyString(client *c, const char *s, size_t len) {</span>
<span class="lineNum">     338 </span><span class="lineCov">   29961643 :     if (prepareClientToWrite(c) != C_OK) return;</span>
<span class="lineNum">     339 </span><span class="lineCov">   29449511 :     if (_addReplyToBuffer(c,s,len) != C_OK)</span>
<span class="lineNum">     340 </span><span class="lineCov">    2483997 :         _addReplyStringToList(c,s,len);</span>
<span class="lineNum">     341 </span>            : }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : /* Low level function called by the addReplyError...() functions.
<span class="lineNum">     344 </span>            :  * It emits the protocol for a Redis error, in the form:
<span class="lineNum">     345 </span>            :  *
<span class="lineNum">     346 </span>            :  * -ERRORCODE Error Message&lt;CR&gt;&lt;LF&gt;
<span class="lineNum">     347 </span>            :  *
<span class="lineNum">     348 </span>            :  * If the error code is already passed in the string 's', the error
<a name="349"><span class="lineNum">     349 </span>            :  * code provided is used, otherwise the string &quot;-ERR &quot; for the generic</a>
<span class="lineNum">     350 </span>            :  * error code is automatically added. */
<span class="lineNum">     351 </span><span class="lineCov">      90437 : void addReplyErrorLength(client *c, const char *s, size_t len) {</span>
<span class="lineNum">     352 </span>            :     /* If the string already starts with &quot;-...&quot; then the error code
<span class="lineNum">     353 </span>            :      * is provided by the caller. Otherwise we use &quot;-ERR&quot;. */
<span class="lineNum">     354 </span><span class="lineCov">      90437 :     if (!len || s[0] != '-') addReplyString(c,&quot;-ERR &quot;,5);</span>
<span class="lineNum">     355 </span><span class="lineCov">      90437 :     addReplyString(c,s,len);</span>
<span class="lineNum">     356 </span><span class="lineCov">      90437 :     addReplyString(c,&quot;\r\n&quot;,2);</span>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            :     /* Sometimes it could be normal that a slave replies to a master with
<span class="lineNum">     359 </span>            :      * an error and this function gets called. Actually the error will never
<span class="lineNum">     360 </span>            :      * be sent because addReply*() against master clients has no effect...
<span class="lineNum">     361 </span>            :      * A notable example is:
<span class="lineNum">     362 </span>            :      *
<span class="lineNum">     363 </span>            :      *    EVAL 'redis.call(&quot;incr&quot;,KEYS[1]); redis.call(&quot;nonexisting&quot;)' 1 x
<span class="lineNum">     364 </span>            :      *
<span class="lineNum">     365 </span>            :      * Where the master must propagate the first change even if the second
<span class="lineNum">     366 </span>            :      * will produce an error. However it is useful to log such events since
<span class="lineNum">     367 </span>            :      * they are rare and may hint at errors in a script or a bug in Redis. */
<span class="lineNum">     368 </span><span class="lineCov">      90437 :     if (c-&gt;flags &amp; (CLIENT_MASTER|CLIENT_SLAVE)) {</span>
<span class="lineNum">     369 </span><span class="lineCov">      89992 :         char* to = c-&gt;flags &amp; CLIENT_MASTER? &quot;master&quot;: &quot;replica&quot;;</span>
<span class="lineNum">     370 </span><span class="lineCov">      89992 :         char* from = c-&gt;flags &amp; CLIENT_MASTER? &quot;replica&quot;: &quot;master&quot;;</span>
<span class="lineNum">     371 </span><span class="lineCov">      89992 :         char *cmdname = c-&gt;lastcmd ? c-&gt;lastcmd-&gt;name : &quot;&lt;unknown&gt;&quot;;</span>
<span class="lineNum">     372 </span><span class="lineCov">      89992 :         serverLog(LL_WARNING,&quot;== CRITICAL == This %s is sending an error &quot;</span>
<span class="lineNum">     373 </span>            :                              &quot;to its %s: '%s' after processing the command &quot;
<span class="lineNum">     374 </span>            :                              &quot;'%s'&quot;, from, to, s, cmdname);
<span class="lineNum">     375 </span>            :         /* Here we want to panic because when a master is sending an
<span class="lineNum">     376 </span>            :          * error to some slave in the context of replication, this can
<span class="lineNum">     377 </span>            :          * only create some kind of offset or data desynchronization. Better
<span class="lineNum">     378 </span>            :          * to catch it ASAP and crash instead of continuing. */
<span class="lineNum">     379 </span><span class="lineCov">      89992 :         if (c-&gt;flags &amp; CLIENT_SLAVE)</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Continuing is unsafe: replication protocol violation.&quot;);</span>
<span class="lineNum">     381 </span>            :     }
<a name="382"><span class="lineNum">     382 </span><span class="lineCov">      90437 : }</span></a>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">      90298 : void addReplyError(client *c, const char *err) {</span>
<span class="lineNum">     385 </span><span class="lineCov">      90298 :     addReplyErrorLength(c,err,strlen(err));</span>
<a name="386"><span class="lineNum">     386 </span><span class="lineCov">      90298 : }</span></a>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">        107 : void addReplyErrorFormat(client *c, const char *fmt, ...) {</span>
<span class="lineNum">     389 </span><span class="lineCov">        107 :     size_t l, j;</span>
<span class="lineNum">     390 </span><span class="lineCov">        107 :     va_list ap;</span>
<span class="lineNum">     391 </span><span class="lineCov">        107 :     va_start(ap,fmt);</span>
<span class="lineNum">     392 </span><span class="lineCov">        107 :     sds s = sdscatvprintf(sdsempty(),fmt,ap);</span>
<span class="lineNum">     393 </span><span class="lineCov">        107 :     va_end(ap);</span>
<span class="lineNum">     394 </span>            :     /* Make sure there are no newlines in the string, otherwise invalid protocol
<span class="lineNum">     395 </span>            :      * is emitted. */
<span class="lineNum">     396 </span><span class="lineCov">        107 :     l = sdslen(s);</span>
<span class="lineNum">     397 </span><span class="lineCov">      10668 :     for (j = 0; j &lt; l; j++) {</span>
<span class="lineNum">     398 </span><span class="lineCov">      10561 :         if (s[j] == '\r' || s[j] == '\n') s[j] = ' ';</span>
<span class="lineNum">     399 </span>            :     }
<span class="lineNum">     400 </span><span class="lineCov">        214 :     addReplyErrorLength(c,s,sdslen(s));</span>
<span class="lineNum">     401 </span><span class="lineCov">        107 :     sdsfree(s);</span>
<a name="402"><span class="lineNum">     402 </span><span class="lineCov">        107 : }</span></a>
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span><span class="lineCov">    5380303 : void addReplyStatusLength(client *c, const char *s, size_t len) {</span>
<span class="lineNum">     405 </span><span class="lineCov">    5380303 :     addReplyString(c,&quot;+&quot;,1);</span>
<span class="lineNum">     406 </span><span class="lineCov">    5380303 :     addReplyString(c,s,len);</span>
<span class="lineNum">     407 </span><span class="lineCov">    5380303 :     addReplyString(c,&quot;\r\n&quot;,2);</span>
<a name="408"><span class="lineNum">     408 </span><span class="lineCov">    5380303 : }</span></a>
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span><span class="lineCov">    5370139 : void addReplyStatus(client *c, const char *status) {</span>
<span class="lineNum">     411 </span><span class="lineCov">    5370139 :     addReplyStatusLength(c,status,strlen(status));</span>
<a name="412"><span class="lineNum">     412 </span><span class="lineCov">    5370139 : }</span></a>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">      10164 : void addReplyStatusFormat(client *c, const char *fmt, ...) {</span>
<span class="lineNum">     415 </span><span class="lineCov">      10164 :     va_list ap;</span>
<span class="lineNum">     416 </span><span class="lineCov">      10164 :     va_start(ap,fmt);</span>
<span class="lineNum">     417 </span><span class="lineCov">      10164 :     sds s = sdscatvprintf(sdsempty(),fmt,ap);</span>
<span class="lineNum">     418 </span><span class="lineCov">      10164 :     va_end(ap);</span>
<span class="lineNum">     419 </span><span class="lineCov">      20328 :     addReplyStatusLength(c,s,sdslen(s));</span>
<span class="lineNum">     420 </span><span class="lineCov">      10164 :     sdsfree(s);</span>
<span class="lineNum">     421 </span><span class="lineCov">      10164 : }</span>
<span class="lineNum">     422 </span>            : 
<a name="423"><span class="lineNum">     423 </span>            : /* Adds an empty object to the reply list that will contain the multi bulk</a>
<span class="lineNum">     424 </span>            :  * length, which is not known when this function is called. */
<span class="lineNum">     425 </span><span class="lineCov">       6222 : void *addDeferredMultiBulkLength(client *c) {</span>
<span class="lineNum">     426 </span>            :     /* Note that we install the write event here even if the object is not
<span class="lineNum">     427 </span>            :      * ready to be sent, since we are sure that before returning to the
<span class="lineNum">     428 </span>            :      * event loop setDeferredMultiBulkLength() will be called. */
<span class="lineNum">     429 </span><span class="lineCov">       6222 :     if (prepareClientToWrite(c) != C_OK) return NULL;</span>
<span class="lineNum">     430 </span><span class="lineCov">       6156 :     listAddNodeTail(c-&gt;reply,NULL); /* NULL is our placeholder. */</span>
<span class="lineNum">     431 </span><span class="lineCov">       6156 :     return listLast(c-&gt;reply);</span>
<span class="lineNum">     432 </span>            : }
<a name="433"><span class="lineNum">     433 </span>            : </a>
<span class="lineNum">     434 </span>            : /* Populate the length object and try gluing it to the next chunk. */
<span class="lineNum">     435 </span><span class="lineCov">       6222 : void setDeferredMultiBulkLength(client *c, void *node, long length) {</span>
<span class="lineNum">     436 </span><span class="lineCov">       6222 :     listNode *ln = (listNode*)node;</span>
<span class="lineNum">     437 </span><span class="lineCov">       6222 :     clientReplyBlock *next;</span>
<span class="lineNum">     438 </span><span class="lineCov">       6222 :     char lenstr[128];</span>
<span class="lineNum">     439 </span><span class="lineCov">       6222 :     size_t lenstr_len = sprintf(lenstr, &quot;*%ld\r\n&quot;, length);</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            :     /* Abort when *node is NULL: when the client should not accept writes
<span class="lineNum">     442 </span>            :      * we return NULL in addDeferredMultiBulkLength() */
<span class="lineNum">     443 </span><span class="lineCov">       6222 :     if (node == NULL) return;</span>
<span class="lineNum">     444 </span><span class="lineCov">       6156 :     serverAssert(!listNodeValue(ln));</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :     /* Normally we fill this dummy NULL node, added by addDeferredMultiBulkLength(),
<span class="lineNum">     447 </span>            :      * with a new buffer structure containing the protocol needed to specify
<span class="lineNum">     448 </span>            :      * the length of the array following. However sometimes when there is
<span class="lineNum">     449 </span>            :      * little memory to move, we may instead remove this NULL node, and prefix
<span class="lineNum">     450 </span>            :      * our protocol in the node immediately after to it, in order to save a
<span class="lineNum">     451 </span>            :      * write(2) syscall later. Conditions needed to do it:
<span class="lineNum">     452 </span>            :      *
<span class="lineNum">     453 </span>            :      * - The next node is non-NULL,
<span class="lineNum">     454 </span>            :      * - It has enough room already allocated
<span class="lineNum">     455 </span>            :      * - And not too large (avoid large memmove) */
<span class="lineNum">     456 </span><span class="lineCov">       6156 :     if (ln-&gt;next != NULL &amp;&amp; (next = listNodeValue(ln-&gt;next)) &amp;&amp;</span>
<span class="lineNum">     457 </span><span class="lineCov">       5904 :         next-&gt;size - next-&gt;used &gt;= lenstr_len &amp;&amp;</span>
<span class="lineNum">     458 </span>            :         next-&gt;used &lt; PROTO_REPLY_CHUNK_BYTES * 4) {
<span class="lineNum">     459 </span><span class="lineCov">       5708 :         memmove(next-&gt;buf + lenstr_len, next-&gt;buf, next-&gt;used);</span>
<span class="lineNum">     460 </span><span class="lineCov">       5708 :         memcpy(next-&gt;buf, lenstr, lenstr_len);</span>
<span class="lineNum">     461 </span><span class="lineCov">       5708 :         next-&gt;used += lenstr_len;</span>
<span class="lineNum">     462 </span><span class="lineCov">       5708 :         listDelNode(c-&gt;reply,ln);</span>
<span class="lineNum">     463 </span>            :     } else {
<span class="lineNum">     464 </span>            :         /* Create a new node */
<span class="lineNum">     465 </span><span class="lineCov">        448 :         clientReplyBlock *buf = zmalloc(lenstr_len + sizeof(clientReplyBlock));</span>
<span class="lineNum">     466 </span>            :         /* Take over the allocation's internal fragmentation */
<span class="lineNum">     467 </span><span class="lineCov">        448 :         buf-&gt;size = zmalloc_usable(buf) - sizeof(clientReplyBlock);</span>
<span class="lineNum">     468 </span><span class="lineCov">        448 :         buf-&gt;used = lenstr_len;</span>
<span class="lineNum">     469 </span><span class="lineCov">        448 :         memcpy(buf-&gt;buf, lenstr, lenstr_len);</span>
<span class="lineNum">     470 </span><span class="lineCov">        448 :         listNodeValue(ln) = buf;</span>
<span class="lineNum">     471 </span><span class="lineCov">        448 :         c-&gt;reply_bytes += buf-&gt;size;</span>
<span class="lineNum">     472 </span>            :     }
<span class="lineNum">     473 </span><span class="lineCov">       6156 :     asyncCloseClientOnOutputBufferLimitReached(c);</span>
<span class="lineNum">     474 </span>            : }
<a name="475"><span class="lineNum">     475 </span>            : </a>
<span class="lineNum">     476 </span>            : /* Add a double as a bulk reply */
<span class="lineNum">     477 </span><span class="lineCov">     141914 : void addReplyDouble(client *c, double d) {</span>
<span class="lineNum">     478 </span><span class="lineCov">     141914 :     char dbuf[128], sbuf[128];</span>
<span class="lineNum">     479 </span><span class="lineCov">     141914 :     int dlen, slen;</span>
<span class="lineNum">     480 </span><span class="lineCov">     141914 :     if (isinf(d)) {</span>
<span class="lineNum">     481 </span>            :         /* Libc in odd systems (Hi Solaris!) will format infinite in a
<span class="lineNum">     482 </span>            :          * different way, so better to handle it in an explicit way. */
<span class="lineNum">     483 </span><span class="lineCov">         42 :         addReplyBulkCString(c, d &gt; 0 ? &quot;inf&quot; : &quot;-inf&quot;);</span>
<span class="lineNum">     484 </span>            :     } else {
<span class="lineNum">     485 </span><span class="lineCov">     141884 :         dlen = snprintf(dbuf,sizeof(dbuf),&quot;%.17g&quot;,d);</span>
<span class="lineNum">     486 </span><span class="lineCov">     141884 :         slen = snprintf(sbuf,sizeof(sbuf),&quot;$%d\r\n%s\r\n&quot;,dlen,dbuf);</span>
<span class="lineNum">     487 </span><span class="lineCov">     141884 :         addReplyString(c,sbuf,slen);</span>
<span class="lineNum">     488 </span>            :     }
<span class="lineNum">     489 </span><span class="lineCov">     141914 : }</span>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : /* Add a long double as a bulk reply, but uses a human readable formatting
<a name="492"><span class="lineNum">     492 </span>            :  * of the double instead of exposing the crude behavior of doubles to the</a>
<span class="lineNum">     493 </span>            :  * dear user. */
<span class="lineNum">     494 </span><span class="lineCov">         28 : void addReplyHumanLongDouble(client *c, long double d) {</span>
<span class="lineNum">     495 </span><span class="lineCov">         28 :     robj *o = createStringObjectFromLongDouble(d,1);</span>
<span class="lineNum">     496 </span><span class="lineCov">         28 :     addReplyBulk(c,o);</span>
<span class="lineNum">     497 </span><span class="lineCov">         28 :     decrRefCount(o);</span>
<span class="lineNum">     498 </span><span class="lineCov">         28 : }</span>
<span class="lineNum">     499 </span>            : 
<a name="500"><span class="lineNum">     500 </span>            : /* Add a long long as integer reply or bulk len / multi bulk count.</a>
<span class="lineNum">     501 </span>            :  * Basically this is used to output &lt;prefix&gt;&lt;long long&gt;&lt;crlf&gt;. */
<span class="lineNum">     502 </span><span class="lineCov">   12789246 : void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {</span>
<span class="lineNum">     503 </span><span class="lineCov">   12789246 :     char buf[128];</span>
<span class="lineNum">     504 </span><span class="lineCov">   12789246 :     int len;</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            :     /* Things like $3\r\n or *2\r\n are emitted very often by the protocol
<span class="lineNum">     507 </span>            :      * so we have a few shared objects to use if the integer is small
<span class="lineNum">     508 </span>            :      * like it is most of the times. */
<span class="lineNum">     509 </span><span class="lineCov">   12789246 :     if (prefix == '*' &amp;&amp; ll &lt; OBJ_SHARED_BULKHDR_LEN &amp;&amp; ll &gt;= 0) {</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :         addReply(c,shared.mbulkhdr[ll]);</span>
<span class="lineNum">     511 </span><span class="lineCov">    5896741 :         return;</span>
<span class="lineNum">     512 </span><span class="lineCov">   12789246 :     } else if (prefix == '$' &amp;&amp; ll &lt; OBJ_SHARED_BULKHDR_LEN &amp;&amp; ll &gt;= 0) {</span>
<span class="lineNum">     513 </span><span class="lineCov">    5896741 :         addReply(c,shared.bulkhdr[ll]);</span>
<span class="lineNum">     514 </span><span class="lineCov">    5896741 :         return;</span>
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">    6892505 :     buf[0] = prefix;</span>
<span class="lineNum">     518 </span><span class="lineCov">    6892505 :     len = ll2string(buf+1,sizeof(buf)-1,ll);</span>
<span class="lineNum">     519 </span><span class="lineCov">    6892505 :     buf[len+1] = '\r';</span>
<span class="lineNum">     520 </span><span class="lineCov">    6892505 :     buf[len+2] = '\n';</span>
<span class="lineNum">     521 </span><span class="lineCov">    6892505 :     addReplyString(c,buf,len+3);</span>
<a name="522"><span class="lineNum">     522 </span>            : }</a>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">   10369079 : void addReplyLongLong(client *c, long long ll) {</span>
<span class="lineNum">     525 </span><span class="lineCov">   10369079 :     if (ll == 0)</span>
<span class="lineNum">     526 </span><span class="lineCov">     965513 :         addReply(c,shared.czero);</span>
<span class="lineNum">     527 </span><span class="lineCov">    9403566 :     else if (ll == 1)</span>
<span class="lineNum">     528 </span><span class="lineCov">    4573893 :         addReply(c,shared.cone);</span>
<span class="lineNum">     529 </span>            :     else
<span class="lineNum">     530 </span><span class="lineCov">    4829673 :         addReplyLongLongWithPrefix(c,ll,':');</span>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">   10369079 : }</span></a>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineCov">   17971195 : void addReplyMultiBulkLen(client *c, long length) {</span>
<span class="lineNum">     534 </span><span class="lineCov">   17971195 :     if (length &lt; OBJ_SHARED_BULKHDR_LEN)</span>
<span class="lineNum">     535 </span><span class="lineCov">   17962645 :         addReply(c,shared.mbulkhdr[length]);</span>
<span class="lineNum">     536 </span>            :     else
<span class="lineNum">     537 </span><span class="lineCov">       8550 :         addReplyLongLongWithPrefix(c,length,'*');</span>
<span class="lineNum">     538 </span><span class="lineCov">   17971195 : }</span>
<a name="539"><span class="lineNum">     539 </span>            : </a>
<span class="lineNum">     540 </span>            : /* Create the length prefix of a bulk reply, example: $2234 */
<span class="lineNum">     541 </span><span class="lineCov">   46694694 : void addReplyBulkLen(client *c, robj *obj) {</span>
<span class="lineNum">     542 </span><span class="lineCov">   46694694 :     size_t len;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span><span class="lineCov">   46694694 :     if (sdsEncodedObject(obj)) {</span>
<span class="lineNum">     545 </span><span class="lineCov">   46051508 :         len = sdslen(obj-&gt;ptr);</span>
<span class="lineNum">     546 </span>            :     } else {
<span class="lineNum">     547 </span><span class="lineCov">     643186 :         long n = (long)obj-&gt;ptr;</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :         /* Compute how many bytes will take this integer as a radix 10 string */
<span class="lineNum">     550 </span><span class="lineCov">     643186 :         len = 1;</span>
<span class="lineNum">     551 </span><span class="lineCov">     643186 :         if (n &lt; 0) {</span>
<span class="lineNum">     552 </span><span class="lineCov">     247883 :             len++;</span>
<span class="lineNum">     553 </span><span class="lineCov">     247883 :             n = -n;</span>
<span class="lineNum">     554 </span>            :         }
<span class="lineNum">     555 </span><span class="lineCov">    4611651 :         while((n = n/10) != 0) {</span>
<span class="lineNum">     556 </span><span class="lineCov">    3968465 :             len++;</span>
<span class="lineNum">     557 </span>            :         }
<span class="lineNum">     558 </span>            :     }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">   46694694 :     if (len &lt; OBJ_SHARED_BULKHDR_LEN)</span>
<span class="lineNum">     561 </span><span class="lineCov">   45667409 :         addReply(c,shared.bulkhdr[len]);</span>
<span class="lineNum">     562 </span>            :     else
<span class="lineNum">     563 </span><span class="lineCov">    1027285 :         addReplyLongLongWithPrefix(c,len,'$');</span>
<span class="lineNum">     564 </span><span class="lineCov">   46694694 : }</span>
<a name="565"><span class="lineNum">     565 </span>            : </a>
<span class="lineNum">     566 </span>            : /* Add a Redis Object as a bulk reply */
<span class="lineNum">     567 </span><span class="lineCov">   46694694 : void addReplyBulk(client *c, robj *obj) {</span>
<span class="lineNum">     568 </span><span class="lineCov">   46694694 :     addReplyBulkLen(c,obj);</span>
<span class="lineNum">     569 </span><span class="lineCov">   46694694 :     addReply(c,obj);</span>
<span class="lineNum">     570 </span><span class="lineCov">   46694694 :     addReply(c,shared.crlf);</span>
<span class="lineNum">     571 </span><span class="lineCov">   46694694 : }</span>
<a name="572"><span class="lineNum">     572 </span>            : </a>
<span class="lineNum">     573 </span>            : /* Add a C buffer as bulk reply */
<span class="lineNum">     574 </span><span class="lineCov">    5962545 : void addReplyBulkCBuffer(client *c, const void *p, size_t len) {</span>
<span class="lineNum">     575 </span><span class="lineCov">    5962545 :     addReplyLongLongWithPrefix(c,len,'$');</span>
<span class="lineNum">     576 </span><span class="lineCov">    5962545 :     addReplyString(c,p,len);</span>
<span class="lineNum">     577 </span><span class="lineCov">    5962545 :     addReply(c,shared.crlf);</span>
<span class="lineNum">     578 </span><span class="lineCov">    5962545 : }</span>
<a name="579"><span class="lineNum">     579 </span>            : </a>
<span class="lineNum">     580 </span>            : /* Add sds to reply (takes ownership of sds and frees it) */
<span class="lineNum">     581 </span><span class="lineCov">     961193 : void addReplyBulkSds(client *c, sds s)  {</span>
<span class="lineNum">     582 </span><span class="lineCov">    1922386 :     addReplyLongLongWithPrefix(c,sdslen(s),'$');</span>
<span class="lineNum">     583 </span><span class="lineCov">     961193 :     addReplySds(c,s);</span>
<span class="lineNum">     584 </span><span class="lineCov">     961193 :     addReply(c,shared.crlf);</span>
<span class="lineNum">     585 </span><span class="lineCov">     961193 : }</span>
<a name="586"><span class="lineNum">     586 </span>            : </a>
<span class="lineNum">     587 </span>            : /* Add a C null term string as bulk reply */
<span class="lineNum">     588 </span><span class="lineCov">      47647 : void addReplyBulkCString(client *c, const char *s) {</span>
<span class="lineNum">     589 </span><span class="lineCov">      47647 :     if (s == NULL) {</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         addReply(c,shared.nullbulk);</span>
<span class="lineNum">     591 </span>            :     } else {
<span class="lineNum">     592 </span><span class="lineCov">      47647 :         addReplyBulkCBuffer(c,s,strlen(s));</span>
<span class="lineNum">     593 </span>            :     }
<span class="lineNum">     594 </span><span class="lineCov">      47647 : }</span>
<a name="595"><span class="lineNum">     595 </span>            : </a>
<span class="lineNum">     596 </span>            : /* Add a long long as a bulk reply */
<span class="lineNum">     597 </span><span class="lineCov">    2762429 : void addReplyBulkLongLong(client *c, long long ll) {</span>
<span class="lineNum">     598 </span><span class="lineCov">    2762429 :     char buf[64];</span>
<span class="lineNum">     599 </span><span class="lineCov">    2762429 :     int len;</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">    2762429 :     len = ll2string(buf,64,ll);</span>
<span class="lineNum">     602 </span><span class="lineCov">    2762429 :     addReplyBulkCBuffer(c,buf,len);</span>
<span class="lineNum">     603 </span><span class="lineCov">    2762429 : }</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : /* Add an array of C strings as status replies with a heading.
<span class="lineNum">     606 </span>            :  * This function is typically invoked by from commands that support
<a name="607"><span class="lineNum">     607 </span>            :  * subcommands in response to the 'help' subcommand. The help array</a>
<span class="lineNum">     608 </span>            :  * is terminated by NULL sentinel. */
<span class="lineNum">     609 </span><span class="lineNoCov">          0 : void addReplyHelp(client *c, const char **help) {</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     sds cmd = sdsnew((char*) c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :     void *blenp = addDeferredMultiBulkLength(c);</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     int blen = 0;</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :     sdstoupper(cmd);</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :     addReplyStatusFormat(c,</span>
<span class="lineNum">     616 </span>            :         &quot;%s &lt;subcommand&gt; arg arg ... arg. Subcommands are:&quot;,cmd);
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     sdsfree(cmd);</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     while (help[blen]) addReplyStatus(c,help[blen++]);</span>
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     blen++;  /* Account for the header line(s). */</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :     setDeferredMultiBulkLength(c,blenp,blen);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : /* Add a suggestive error reply.
<a name="626"><span class="lineNum">     626 </span>            :  * This function is typically invoked by from commands that support</a>
<span class="lineNum">     627 </span>            :  * subcommands in response to an unknown subcommand or argument error. */
<span class="lineNum">     628 </span><span class="lineNoCov">          0 : void addReplySubcommandSyntaxError(client *c) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     sds cmd = sdsnew((char*) c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     sdstoupper(cmd);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     addReplyErrorFormat(c,</span>
<span class="lineNum">     632 </span>            :         &quot;Unknown subcommand or wrong number of arguments for '%s'. Try %s HELP.&quot;,
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         (char*)c-&gt;argv[1]-&gt;ptr,cmd);</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     sdsfree(cmd);</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : /* Copy 'src' client output buffers into 'dst' client output buffers.
<a name="638"><span class="lineNum">     638 </span>            :  * The function takes care of freeing the old output buffers of the</a>
<span class="lineNum">     639 </span>            :  * destination client. */
<span class="lineNum">     640 </span><span class="lineCov">          6 : void copyClientOutputBuffer(client *dst, client *src) {</span>
<span class="lineNum">     641 </span><span class="lineCov">          6 :     listRelease(dst-&gt;reply);</span>
<span class="lineNum">     642 </span><span class="lineCov">          6 :     dst-&gt;sentlen = 0;</span>
<span class="lineNum">     643 </span><span class="lineCov">          6 :     dst-&gt;reply = listDup(src-&gt;reply);</span>
<span class="lineNum">     644 </span><span class="lineCov">         12 :     memcpy(dst-&gt;buf,src-&gt;buf,src-&gt;bufpos);</span>
<span class="lineNum">     645 </span><span class="lineCov">          6 :     dst-&gt;bufpos = src-&gt;bufpos;</span>
<span class="lineNum">     646 </span><span class="lineCov">          6 :     dst-&gt;reply_bytes = src-&gt;reply_bytes;</span>
<span class="lineNum">     647 </span><span class="lineCov">          6 : }</span>
<span class="lineNum">     648 </span>            : 
<a name="649"><span class="lineNum">     649 </span>            : /* Return true if the specified client has pending reply buffers to write to</a>
<span class="lineNum">     650 </span>            :  * the socket. */
<span class="lineNum">     651 </span><span class="lineCov">        637 : int clientHasPendingReplies(client *c) {</span>
<span class="lineNum">     652 </span><span class="lineCov">  310708875 :     return c-&gt;bufpos || listLength(c-&gt;reply);</span>
<span class="lineNum">     653 </span>            : }
<a name="654"><span class="lineNum">     654 </span>            : </a>
<span class="lineNum">     655 </span>            : #define MAX_ACCEPTS_PER_CALL 1000
<span class="lineNum">     656 </span><span class="lineCov">       2766 : static void acceptCommonHandler(int fd, int flags, char *ip) {</span>
<span class="lineNum">     657 </span><span class="lineCov">       2766 :     client *c;</span>
<span class="lineNum">     658 </span><span class="lineCov">       2766 :     if ((c = createClient(fd)) == NULL) {</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">     660 </span>            :             &quot;Error registering fd event for the new client: %s (fd=%d)&quot;,
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :             strerror(errno),fd);</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         close(fd); /* May be already closed, just ignore errors */</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span>            :     /* If maxclient directive is set and this is one client more... close the
<span class="lineNum">     666 </span>            :      * connection. Note that we create the client instead to check before
<span class="lineNum">     667 </span>            :      * for this condition, since now the socket is already set in non-blocking
<span class="lineNum">     668 </span>            :      * mode and we can send an error for free using the Kernel I/O */
<span class="lineNum">     669 </span><span class="lineCov">       2766 :     if (listLength(server.clients) &gt; server.maxclients) {</span>
<span class="lineNum">     670 </span><span class="lineCov">          2 :         char *err = &quot;-ERR max number of clients reached\r\n&quot;;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :         /* That's a best effort error message, don't check write errors */
<span class="lineNum">     673 </span><span class="lineCov">          2 :         if (write(c-&gt;fd,err,strlen(err)) == -1) {</span>
<span class="lineNum">     674 </span>            :             /* Nothing to do, Just to avoid the warning... */
<span class="lineNum">     675 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">     676 </span><span class="lineCov">          2 :         server.stat_rejected_conn++;</span>
<span class="lineNum">     677 </span><span class="lineCov">          2 :         freeClient(c);</span>
<span class="lineNum">     678 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">     679 </span>            :     }
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :     /* If the server is running in protected mode (the default) and there
<span class="lineNum">     682 </span>            :      * is no password set, nor a specific interface is bound, we don't accept
<span class="lineNum">     683 </span>            :      * requests from non loopback interfaces. Instead we try to explain the
<span class="lineNum">     684 </span>            :      * user what to do to fix it if needed. */
<span class="lineNum">     685 </span><span class="lineCov">       2764 :     if (server.protected_mode &amp;&amp;</span>
<span class="lineNum">     686 </span><span class="lineCov">       2764 :         server.bindaddr_count == 0 &amp;&amp;</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :         server.requirepass == NULL &amp;&amp;</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :         !(flags &amp; CLIENT_UNIX_SOCKET) &amp;&amp;</span>
<span class="lineNum">     689 </span>            :         ip != NULL)
<span class="lineNum">     690 </span>            :     {
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         if (strcmp(ip,&quot;127.0.0.1&quot;) &amp;&amp; strcmp(ip,&quot;::1&quot;)) {</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :             char *err =</span>
<span class="lineNum">     693 </span>            :                 &quot;-DENIED Redis is running in protected mode because protected &quot;
<span class="lineNum">     694 </span>            :                 &quot;mode is enabled, no bind address was specified, no &quot;
<span class="lineNum">     695 </span>            :                 &quot;authentication password is requested to clients. In this mode &quot;
<span class="lineNum">     696 </span>            :                 &quot;connections are only accepted from the loopback interface. &quot;
<span class="lineNum">     697 </span>            :                 &quot;If you want to connect from external computers to Redis you &quot;
<span class="lineNum">     698 </span>            :                 &quot;may adopt one of the following solutions: &quot;
<span class="lineNum">     699 </span>            :                 &quot;1) Just disable protected mode sending the command &quot;
<span class="lineNum">     700 </span>            :                 &quot;'CONFIG SET protected-mode no' from the loopback interface &quot;
<span class="lineNum">     701 </span>            :                 &quot;by connecting to Redis from the same host the server is &quot;
<span class="lineNum">     702 </span>            :                 &quot;running, however MAKE SURE Redis is not publicly accessible &quot;
<span class="lineNum">     703 </span>            :                 &quot;from internet if you do so. Use CONFIG REWRITE to make this &quot;
<span class="lineNum">     704 </span>            :                 &quot;change permanent. &quot;
<span class="lineNum">     705 </span>            :                 &quot;2) Alternatively you can just disable the protected mode by &quot;
<span class="lineNum">     706 </span>            :                 &quot;editing the Redis configuration file, and setting the protected &quot;
<span class="lineNum">     707 </span>            :                 &quot;mode option to 'no', and then restarting the server. &quot;
<span class="lineNum">     708 </span>            :                 &quot;3) If you started the server manually just for testing, restart &quot;
<span class="lineNum">     709 </span>            :                 &quot;it with the '--protected-mode no' option. &quot;
<span class="lineNum">     710 </span>            :                 &quot;4) Setup a bind address or an authentication password. &quot;
<span class="lineNum">     711 </span>            :                 &quot;NOTE: You only need to do one of the above things in order for &quot;
<span class="lineNum">     712 </span>            :                 &quot;the server to start accepting connections from the outside.\r\n&quot;;
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :             if (write(c-&gt;fd,err,strlen(err)) == -1) {</span>
<span class="lineNum">     714 </span>            :                 /* Nothing to do, Just to avoid the warning... */
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :             server.stat_rejected_conn++;</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :             freeClient(c);</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     719 </span>            :         }
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineCov">       2764 :     server.stat_numconnections++;</span>
<span class="lineNum">     723 </span><span class="lineCov">       2764 :     c-&gt;flags |= flags;</span>
<a name="724"><span class="lineNum">     724 </span>            : }</a>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">       2757 : void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {</span>
<span class="lineNum">     727 </span><span class="lineCov">       2757 :     int cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span>
<span class="lineNum">     728 </span><span class="lineCov">       2757 :     char cip[NET_IP_STR_LEN];</span>
<span class="lineNum">     729 </span><span class="lineCov">       2757 :     UNUSED(el);</span>
<span class="lineNum">     730 </span><span class="lineCov">       2757 :     UNUSED(mask);</span>
<span class="lineNum">     731 </span><span class="lineCov">       2757 :     UNUSED(privdata);</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">       5523 :     while(max--) {</span>
<span class="lineNum">     734 </span><span class="lineCov">       5523 :         cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;cport);</span>
<span class="lineNum">     735 </span><span class="lineCov">       5523 :         if (cfd == ANET_ERR) {</span>
<span class="lineNum">     736 </span><span class="lineCov">       2757 :             if (errno != EWOULDBLOCK)</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING,</span>
<span class="lineNum">     738 </span>            :                     &quot;Accepting client connection: %s&quot;, server.neterr);
<span class="lineNum">     739 </span><span class="lineCov">       2757 :             return;</span>
<span class="lineNum">     740 </span>            :         }
<span class="lineNum">     741 </span><span class="lineCov">       2766 :         serverLog(LL_VERBOSE,&quot;Accepted %s:%d&quot;, cip, cport);</span>
<span class="lineNum">     742 </span><span class="lineCov">       2766 :         acceptCommonHandler(cfd,0,cip);</span>
<span class="lineNum">     743 </span>            :     }
<a name="744"><span class="lineNum">     744 </span>            : }</a>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineNoCov">          0 : void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :     int cfd, max = MAX_ACCEPTS_PER_CALL;</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :     UNUSED(el);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :     UNUSED(mask);</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :     UNUSED(privdata);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     while(max--) {</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         cfd = anetUnixAccept(server.neterr, fd);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :         if (cfd == ANET_ERR) {</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :             if (errno != EWOULDBLOCK)</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING,</span>
<span class="lineNum">     757 </span>            :                     &quot;Accepting client connection: %s&quot;, server.neterr);
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">     759 </span>            :         }
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         serverLog(LL_VERBOSE,&quot;Accepted connection to %s&quot;, server.unixsocket);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :         acceptCommonHandler(cfd,CLIENT_UNIX_SOCKET,NULL);</span>
<span class="lineNum">     762 </span>            :     }
<a name="763"><span class="lineNum">     763 </span>            : }</a>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineCov">   55432301 : static void freeClientArgv(client *c) {</span>
<span class="lineNum">     766 </span><span class="lineCov">   55432301 :     int j;</span>
<span class="lineNum">     767 </span><span class="lineCov">  216130278 :     for (j = 0; j &lt; c-&gt;argc; j++)</span>
<span class="lineNum">     768 </span><span class="lineCov">  160697977 :         decrRefCount(c-&gt;argv[j]);</span>
<span class="lineNum">     769 </span><span class="lineCov">   55432301 :     c-&gt;argc = 0;</span>
<span class="lineNum">     770 </span><span class="lineCov">   55432301 :     c-&gt;cmd = NULL;</span>
<span class="lineNum">     771 </span><span class="lineCov">   55432301 : }</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span>            : /* Close all the slaves connections. This is useful in chained replication
<a name="774"><span class="lineNum">     774 </span>            :  * when we resync with our own master and want to force all our slaves to</a>
<span class="lineNum">     775 </span>            :  * resync with us as well. */
<span class="lineNum">     776 </span><span class="lineCov">        358 : void disconnectSlaves(void) {</span>
<span class="lineNum">     777 </span><span class="lineCov">        378 :     while (listLength(server.slaves)) {</span>
<span class="lineNum">     778 </span><span class="lineCov">         20 :         listNode *ln = listFirst(server.slaves);</span>
<span class="lineNum">     779 </span><span class="lineCov">         20 :         freeClient((client*)ln-&gt;value);</span>
<span class="lineNum">     780 </span>            :     }
<span class="lineNum">     781 </span><span class="lineCov">        358 : }</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            : /* Remove the specified client from global lists where the client could
<a name="784"><span class="lineNum">     784 </span>            :  * be referenced, not including the Pub/Sub channels.</a>
<span class="lineNum">     785 </span>            :  * This is used by freeClient() and replicationCacheMaster(). */
<span class="lineNum">     786 </span><span class="lineCov">       1872 : void unlinkClient(client *c) {</span>
<span class="lineNum">     787 </span><span class="lineCov">       1872 :     listNode *ln;</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span>            :     /* If this is marked as current client unset it. */
<span class="lineNum">     790 </span><span class="lineCov">       1872 :     if (server.current_client == c) server.current_client = NULL;</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :     /* Certain operations must be done only if the client has an active socket.
<span class="lineNum">     793 </span>            :      * If the client was already unlinked or if it's a &quot;fake client&quot; the
<span class="lineNum">     794 </span>            :      * fd is already set to -1. */
<span class="lineNum">     795 </span><span class="lineCov">       1872 :     if (c-&gt;fd != -1) {</span>
<span class="lineNum">     796 </span>            :         /* Remove from the list of active clients. */
<span class="lineNum">     797 </span><span class="lineCov">       1570 :         if (c-&gt;client_list_node) {</span>
<span class="lineNum">     798 </span><span class="lineCov">       1570 :             uint64_t id = htonu64(c-&gt;id);</span>
<span class="lineNum">     799 </span><span class="lineCov">       1570 :             raxRemove(server.clients_index,(unsigned char*)&amp;id,sizeof(id),NULL);</span>
<span class="lineNum">     800 </span><span class="lineCov">       1570 :             listDelNode(server.clients,c-&gt;client_list_node);</span>
<span class="lineNum">     801 </span><span class="lineCov">       1570 :             c-&gt;client_list_node = NULL;</span>
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :         /* Unregister async I/O handlers and close the socket. */
<span class="lineNum">     805 </span><span class="lineCov">       1570 :         aeDeleteFileEvent(server.el,c-&gt;fd,AE_READABLE);</span>
<span class="lineNum">     806 </span><span class="lineCov">       1570 :         aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span>
<span class="lineNum">     807 </span><span class="lineCov">       1570 :         close(c-&gt;fd);</span>
<span class="lineNum">     808 </span><span class="lineCov">       1570 :         c-&gt;fd = -1;</span>
<span class="lineNum">     809 </span>            :     }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :     /* Remove from the list of pending writes if needed. */
<span class="lineNum">     812 </span><span class="lineCov">       1872 :     if (c-&gt;flags &amp; CLIENT_PENDING_WRITE) {</span>
<span class="lineNum">     813 </span><span class="lineCov">         29 :         ln = listSearchKey(server.clients_pending_write,c);</span>
<span class="lineNum">     814 </span><span class="lineCov">         29 :         serverAssert(ln != NULL);</span>
<span class="lineNum">     815 </span><span class="lineCov">         29 :         listDelNode(server.clients_pending_write,ln);</span>
<span class="lineNum">     816 </span><span class="lineCov">         29 :         c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span>
<span class="lineNum">     817 </span>            :     }
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span>            :     /* When client was just unblocked because of a blocking operation,
<span class="lineNum">     820 </span>            :      * remove it from the list of unblocked clients. */
<span class="lineNum">     821 </span><span class="lineCov">       1872 :     if (c-&gt;flags &amp; CLIENT_UNBLOCKED) {</span>
<span class="lineNum">     822 </span><span class="lineCov">         12 :         ln = listSearchKey(server.unblocked_clients,c);</span>
<span class="lineNum">     823 </span><span class="lineCov">         12 :         serverAssert(ln != NULL);</span>
<span class="lineNum">     824 </span><span class="lineCov">         12 :         listDelNode(server.unblocked_clients,ln);</span>
<span class="lineNum">     825 </span><span class="lineCov">         12 :         c-&gt;flags &amp;= ~CLIENT_UNBLOCKED;</span>
<span class="lineNum">     826 </span>            :     }
<a name="827"><span class="lineNum">     827 </span><span class="lineCov">       1872 : }</span></a>
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span><span class="lineCov">       1736 : void freeClient(client *c) {</span>
<span class="lineNum">     830 </span><span class="lineCov">       1736 :     listNode *ln;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :     /* If a client is protected, yet we need to free it right now, make sure
<span class="lineNum">     833 </span>            :      * to at least use asynchronous freeing. */
<span class="lineNum">     834 </span><span class="lineCov">       1736 :     if (c-&gt;flags &amp; CLIENT_PROTECTED) {</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :         freeClientAsync(c);</span>
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     837 </span>            :     }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            :     /* If it is our master that's beging disconnected we should make sure
<span class="lineNum">     840 </span>            :      * to cache the state to try a partial resynchronization later.
<span class="lineNum">     841 </span>            :      *
<span class="lineNum">     842 </span>            :      * Note that before doing this we make sure that the client is not in
<span class="lineNum">     843 </span>            :      * some unexpected state, by checking its flags. */
<span class="lineNum">     844 </span><span class="lineCov">       1736 :     if (server.master &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) {</span>
<span class="lineNum">     845 </span><span class="lineCov">        183 :         serverLog(LL_WARNING,&quot;Connection with master lost.&quot;);</span>
<span class="lineNum">     846 </span><span class="lineCov">        183 :         if (!(c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|</span>
<span class="lineNum">     847 </span>            :                           CLIENT_CLOSE_ASAP|
<span class="lineNum">     848 </span>            :                           CLIENT_BLOCKED)))
<span class="lineNum">     849 </span>            :         {
<span class="lineNum">     850 </span><span class="lineCov">        183 :             replicationCacheMaster(c);</span>
<span class="lineNum">     851 </span><span class="lineCov">        183 :             return;</span>
<span class="lineNum">     852 </span>            :         }
<span class="lineNum">     853 </span>            :     }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :     /* Log link disconnection with slave */
<span class="lineNum">     856 </span><span class="lineCov">       1553 :     if ((c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; !(c-&gt;flags &amp; CLIENT_MONITOR)) {</span>
<span class="lineNum">     857 </span><span class="lineCov">        322 :         serverLog(LL_WARNING,&quot;Connection with replica %s lost.&quot;,</span>
<span class="lineNum">     858 </span>            :             replicationGetSlaveName(c));
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     /* Free the query buffer */
<span class="lineNum">     862 </span><span class="lineCov">       1553 :     sdsfree(c-&gt;querybuf);</span>
<span class="lineNum">     863 </span><span class="lineCov">       1553 :     sdsfree(c-&gt;pending_querybuf);</span>
<span class="lineNum">     864 </span><span class="lineCov">       1553 :     c-&gt;querybuf = NULL;</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :     /* Deallocate structures used to block on blocking ops. */
<span class="lineNum">     867 </span><span class="lineCov">       1553 :     if (c-&gt;flags &amp; CLIENT_BLOCKED) unblockClient(c);</span>
<span class="lineNum">     868 </span><span class="lineCov">       1553 :     dictRelease(c-&gt;bpop.keys);</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            :     /* UNWATCH all the keys */
<span class="lineNum">     871 </span><span class="lineCov">       1553 :     unwatchAllKeys(c);</span>
<span class="lineNum">     872 </span><span class="lineCov">       1553 :     listRelease(c-&gt;watched_keys);</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :     /* Unsubscribe from all the pubsub channels */
<span class="lineNum">     875 </span><span class="lineCov">       1553 :     pubsubUnsubscribeAllChannels(c,0);</span>
<span class="lineNum">     876 </span><span class="lineCov">       1553 :     pubsubUnsubscribeAllPatterns(c,0);</span>
<span class="lineNum">     877 </span><span class="lineCov">       1553 :     dictRelease(c-&gt;pubsub_channels);</span>
<span class="lineNum">     878 </span><span class="lineCov">       1553 :     listRelease(c-&gt;pubsub_patterns);</span>
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            :     /* Free data structures. */
<span class="lineNum">     881 </span><span class="lineCov">       1553 :     listRelease(c-&gt;reply);</span>
<span class="lineNum">     882 </span><span class="lineCov">       1553 :     freeClientArgv(c);</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            :     /* Unlink the client: this will close the socket, remove the I/O
<span class="lineNum">     885 </span>            :      * handlers, and remove references of the client from different
<span class="lineNum">     886 </span>            :      * places where active clients may be referenced. */
<span class="lineNum">     887 </span><span class="lineCov">       1553 :     unlinkClient(c);</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :     /* Master/slave cleanup Case 1:
<span class="lineNum">     890 </span>            :      * we lost the connection with a slave. */
<span class="lineNum">     891 </span><span class="lineCov">       1553 :     if (c-&gt;flags &amp; CLIENT_SLAVE) {</span>
<span class="lineNum">     892 </span><span class="lineCov">        322 :         if (c-&gt;replstate == SLAVE_STATE_SEND_BULK) {</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :             if (c-&gt;repldbfd != -1) close(c-&gt;repldbfd);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :             if (c-&gt;replpreamble) sdsfree(c-&gt;replpreamble);</span>
<span class="lineNum">     895 </span>            :         }
<span class="lineNum">     896 </span><span class="lineCov">        322 :         list *l = (c-&gt;flags &amp; CLIENT_MONITOR) ? server.monitors : server.slaves;</span>
<span class="lineNum">     897 </span><span class="lineCov">        322 :         ln = listSearchKey(l,c);</span>
<span class="lineNum">     898 </span><span class="lineCov">        322 :         serverAssert(ln != NULL);</span>
<span class="lineNum">     899 </span><span class="lineCov">        322 :         listDelNode(l,ln);</span>
<span class="lineNum">     900 </span>            :         /* We need to remember the time when we started to have zero
<span class="lineNum">     901 </span>            :          * attached slaves, as after some time we'll free the replication
<span class="lineNum">     902 </span>            :          * backlog. */
<span class="lineNum">     903 </span><span class="lineCov">        322 :         if (c-&gt;flags &amp; CLIENT_SLAVE &amp;&amp; listLength(server.slaves) == 0)</span>
<span class="lineNum">     904 </span><span class="lineCov">        241 :             server.repl_no_slaves_since = server.unixtime;</span>
<span class="lineNum">     905 </span><span class="lineCov">        322 :         refreshGoodSlavesCount();</span>
<span class="lineNum">     906 </span>            :     }
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            :     /* Master/slave cleanup Case 2:
<span class="lineNum">     909 </span>            :      * we lost the connection with the master. */
<span class="lineNum">     910 </span><span class="lineCov">       1553 :     if (c-&gt;flags &amp; CLIENT_MASTER) replicationHandleMasterDisconnection();</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :     /* If this client was scheduled for async freeing we need to remove it
<span class="lineNum">     913 </span>            :      * from the queue. */
<span class="lineNum">     914 </span><span class="lineCov">       1553 :     if (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) {</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :         ln = listSearchKey(server.clients_to_close,c);</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         serverAssert(ln != NULL);</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         listDelNode(server.clients_to_close,ln);</span>
<span class="lineNum">     918 </span>            :     }
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            :     /* Release other dynamically allocated client structure fields,
<span class="lineNum">     921 </span>            :      * and finally release the client structure itself. */
<span class="lineNum">     922 </span><span class="lineCov">       1553 :     if (c-&gt;name) decrRefCount(c-&gt;name);</span>
<span class="lineNum">     923 </span><span class="lineCov">       1553 :     zfree(c-&gt;argv);</span>
<span class="lineNum">     924 </span><span class="lineCov">       1553 :     freeClientMultiState(c);</span>
<span class="lineNum">     925 </span><span class="lineCov">       1553 :     sdsfree(c-&gt;peerid);</span>
<span class="lineNum">     926 </span><span class="lineCov">       1553 :     zfree(c);</span>
<span class="lineNum">     927 </span>            : }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            : /* Schedule a client to free it at a safe time in the serverCron() function.
<span class="lineNum">     930 </span>            :  * This function is useful when we need to terminate a client but we are in
<a name="931"><span class="lineNum">     931 </span>            :  * a context where calling freeClient() is not possible, because the client</a>
<span class="lineNum">     932 </span>            :  * should be valid for the continuation of the flow of the program. */
<span class="lineNum">     933 </span><span class="lineNoCov">          0 : void freeClientAsync(client *c) {</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     if (c-&gt;flags &amp; CLIENT_CLOSE_ASAP || c-&gt;flags &amp; CLIENT_LUA) return;</span>
<span class="lineNum">     935 </span><span class="lineCov">          4 :     c-&gt;flags |= CLIENT_CLOSE_ASAP;</span>
<span class="lineNum">     936 </span><span class="lineCov">          4 :     listAddNodeTail(server.clients_to_close,c);</span>
<a name="937"><span class="lineNum">     937 </span>            : }</a>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span><span class="lineCov">      42507 : void freeClientsInAsyncFreeQueue(void) {</span>
<span class="lineNum">     940 </span><span class="lineCov">      42511 :     while (listLength(server.clients_to_close)) {</span>
<span class="lineNum">     941 </span><span class="lineCov">          4 :         listNode *ln = listFirst(server.clients_to_close);</span>
<span class="lineNum">     942 </span><span class="lineCov">          4 :         client *c = listNodeValue(ln);</span>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineCov">          4 :         c-&gt;flags &amp;= ~CLIENT_CLOSE_ASAP;</span>
<span class="lineNum">     945 </span><span class="lineCov">          4 :         freeClient(c);</span>
<span class="lineNum">     946 </span><span class="lineCov">          4 :         listDelNode(server.clients_to_close,ln);</span>
<span class="lineNum">     947 </span>            :     }
<span class="lineNum">     948 </span><span class="lineCov">      42507 : }</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            : /* Return a client by ID, or NULL if the client ID is not in the set
<a name="951"><span class="lineNum">     951 </span>            :  * of registered clients. Note that &quot;fake clients&quot;, created with -1 as FD,</a>
<span class="lineNum">     952 </span>            :  * are not registered clients. */
<span class="lineNum">     953 </span><span class="lineNoCov">          0 : client *lookupClientByID(uint64_t id) {</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     id = htonu64(id);</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     client *c = raxFind(server.clients_index,(unsigned char*)&amp;id,sizeof(id));</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     return (c == raxNotFound) ? NULL : c;</span>
<span class="lineNum">     957 </span>            : }
<span class="lineNum">     958 </span>            : 
<a name="959"><span class="lineNum">     959 </span>            : /* Write data in output buffers to client. Return C_OK if the client</a>
<span class="lineNum">     960 </span>            :  * is still valid after the call, C_ERR if it was freed. */
<span class="lineNum">     961 </span><span class="lineCov">   25403484 : int writeToClient(int fd, client *c, int handler_installed) {</span>
<span class="lineNum">     962 </span><span class="lineCov">   25403484 :     ssize_t nwritten = 0, totwritten = 0;</span>
<span class="lineNum">     963 </span><span class="lineCov">   25403484 :     size_t objlen;</span>
<span class="lineNum">     964 </span><span class="lineCov">   25403484 :     clientReplyBlock *o;</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineCov">   50831138 :     while(clientHasPendingReplies(c)) {</span>
<span class="lineNum">     967 </span><span class="lineCov">   25431571 :         if (c-&gt;bufpos &gt; 0) {</span>
<span class="lineNum">     968 </span><span class="lineCov">   25396623 :             nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span>
<span class="lineNum">     969 </span><span class="lineCov">   25396623 :             if (nwritten &lt;= 0) break;</span>
<span class="lineNum">     970 </span><span class="lineCov">   25396528 :             c-&gt;sentlen += nwritten;</span>
<span class="lineNum">     971 </span><span class="lineCov">   25396528 :             totwritten += nwritten;</span>
<span class="lineNum">     972 </span>            : 
<span class="lineNum">     973 </span>            :             /* If the buffer was sent, set bufpos to zero to continue with
<span class="lineNum">     974 </span>            :              * the remainder of the reply. */
<span class="lineNum">     975 </span><span class="lineCov">   25396528 :             if ((int)c-&gt;sentlen == c-&gt;bufpos) {</span>
<span class="lineNum">     976 </span><span class="lineCov">   25396515 :                 c-&gt;bufpos = 0;</span>
<span class="lineNum">     977 </span><span class="lineCov">   25396515 :                 c-&gt;sentlen = 0;</span>
<span class="lineNum">     978 </span>            :             }
<span class="lineNum">     979 </span>            :         } else {
<span class="lineNum">     980 </span><span class="lineCov">      34948 :             o = listNodeValue(listFirst(c-&gt;reply));</span>
<span class="lineNum">     981 </span><span class="lineCov">      34948 :             objlen = o-&gt;used;</span>
<span class="lineNum">     982 </span>            : 
<span class="lineNum">     983 </span><span class="lineCov">      34948 :             if (objlen == 0) {</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                 c-&gt;reply_bytes -= o-&gt;size;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     987 </span>            :             }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineCov">      34948 :             nwritten = write(fd, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);</span>
<span class="lineNum">     990 </span><span class="lineCov">      34948 :             if (nwritten &lt;= 0) break;</span>
<span class="lineNum">     991 </span><span class="lineCov">      34698 :             c-&gt;sentlen += nwritten;</span>
<span class="lineNum">     992 </span><span class="lineCov">      34698 :             totwritten += nwritten;</span>
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :             /* If we fully sent the object on head go to the next one */
<span class="lineNum">     995 </span><span class="lineCov">      34698 :             if (c-&gt;sentlen == objlen) {</span>
<span class="lineNum">     996 </span><span class="lineCov">      34445 :                 c-&gt;reply_bytes -= o-&gt;size;</span>
<span class="lineNum">     997 </span><span class="lineCov">      34445 :                 listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span>
<span class="lineNum">     998 </span><span class="lineCov">      34445 :                 c-&gt;sentlen = 0;</span>
<span class="lineNum">     999 </span>            :                 /* If there are no longer objects in the list, we expect
<span class="lineNum">    1000 </span>            :                  * the count of reply bytes to be exactly zero. */
<span class="lineNum">    1001 </span><span class="lineCov">      34445 :                 if (listLength(c-&gt;reply) == 0)</span>
<span class="lineNum">    1002 </span><span class="lineCov">      10767 :                     serverAssert(c-&gt;reply_bytes == 0);</span>
<span class="lineNum">    1003 </span>            :             }
<span class="lineNum">    1004 </span>            :         }
<span class="lineNum">    1005 </span>            :         /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
<span class="lineNum">    1006 </span>            :          * bytes, in a single threaded server it's a good idea to serve
<span class="lineNum">    1007 </span>            :          * other clients as well, even if a very large request comes from
<span class="lineNum">    1008 </span>            :          * super fast link that is always able to accept data (in real world
<span class="lineNum">    1009 </span>            :          * scenario think about 'KEYS *' against the loopback interface).
<span class="lineNum">    1010 </span>            :          *
<span class="lineNum">    1011 </span>            :          * However if we are over the maxmemory limit we ignore that and
<span class="lineNum">    1012 </span>            :          * just deliver as much data as it is possible to deliver.
<span class="lineNum">    1013 </span>            :          *
<span class="lineNum">    1014 </span>            :          * Moreover, we also send as much as possible if the client is
<span class="lineNum">    1015 </span>            :          * a slave (otherwise, on high-speed traffic, the replication
<span class="lineNum">    1016 </span>            :          * buffer will grow indefinitely) */
<span class="lineNum">    1017 </span><span class="lineCov">   25431226 :         if (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span>
<span class="lineNum">    1018 </span><span class="lineCov">      24107 :             (server.maxmemory == 0 ||</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :              zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp;</span>
<span class="lineNum">    1020 </span><span class="lineCov">      24107 :             !(c-&gt;flags &amp; CLIENT_SLAVE)) break;</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span><span class="lineCov">   25403484 :     server.stat_net_output_bytes += totwritten;</span>
<span class="lineNum">    1023 </span><span class="lineCov">   25403484 :     if (nwritten == -1) {</span>
<span class="lineNum">    1024 </span><span class="lineCov">        345 :         if (errno == EAGAIN) {</span>
<span class="lineNum">    1025 </span>            :             nwritten = 0;
<span class="lineNum">    1026 </span>            :         } else {
<span class="lineNum">    1027 </span><span class="lineCov">         82 :             serverLog(LL_VERBOSE,</span>
<span class="lineNum">    1028 </span>            :                 &quot;Error writing to client: %s&quot;, strerror(errno));
<span class="lineNum">    1029 </span><span class="lineCov">         82 :             freeClient(c);</span>
<span class="lineNum">    1030 </span><span class="lineCov">         82 :             return C_ERR;</span>
<span class="lineNum">    1031 </span>            :         }
<span class="lineNum">    1032 </span>            :     }
<span class="lineNum">    1033 </span><span class="lineCov">   25403402 :     if (totwritten &gt; 0) {</span>
<span class="lineNum">    1034 </span>            :         /* For clients representing masters we don't count sending data
<span class="lineNum">    1035 </span>            :          * as an interaction, since we always send REPLCONF ACK commands
<span class="lineNum">    1036 </span>            :          * that take some time to just fill the socket output buffer.
<span class="lineNum">    1037 </span>            :          * We just rely on data / pings received for timeout detection. */
<span class="lineNum">    1038 </span><span class="lineCov">   25403289 :         if (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span>
<span class="lineNum">    1039 </span>            :     }
<span class="lineNum">    1040 </span><span class="lineCov">   25403402 :     if (!clientHasPendingReplies(c)) {</span>
<span class="lineNum">    1041 </span><span class="lineCov">   25402704 :         c-&gt;sentlen = 0;</span>
<span class="lineNum">    1042 </span><span class="lineCov">   25402704 :         if (handler_installed) aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span>
<span class="lineNum">    1043 </span>            : 
<span class="lineNum">    1044 </span>            :         /* Close connection after entire reply has been sent. */
<span class="lineNum">    1045 </span><span class="lineCov">   25402704 :         if (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) {</span>
<span class="lineNum">    1046 </span><span class="lineCov">         42 :             freeClient(c);</span>
<span class="lineNum">    1047 </span><span class="lineCov">         42 :             return C_ERR;</span>
<span class="lineNum">    1048 </span>            :         }
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span>            :     return C_OK;
<span class="lineNum">    1051 </span>            : }
<a name="1052"><span class="lineNum">    1052 </span>            : </a>
<span class="lineNum">    1053 </span>            : /* Write event handler. Just send data to the client. */
<span class="lineNum">    1054 </span><span class="lineCov">        909 : void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {</span>
<span class="lineNum">    1055 </span><span class="lineCov">        909 :     UNUSED(el);</span>
<span class="lineNum">    1056 </span><span class="lineCov">        909 :     UNUSED(mask);</span>
<span class="lineNum">    1057 </span><span class="lineCov">        909 :     writeToClient(fd,privdata,1);</span>
<span class="lineNum">    1058 </span><span class="lineCov">        909 : }</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : /* This function is called just before entering the event loop, in the hope
<span class="lineNum">    1061 </span>            :  * we can just write the replies to the client output buffer without any
<a name="1062"><span class="lineNum">    1062 </span>            :  * need to use a syscall in order to install the writable event handler,</a>
<span class="lineNum">    1063 </span>            :  * get it called, and so forth. */
<span class="lineNum">    1064 </span><span class="lineCov">   22808544 : int handleClientsWithPendingWrites(void) {</span>
<span class="lineNum">    1065 </span><span class="lineCov">   22808544 :     listIter li;</span>
<span class="lineNum">    1066 </span><span class="lineCov">   22808544 :     listNode *ln;</span>
<span class="lineNum">    1067 </span><span class="lineCov">   22808544 :     int processed = listLength(server.clients_pending_write);</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineCov">   22808544 :     listRewind(server.clients_pending_write,&amp;li);</span>
<span class="lineNum">    1070 </span><span class="lineCov">   48211119 :     while((ln = listNext(&amp;li))) {</span>
<span class="lineNum">    1071 </span><span class="lineCov">   25402575 :         client *c = listNodeValue(ln);</span>
<span class="lineNum">    1072 </span><span class="lineCov">   25402575 :         c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;</span>
<span class="lineNum">    1073 </span><span class="lineCov">   25402575 :         listDelNode(server.clients_pending_write,ln);</span>
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :         /* If a client is protected, don't do anything,
<span class="lineNum">    1076 </span>            :          * that may trigger write error or recreate handler. */
<span class="lineNum">    1077 </span><span class="lineCov">   25402575 :         if (c-&gt;flags &amp; CLIENT_PROTECTED) continue;</span>
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            :         /* Try to write buffers to the client socket. */
<span class="lineNum">    1080 </span><span class="lineCov">   25402575 :         if (writeToClient(c-&gt;fd,c,0) == C_ERR) continue;</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            :         /* If after the synchronous writes above we still have data to
<span class="lineNum">    1083 </span>            :          * output to the client, we need to install the writable handler. */
<span class="lineNum">    1084 </span><span class="lineCov">   25402451 :         if (clientHasPendingReplies(c)) {</span>
<span class="lineNum">    1085 </span><span class="lineCov">        187 :             int ae_flags = AE_WRITABLE;</span>
<span class="lineNum">    1086 </span>            :             /* For the fsync=always policy, we want that a given FD is never
<span class="lineNum">    1087 </span>            :              * served for reading and writing in the same event loop iteration,
<span class="lineNum">    1088 </span>            :              * so that in the middle of receiving the query, and serving it
<span class="lineNum">    1089 </span>            :              * to the client, we'll call beforeSleep() that will do the
<span class="lineNum">    1090 </span>            :              * actual fsync of AOF to disk. AE_BARRIER ensures that. */
<span class="lineNum">    1091 </span><span class="lineCov">        187 :             if (server.aof_state == AOF_ON &amp;&amp;</span>
<span class="lineNum">    1092 </span>            :                 server.aof_fsync == AOF_FSYNC_ALWAYS)
<span class="lineNum">    1093 </span>            :             {
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :                 ae_flags |= AE_BARRIER;</span>
<span class="lineNum">    1095 </span>            :             }
<span class="lineNum">    1096 </span><span class="lineCov">        187 :             if (aeCreateFileEvent(server.el, c-&gt;fd, ae_flags,</span>
<span class="lineNum">    1097 </span>            :                 sendReplyToClient, c) == AE_ERR)
<span class="lineNum">    1098 </span>            :             {
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :                     freeClientAsync(c);</span>
<span class="lineNum">    1100 </span>            :             }
<span class="lineNum">    1101 </span>            :         }
<span class="lineNum">    1102 </span>            :     }
<span class="lineNum">    1103 </span><span class="lineCov">   22808544 :     return processed;</span>
<span class="lineNum">    1104 </span>            : }
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<span class="lineNum">    1106 </span>            : /* resetClient prepare the client to process the next command */
<span class="lineNum">    1107 </span><span class="lineCov">   55430626 : void resetClient(client *c) {</span>
<span class="lineNum">    1108 </span><span class="lineCov">   55430626 :     redisCommandProc *prevcmd = c-&gt;cmd ? c-&gt;cmd-&gt;proc : NULL;</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">   55430626 :     freeClientArgv(c);</span>
<span class="lineNum">    1111 </span><span class="lineCov">   55430626 :     c-&gt;reqtype = 0;</span>
<span class="lineNum">    1112 </span><span class="lineCov">   55430626 :     c-&gt;multibulklen = 0;</span>
<span class="lineNum">    1113 </span><span class="lineCov">   55430626 :     c-&gt;bulklen = -1;</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            :     /* We clear the ASKING flag as well if we are not inside a MULTI, and
<span class="lineNum">    1116 </span>            :      * if what we just executed is not the ASKING command itself. */
<span class="lineNum">    1117 </span><span class="lineCov">   55430626 :     if (!(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp; prevcmd != askingCommand)</span>
<span class="lineNum">    1118 </span><span class="lineCov">   54948937 :         c-&gt;flags &amp;= ~CLIENT_ASKING;</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            :     /* Remove the CLIENT_REPLY_SKIP flag if any so that the reply
<span class="lineNum">    1121 </span>            :      * to the next command will be sent, but set the flag if the command
<span class="lineNum">    1122 </span>            :      * we just processed was &quot;CLIENT REPLY SKIP&quot;. */
<span class="lineNum">    1123 </span><span class="lineCov">   55430626 :     c-&gt;flags &amp;= ~CLIENT_REPLY_SKIP;</span>
<span class="lineNum">    1124 </span><span class="lineCov">   55430626 :     if (c-&gt;flags &amp; CLIENT_REPLY_SKIP_NEXT) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :         c-&gt;flags |= CLIENT_REPLY_SKIP;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :         c-&gt;flags &amp;= ~CLIENT_REPLY_SKIP_NEXT;</span>
<span class="lineNum">    1127 </span>            :     }
<span class="lineNum">    1128 </span><span class="lineCov">   55430626 : }</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            : /* This funciton is used when we want to re-enter the event loop but there
<span class="lineNum">    1131 </span>            :  * is the risk that the client we are dealing with will be freed in some
<span class="lineNum">    1132 </span>            :  * way. This happens for instance in:
<span class="lineNum">    1133 </span>            :  *
<span class="lineNum">    1134 </span>            :  * * DEBUG RELOAD and similar.
<span class="lineNum">    1135 </span>            :  * * When a Lua script is in -BUSY state.
<span class="lineNum">    1136 </span>            :  *
<span class="lineNum">    1137 </span>            :  * So the function will protect the client by doing two things:
<span class="lineNum">    1138 </span>            :  *
<span class="lineNum">    1139 </span>            :  * 1) It removes the file events. This way it is not possible that an
<span class="lineNum">    1140 </span>            :  *    error is signaled on the socket, freeing the client.
<a name="1141"><span class="lineNum">    1141 </span>            :  * 2) Moreover it makes sure that if the client is freed in a different code</a>
<span class="lineNum">    1142 </span>            :  *    path, it is not really released, but only marked for later release. */
<span class="lineNum">    1143 </span><span class="lineCov">        502 : void protectClient(client *c) {</span>
<span class="lineNum">    1144 </span><span class="lineCov">        502 :     c-&gt;flags |= CLIENT_PROTECTED;</span>
<span class="lineNum">    1145 </span><span class="lineCov">        502 :     aeDeleteFileEvent(server.el,c-&gt;fd,AE_READABLE);</span>
<span class="lineNum">    1146 </span><span class="lineCov">        502 :     aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span>
<span class="lineNum">    1147 </span><span class="lineCov">        502 : }</span>
<a name="1148"><span class="lineNum">    1148 </span>            : </a>
<span class="lineNum">    1149 </span>            : /* This will undo the client protection done by protectClient() */
<span class="lineNum">    1150 </span><span class="lineCov">        500 : void unprotectClient(client *c) {</span>
<span class="lineNum">    1151 </span><span class="lineCov">        500 :     if (c-&gt;flags &amp; CLIENT_PROTECTED) {</span>
<span class="lineNum">    1152 </span><span class="lineCov">        500 :         c-&gt;flags &amp;= ~CLIENT_PROTECTED;</span>
<span class="lineNum">    1153 </span><span class="lineCov">        500 :         aeCreateFileEvent(server.el,c-&gt;fd,AE_READABLE,readQueryFromClient,c);</span>
<span class="lineNum">    1154 </span><span class="lineCov">        500 :         if (clientHasPendingReplies(c)) clientInstallWriteHandler(c);</span>
<span class="lineNum">    1155 </span>            :     }
<span class="lineNum">    1156 </span><span class="lineCov">        500 : }</span>
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : /* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,
<span class="lineNum">    1159 </span>            :  * this function consumes the client query buffer and creates a command ready
<span class="lineNum">    1160 </span>            :  * to be executed inside the client structure. Returns C_OK if the command
<span class="lineNum">    1161 </span>            :  * is ready to be executed, or C_ERR if there is still protocol to read to
<span class="lineNum">    1162 </span>            :  * have a well formed command. The function also returns C_ERR when there is
<a name="1163"><span class="lineNum">    1163 </span>            :  * a protocol error: in such a case the client structure is setup to reply</a>
<span class="lineNum">    1164 </span>            :  * with the error and close the connection. */
<span class="lineNum">    1165 </span><span class="lineCov">     635085 : int processInlineBuffer(client *c) {</span>
<span class="lineNum">    1166 </span><span class="lineCov">     635085 :     char *newline;</span>
<span class="lineNum">    1167 </span><span class="lineCov">     635085 :     int argc, j, linefeed_chars = 1;</span>
<span class="lineNum">    1168 </span><span class="lineCov">     635085 :     sds *argv, aux;</span>
<span class="lineNum">    1169 </span><span class="lineCov">     635085 :     size_t querylen;</span>
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            :     /* Search for end of line */
<span class="lineNum">    1172 </span><span class="lineCov">     635085 :     newline = strchr(c-&gt;querybuf+c-&gt;qb_pos,'\n');</span>
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :     /* Nothing to do without a \r\n */
<span class="lineNum">    1175 </span><span class="lineCov">     635085 :     if (newline == NULL) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">      67386 :         if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) {</span>
<span class="lineNum">    1177 </span><span class="lineCov">          6 :             addReplyError(c,&quot;Protocol error: too big inline request&quot;);</span>
<span class="lineNum">    1178 </span><span class="lineCov">          6 :             setProtocolError(&quot;too big inline request&quot;,c);</span>
<span class="lineNum">    1179 </span>            :         }
<span class="lineNum">    1180 </span><span class="lineCov">      33693 :         return C_ERR;</span>
<span class="lineNum">    1181 </span>            :     }
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :     /* Handle the \r\n case. */
<span class="lineNum">    1184 </span><span class="lineCov">     601392 :     if (newline &amp;&amp; newline != c-&gt;querybuf+c-&gt;qb_pos &amp;&amp; *(newline-1) == '\r')</span>
<span class="lineNum">    1185 </span><span class="lineCov">     600677 :         newline--, linefeed_chars++;</span>
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span>            :     /* Split the input buffer up to the \r\n */
<span class="lineNum">    1188 </span><span class="lineCov">     601392 :     querylen = newline-(c-&gt;querybuf+c-&gt;qb_pos);</span>
<span class="lineNum">    1189 </span><span class="lineCov">     601392 :     aux = sdsnewlen(c-&gt;querybuf+c-&gt;qb_pos,querylen);</span>
<span class="lineNum">    1190 </span><span class="lineCov">     601392 :     argv = sdssplitargs(aux,&amp;argc);</span>
<span class="lineNum">    1191 </span><span class="lineCov">     601392 :     sdsfree(aux);</span>
<span class="lineNum">    1192 </span><span class="lineCov">     601392 :     if (argv == NULL) {</span>
<span class="lineNum">    1193 </span><span class="lineCov">          3 :         addReplyError(c,&quot;Protocol error: unbalanced quotes in request&quot;);</span>
<span class="lineNum">    1194 </span><span class="lineCov">          3 :         setProtocolError(&quot;unbalanced quotes in inline request&quot;,c);</span>
<span class="lineNum">    1195 </span><span class="lineCov">          3 :         return C_ERR;</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :     /* Newline from slaves can be used to refresh the last ACK time.
<span class="lineNum">    1199 </span>            :      * This is useful for a slave to ping back while loading a big
<span class="lineNum">    1200 </span>            :      * RDB file. */
<span class="lineNum">    1201 </span><span class="lineCov">     601389 :     if (querylen == 0 &amp;&amp; c-&gt;flags &amp; CLIENT_SLAVE)</span>
<span class="lineNum">    1202 </span><span class="lineCov">         98 :         c-&gt;repl_ack_time = server.unixtime;</span>
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :     /* Move querybuffer position to the next query in the buffer. */
<span class="lineNum">    1205 </span><span class="lineCov">     601389 :     c-&gt;qb_pos += querylen+linefeed_chars;</span>
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            :     /* Setup argv array on client structure */
<span class="lineNum">    1208 </span><span class="lineCov">     601389 :     if (argc) {</span>
<span class="lineNum">    1209 </span><span class="lineCov">     600671 :         if (c-&gt;argv) zfree(c-&gt;argv);</span>
<span class="lineNum">    1210 </span><span class="lineCov">     600671 :         c-&gt;argv = zmalloc(sizeof(robj*)*argc);</span>
<span class="lineNum">    1211 </span>            :     }
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span>            :     /* Create redis objects for all arguments. */
<span class="lineNum">    1214 </span><span class="lineCov">    2102072 :     for (c-&gt;argc = 0, j = 0; j &lt; argc; j++) {</span>
<span class="lineNum">    1215 </span><span class="lineCov">    3001366 :         if (sdslen(argv[j])) {</span>
<span class="lineNum">    1216 </span><span class="lineCov">    1500683 :             c-&gt;argv[c-&gt;argc] = createObject(OBJ_STRING,argv[j]);</span>
<span class="lineNum">    1217 </span><span class="lineCov">    1500683 :             c-&gt;argc++;</span>
<span class="lineNum">    1218 </span>            :         } else {
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :             sdsfree(argv[j]);</span>
<span class="lineNum">    1220 </span>            :         }
<span class="lineNum">    1221 </span>            :     }
<span class="lineNum">    1222 </span><span class="lineCov">     601389 :     zfree(argv);</span>
<span class="lineNum">    1223 </span><span class="lineCov">     601389 :     return C_OK;</span>
<span class="lineNum">    1224 </span>            : }
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            : /* Helper function. Record protocol erro details in server log,
<a name="1227"><span class="lineNum">    1227 </span>            :  * and set the client as CLIENT_CLOSE_AFTER_REPLY. */</a>
<span class="lineNum">    1228 </span>            : #define PROTO_DUMP_LEN 128
<span class="lineNum">    1229 </span><span class="lineCov">         30 : static void setProtocolError(const char *errstr, client *c) {</span>
<span class="lineNum">    1230 </span><span class="lineCov">         30 :     if (server.verbosity &lt;= LL_VERBOSE) {</span>
<span class="lineNum">    1231 </span><span class="lineCov">         30 :         sds client = catClientInfoString(sdsempty(),c);</span>
<span class="lineNum">    1232 </span>            : 
<span class="lineNum">    1233 </span>            :         /* Sample some protocol to given an idea about what was inside. */
<span class="lineNum">    1234 </span><span class="lineCov">         30 :         char buf[256];</span>
<span class="lineNum">    1235 </span><span class="lineCov">         60 :         if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &lt; PROTO_DUMP_LEN) {</span>
<span class="lineNum">    1236 </span><span class="lineCov">         21 :             snprintf(buf,sizeof(buf),&quot;Query buffer during protocol error: '%s'&quot;, c-&gt;querybuf+c-&gt;qb_pos);</span>
<span class="lineNum">    1237 </span>            :         } else {
<span class="lineNum">    1238 </span><span class="lineCov">         27 :             snprintf(buf,sizeof(buf),&quot;Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'&quot;, PROTO_DUMP_LEN/2, c-&gt;querybuf+c-&gt;qb_pos, sdslen(c-&gt;querybuf)-c-&gt;qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c-&gt;querybuf+sdslen(c-&gt;querybuf)-PROTO_DUMP_LEN/2);</span>
<span class="lineNum">    1239 </span>            :         }
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            :         /* Remove non printable chars. */
<span class="lineNum">    1242 </span>            :         char *p = buf;
<span class="lineNum">    1243 </span><span class="lineCov">       2283 :         while (*p != '\0') {</span>
<span class="lineNum">    1244 </span><span class="lineCov">       2253 :             if (!isprint(*p)) *p = '.';</span>
<span class="lineNum">    1245 </span><span class="lineCov">       2253 :             p++;</span>
<span class="lineNum">    1246 </span>            :         }
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :         /* Log all the client and protocol info. */
<span class="lineNum">    1249 </span><span class="lineCov">         30 :         serverLog(LL_VERBOSE,</span>
<span class="lineNum">    1250 </span>            :             &quot;Protocol error (%s) from client: %s. %s&quot;, errstr, client, buf);
<span class="lineNum">    1251 </span><span class="lineCov">         30 :         sdsfree(client);</span>
<span class="lineNum">    1252 </span>            :     }
<span class="lineNum">    1253 </span><span class="lineCov">         30 :     c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span>
<span class="lineNum">    1254 </span><span class="lineCov">         30 : }</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : /* Process the query buffer for client 'c', setting up the client argument
<span class="lineNum">    1257 </span>            :  * vector for command execution. Returns C_OK if after running the function
<span class="lineNum">    1258 </span>            :  * the client has a well-formed ready to be processed command, otherwise
<span class="lineNum">    1259 </span>            :  * C_ERR if there is still to read more buffer to get the full command.
<span class="lineNum">    1260 </span>            :  * The function also returns C_ERR when there is a protocol error: in such a
<span class="lineNum">    1261 </span>            :  * case the client structure is setup to reply with the error and close
<span class="lineNum">    1262 </span>            :  * the connection.
<span class="lineNum">    1263 </span>            :  *
<span class="lineNum">    1264 </span>            :  * This function is called if processInputBuffer() detects that the next
<a name="1265"><span class="lineNum">    1265 </span>            :  * command is in RESP format, so the first byte in the command is found</a>
<span class="lineNum">    1266 </span>            :  * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */
<span class="lineNum">    1267 </span><span class="lineCov">   55000058 : int processMultibulkBuffer(client *c) {</span>
<span class="lineNum">    1268 </span><span class="lineCov">   55000058 :     char *newline = NULL;</span>
<span class="lineNum">    1269 </span><span class="lineCov">   55000058 :     int ok;</span>
<span class="lineNum">    1270 </span><span class="lineCov">   55000058 :     long long ll;</span>
<span class="lineNum">    1271 </span>            : 
<span class="lineNum">    1272 </span><span class="lineCov">   55000058 :     if (c-&gt;multibulklen == 0) {</span>
<span class="lineNum">    1273 </span>            :         /* The client should have been reset */
<span class="lineNum">    1274 </span><span class="lineCov">   54851108 :         serverAssertWithInfo(c,NULL,c-&gt;argc == 0);</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            :         /* Multi bulk length cannot be read without a \r\n */
<span class="lineNum">    1277 </span><span class="lineCov">   54851108 :         newline = strchr(c-&gt;querybuf+c-&gt;qb_pos,'\r');</span>
<span class="lineNum">    1278 </span><span class="lineCov">   54851108 :         if (newline == NULL) {</span>
<span class="lineNum">    1279 </span><span class="lineCov">      40364 :             if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) {</span>
<span class="lineNum">    1280 </span><span class="lineCov">          3 :                 addReplyError(c,&quot;Protocol error: too big mbulk count string&quot;);</span>
<span class="lineNum">    1281 </span><span class="lineCov">          3 :                 setProtocolError(&quot;too big mbulk count string&quot;,c);</span>
<span class="lineNum">    1282 </span>            :             }
<span class="lineNum">    1283 </span><span class="lineCov">      20182 :             return C_ERR;</span>
<span class="lineNum">    1284 </span>            :         }
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            :         /* Buffer should also contain \n */
<span class="lineNum">    1287 </span><span class="lineCov">  109661852 :         if (newline-(c-&gt;querybuf+c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf)-c-&gt;qb_pos-2))</span>
<span class="lineNum">    1288 </span>            :             return C_ERR;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            :         /* We know for sure there is a whole line since newline != NULL,
<span class="lineNum">    1291 </span>            :          * so go ahead and find out the multi bulk length. */
<span class="lineNum">    1292 </span><span class="lineCov">   54829417 :         serverAssertWithInfo(c,NULL,c-&gt;querybuf[c-&gt;qb_pos] == '*');</span>
<span class="lineNum">    1293 </span><span class="lineCov">   54829417 :         ok = string2ll(c-&gt;querybuf+1+c-&gt;qb_pos,newline-(c-&gt;querybuf+1+c-&gt;qb_pos),&amp;ll);</span>
<span class="lineNum">    1294 </span><span class="lineCov">   54829417 :         if (!ok || ll &gt; 1024*1024) {</span>
<span class="lineNum">    1295 </span><span class="lineCov">          3 :             addReplyError(c,&quot;Protocol error: invalid multibulk length&quot;);</span>
<span class="lineNum">    1296 </span><span class="lineCov">          3 :             setProtocolError(&quot;invalid mbulk count&quot;,c);</span>
<span class="lineNum">    1297 </span><span class="lineCov">          3 :             return C_ERR;</span>
<span class="lineNum">    1298 </span>            :         }
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineCov">   54829414 :         c-&gt;qb_pos = (newline-c-&gt;querybuf)+2;</span>
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span><span class="lineCov">   54829414 :         if (ll &lt;= 0) return C_OK;</span>
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineCov">   54829411 :         c-&gt;multibulklen = ll;</span>
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :         /* Setup argv array on client structure */
<span class="lineNum">    1307 </span><span class="lineCov">   54829411 :         if (c-&gt;argv) zfree(c-&gt;argv);</span>
<span class="lineNum">    1308 </span><span class="lineCov">   54829411 :         c-&gt;argv = zmalloc(sizeof(robj*)*c-&gt;multibulklen);</span>
<span class="lineNum">    1309 </span>            :     }
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineCov">   54978361 :     serverAssertWithInfo(c,NULL,c-&gt;multibulklen &gt; 0);</span>
<span class="lineNum">    1312 </span><span class="lineCov">  211831043 :     while(c-&gt;multibulklen) {</span>
<span class="lineNum">    1313 </span>            :         /* Read bulk length if unknown */
<span class="lineNum">    1314 </span><span class="lineCov">  157001782 :         if (c-&gt;bulklen == -1) {</span>
<span class="lineNum">    1315 </span><span class="lineCov">  156877315 :             newline = strchr(c-&gt;querybuf+c-&gt;qb_pos,'\r');</span>
<span class="lineNum">    1316 </span><span class="lineCov">  156877315 :             if (newline == NULL) {</span>
<span class="lineNum">    1317 </span><span class="lineCov">      36260 :                 if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &gt; PROTO_INLINE_MAX_SIZE) {</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :                     addReplyError(c,</span>
<span class="lineNum">    1319 </span>            :                         &quot;Protocol error: too big bulk count string&quot;);
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :                     setProtocolError(&quot;too big bulk count string&quot;,c);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :                     return C_ERR;</span>
<span class="lineNum">    1322 </span>            :                 }
<span class="lineNum">    1323 </span>            :                 break;
<span class="lineNum">    1324 </span>            :             }
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            :             /* Buffer should also contain \n */
<span class="lineNum">    1327 </span><span class="lineCov">  313718370 :             if (newline-(c-&gt;querybuf+c-&gt;qb_pos) &gt; (ssize_t)(sdslen(c-&gt;querybuf)-c-&gt;qb_pos-2))</span>
<span class="lineNum">    1328 </span>            :                 break;
<span class="lineNum">    1329 </span>            : 
<span class="lineNum">    1330 </span><span class="lineCov">  156852801 :             if (c-&gt;querybuf[c-&gt;qb_pos] != '$') {</span>
<span class="lineNum">    1331 </span><span class="lineCov">          6 :                 addReplyErrorFormat(c,</span>
<span class="lineNum">    1332 </span>            :                     &quot;Protocol error: expected '$', got '%c'&quot;,
<span class="lineNum">    1333 </span>            :                     c-&gt;querybuf[c-&gt;qb_pos]);
<span class="lineNum">    1334 </span><span class="lineCov">          6 :                 setProtocolError(&quot;expected $ but got something else&quot;,c);</span>
<span class="lineNum">    1335 </span><span class="lineCov">          6 :                 return C_ERR;</span>
<span class="lineNum">    1336 </span>            :             }
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span><span class="lineCov">  156852795 :             ok = string2ll(c-&gt;querybuf+c-&gt;qb_pos+1,newline-(c-&gt;querybuf+c-&gt;qb_pos+1),&amp;ll);</span>
<span class="lineNum">    1339 </span><span class="lineCov">  156852795 :             if (!ok || ll &lt; 0 || ll &gt; server.proto_max_bulk_len) {</span>
<span class="lineNum">    1340 </span><span class="lineCov">          9 :                 addReplyError(c,&quot;Protocol error: invalid bulk length&quot;);</span>
<span class="lineNum">    1341 </span><span class="lineCov">          9 :                 setProtocolError(&quot;invalid bulk length&quot;,c);</span>
<span class="lineNum">    1342 </span><span class="lineCov">          9 :                 return C_ERR;</span>
<span class="lineNum">    1343 </span>            :             }
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineCov">  156852786 :             c-&gt;qb_pos = newline-c-&gt;querybuf+2;</span>
<span class="lineNum">    1346 </span><span class="lineCov">  156852786 :             if (ll &gt;= PROTO_MBULK_BIG_ARG) {</span>
<span class="lineNum">    1347 </span>            :                 /* If we are going to read a large object from network
<span class="lineNum">    1348 </span>            :                  * try to make it likely that it will start at c-&gt;querybuf
<span class="lineNum">    1349 </span>            :                  * boundary so that we can optimize object creation
<span class="lineNum">    1350 </span>            :                  * avoiding a large copy of data.
<span class="lineNum">    1351 </span>            :                  *
<span class="lineNum">    1352 </span>            :                  * But only when the data we have not parsed is less than
<span class="lineNum">    1353 </span>            :                  * or equal to ll+2. If the data length is greater than
<span class="lineNum">    1354 </span>            :                  * ll+2, trimming querybuf is just a waste of time, because
<span class="lineNum">    1355 </span>            :                  * at this time the querybuf contains not only our bulk. */
<span class="lineNum">    1356 </span><span class="lineCov">       2638 :                 if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &lt;= (size_t)ll+2) {</span>
<span class="lineNum">    1357 </span><span class="lineCov">       1319 :                     sdsrange(c-&gt;querybuf,c-&gt;qb_pos,-1);</span>
<span class="lineNum">    1358 </span><span class="lineCov">       1319 :                     c-&gt;qb_pos = 0;</span>
<span class="lineNum">    1359 </span>            :                     /* Hint the sds library about the amount of bytes this string is
<span class="lineNum">    1360 </span>            :                      * going to contain. */
<span class="lineNum">    1361 </span><span class="lineCov">       1319 :                     c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,ll+2);</span>
<span class="lineNum">    1362 </span>            :                 }
<span class="lineNum">    1363 </span>            :             }
<span class="lineNum">    1364 </span><span class="lineCov">  156852786 :             c-&gt;bulklen = ll;</span>
<span class="lineNum">    1365 </span>            :         }
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span>            :         /* Read bulk argument */
<span class="lineNum">    1368 </span><span class="lineCov">  313954506 :         if (sdslen(c-&gt;querybuf)-c-&gt;qb_pos &lt; (size_t)(c-&gt;bulklen+2)) {</span>
<span class="lineNum">    1369 </span>            :             /* Not enough data (+2 == trailing \r\n) */
<span class="lineNum">    1370 </span>            :             break;
<span class="lineNum">    1371 </span>            :         } else {
<span class="lineNum">    1372 </span>            :             /* Optimization: if the buffer contains JUST our bulk element
<span class="lineNum">    1373 </span>            :              * instead of creating a new object by *copying* the sds we
<span class="lineNum">    1374 </span>            :              * just use the current sds string. */
<span class="lineNum">    1375 </span><span class="lineCov">  156852682 :             if (c-&gt;qb_pos == 0 &amp;&amp;</span>
<span class="lineNum">    1376 </span><span class="lineCov">       1316 :                 c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp;</span>
<span class="lineNum">    1377 </span><span class="lineCov">       2632 :                 sdslen(c-&gt;querybuf) == (size_t)(c-&gt;bulklen+2))</span>
<span class="lineNum">    1378 </span>            :             {
<span class="lineNum">    1379 </span><span class="lineCov">       1316 :                 c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING,c-&gt;querybuf);</span>
<span class="lineNum">    1380 </span><span class="lineCov">       1316 :                 sdsIncrLen(c-&gt;querybuf,-2); /* remove CRLF */</span>
<span class="lineNum">    1381 </span>            :                 /* Assume that if we saw a fat argument we'll see another one
<span class="lineNum">    1382 </span>            :                  * likely... */
<span class="lineNum">    1383 </span><span class="lineCov">       1316 :                 c-&gt;querybuf = sdsnewlen(SDS_NOINIT,c-&gt;bulklen+2);</span>
<span class="lineNum">    1384 </span><span class="lineCov">       1316 :                 sdsclear(c-&gt;querybuf);</span>
<span class="lineNum">    1385 </span>            :             } else {
<span class="lineNum">    1386 </span><span class="lineCov">  470554098 :                 c-&gt;argv[c-&gt;argc++] =</span>
<span class="lineNum">    1387 </span><span class="lineCov">  156851366 :                     createStringObject(c-&gt;querybuf+c-&gt;qb_pos,c-&gt;bulklen);</span>
<span class="lineNum">    1388 </span><span class="lineCov">  156851366 :                 c-&gt;qb_pos += c-&gt;bulklen+2;</span>
<span class="lineNum">    1389 </span>            :             }
<span class="lineNum">    1390 </span><span class="lineCov">  156852682 :             c-&gt;bulklen = -1;</span>
<span class="lineNum">    1391 </span><span class="lineCov">  156852682 :             c-&gt;multibulklen--;</span>
<span class="lineNum">    1392 </span>            :         }
<span class="lineNum">    1393 </span>            :     }
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :     /* We're done when c-&gt;multibulk == 0 */
<span class="lineNum">    1396 </span><span class="lineCov">   54978346 :     if (c-&gt;multibulklen == 0) return C_OK;</span>
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :     /* Still not ready to process the command */
<span class="lineNum">    1399 </span>            :     return C_ERR;
<span class="lineNum">    1400 </span>            : }
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            : /* This function is called every time, in the client structure 'c', there is
<span class="lineNum">    1403 </span>            :  * more query buffer to process, because we read more data from the socket
<a name="1404"><span class="lineNum">    1404 </span>            :  * or because a client was blocked and later reactivated, so there could be</a>
<span class="lineNum">    1405 </span>            :  * pending query buffer, already representing a full command, to process. */
<span class="lineNum">    1406 </span><span class="lineCov">   24400235 : void processInputBuffer(client *c) {</span>
<span class="lineNum">    1407 </span><span class="lineCov">   24400235 :     server.current_client = c;</span>
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            :     /* Keep processing while there is something in the input buffer */
<span class="lineNum">    1410 </span><span class="lineCov">  159661364 :     while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) {</span>
<span class="lineNum">    1411 </span>            :         /* Return if clients are paused. */
<span class="lineNum">    1412 </span><span class="lineCov">   55635158 :         if (!(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; clientsArePaused()) break;</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span>            :         /* Immediately abort if the client is in the middle of something. */
<span class="lineNum">    1415 </span><span class="lineCov">   55635158 :         if (c-&gt;flags &amp; CLIENT_BLOCKED) break;</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span>            :         /* Don't process input from the master while there is a busy script
<span class="lineNum">    1418 </span>            :          * condition on the slave. We want just to accumulate the replication
<span class="lineNum">    1419 </span>            :          * stream (instead of replying -BUSY like we do with other clients) and
<span class="lineNum">    1420 </span>            :          * later resume the processing. */
<span class="lineNum">    1421 </span><span class="lineCov">   55635152 :         if (server.lua_timedout &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) break;</span>
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            :         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
<span class="lineNum">    1424 </span>            :          * written to the client. Make sure to not let the reply grow after
<span class="lineNum">    1425 </span>            :          * this flag has been set (i.e. don't process more commands).
<span class="lineNum">    1426 </span>            :          *
<span class="lineNum">    1427 </span>            :          * The same applies for clients we want to terminate ASAP. */
<span class="lineNum">    1428 </span><span class="lineCov">   55635149 :         if (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :         /* Determine request type when unknown. */
<span class="lineNum">    1431 </span><span class="lineCov">   55635143 :         if (!c-&gt;reqtype) {</span>
<span class="lineNum">    1432 </span><span class="lineCov">   55430823 :             if (c-&gt;querybuf[c-&gt;qb_pos] == '*') {</span>
<span class="lineNum">    1433 </span><span class="lineCov">   54829425 :                 c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span>
<span class="lineNum">    1434 </span>            :             } else {
<span class="lineNum">    1435 </span><span class="lineCov">     601398 :                 c-&gt;reqtype = PROTO_REQ_INLINE;</span>
<span class="lineNum">    1436 </span>            :             }
<span class="lineNum">    1437 </span>            :         }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineCov">   55635143 :         if (c-&gt;reqtype == PROTO_REQ_INLINE) {</span>
<span class="lineNum">    1440 </span><span class="lineCov">     635085 :             if (processInlineBuffer(c) != C_OK) break;</span>
<span class="lineNum">    1441 </span><span class="lineCov">   55000058 :         } else if (c-&gt;reqtype == PROTO_REQ_MULTIBULK) {</span>
<span class="lineNum">    1442 </span><span class="lineCov">   55000058 :             if (processMultibulkBuffer(c) != C_OK) break;</span>
<span class="lineNum">    1443 </span>            :         } else {
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown request type&quot;);</span>
<span class="lineNum">    1445 </span>            :         }
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span>            :         /* Multibulk processing could see a &lt;= 0 length. */
<span class="lineNum">    1448 </span><span class="lineCov">   55430653 :         if (c-&gt;argc == 0) {</span>
<span class="lineNum">    1449 </span><span class="lineCov">        721 :             resetClient(c);</span>
<span class="lineNum">    1450 </span>            :         } else {
<span class="lineNum">    1451 </span>            :             /* Only reset the client when the command was executed. */
<span class="lineNum">    1452 </span><span class="lineCov">   55429932 :             if (processCommand(c) == C_OK) {</span>
<span class="lineNum">    1453 </span><span class="lineCov">   55429722 :                 if (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; !(c-&gt;flags &amp; CLIENT_MULTI)) {</span>
<span class="lineNum">    1454 </span>            :                     /* Update the applied replication offset of our master. */
<span class="lineNum">    1455 </span><span class="lineCov">   30786124 :                     c-&gt;reploff = c-&gt;read_reploff - sdslen(c-&gt;querybuf) + c-&gt;qb_pos;</span>
<span class="lineNum">    1456 </span>            :                 }
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            :                 /* Don't reset the client structure for clients blocked in a
<span class="lineNum">    1459 </span>            :                  * module blocking command, so that the reply callback will
<span class="lineNum">    1460 </span>            :                  * still be able to access the client argv and argc field.
<span class="lineNum">    1461 </span>            :                  * The client will be reset in unblockClientFromModule(). */
<span class="lineNum">    1462 </span><span class="lineCov">   55429722 :                 if (!(c-&gt;flags &amp; CLIENT_BLOCKED) || c-&gt;btype != BLOCKED_MODULE)</span>
<span class="lineNum">    1463 </span><span class="lineCov">   55429722 :                     resetClient(c);</span>
<span class="lineNum">    1464 </span>            :             }
<span class="lineNum">    1465 </span>            :             /* freeMemoryIfNeeded may flush slave output buffers. This may
<span class="lineNum">    1466 </span>            :              * result into a slave, that may be the active client, to be
<span class="lineNum">    1467 </span>            :              * freed. */
<span class="lineNum">    1468 </span><span class="lineCov">   55429731 :             if (server.current_client == NULL) break;</span>
<span class="lineNum">    1469 </span>            :         }
<span class="lineNum">    1470 </span>            :     }
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span>            :     /* Trim to pos */
<span class="lineNum">    1473 </span><span class="lineCov">   24400034 :     if (c-&gt;qb_pos) {</span>
<span class="lineNum">    1474 </span><span class="lineCov">   24326125 :         sdsrange(c-&gt;querybuf,c-&gt;qb_pos,-1);</span>
<span class="lineNum">    1475 </span><span class="lineCov">   24326125 :         c-&gt;qb_pos = 0;</span>
<span class="lineNum">    1476 </span>            :     }
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineCov">   24400034 :     server.current_client = NULL;</span>
<span class="lineNum">    1479 </span><span class="lineCov">   24400034 : }</span>
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            : /* This is a wrapper for processInputBuffer that also cares about handling
<span class="lineNum">    1482 </span>            :  * the replication forwarding to the sub-slaves, in case the client 'c'
<a name="1483"><span class="lineNum">    1483 </span>            :  * is flagged as master. Usually you want to call this instead of the</a>
<span class="lineNum">    1484 </span>            :  * raw processInputBuffer(). */
<span class="lineNum">    1485 </span><span class="lineCov">   24400235 : void processInputBufferAndReplicate(client *c) {</span>
<span class="lineNum">    1486 </span><span class="lineCov">   24400235 :     if (!(c-&gt;flags &amp; CLIENT_MASTER)) {</span>
<span class="lineNum">    1487 </span><span class="lineCov">   21521449 :         processInputBuffer(c);</span>
<span class="lineNum">    1488 </span>            :     } else {
<span class="lineNum">    1489 </span><span class="lineCov">    2878786 :         size_t prev_offset = c-&gt;reploff;</span>
<span class="lineNum">    1490 </span><span class="lineCov">    2878786 :         processInputBuffer(c);</span>
<span class="lineNum">    1491 </span><span class="lineCov">    2878786 :         size_t applied = c-&gt;reploff - prev_offset;</span>
<span class="lineNum">    1492 </span><span class="lineCov">    2878786 :         if (applied) {</span>
<span class="lineNum">    1493 </span><span class="lineCov">    2872657 :             replicationFeedSlavesFromMasterStream(server.slaves,</span>
<span class="lineNum">    1494 </span>            :                     c-&gt;pending_querybuf, applied);
<span class="lineNum">    1495 </span><span class="lineCov">    2872657 :             sdsrange(c-&gt;pending_querybuf,applied,-1);</span>
<span class="lineNum">    1496 </span>            :         }
<span class="lineNum">    1497 </span>            :     }
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">   24400034 : }</span></a>
<span class="lineNum">    1499 </span>            : 
<span class="lineNum">    1500 </span><span class="lineCov">   24401504 : void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {</span>
<span class="lineNum">    1501 </span><span class="lineCov">   24401504 :     client *c = (client*) privdata;</span>
<span class="lineNum">    1502 </span><span class="lineCov">   24401504 :     int nread, readlen;</span>
<span class="lineNum">    1503 </span><span class="lineCov">   24401504 :     size_t qblen;</span>
<span class="lineNum">    1504 </span><span class="lineCov">   24401504 :     UNUSED(el);</span>
<span class="lineNum">    1505 </span><span class="lineCov">   24401504 :     UNUSED(mask);</span>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineCov">   24401504 :     readlen = PROTO_IOBUF_LEN;</span>
<span class="lineNum">    1508 </span>            :     /* If this is a multi bulk request, and we are processing a bulk reply
<span class="lineNum">    1509 </span>            :      * that is large enough, try to maximize the probability that the query
<span class="lineNum">    1510 </span>            :      * buffer contains exactly the SDS string representing the object, even
<span class="lineNum">    1511 </span>            :      * at the risk of requiring more read(2) calls. This way the function
<span class="lineNum">    1512 </span>            :      * processMultiBulkBuffer() can avoid copying buffers to create the
<span class="lineNum">    1513 </span>            :      * Redis Object representing the argument. */
<span class="lineNum">    1514 </span><span class="lineCov">   24401504 :     if (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != -1</span>
<span class="lineNum">    1515 </span><span class="lineCov">     124469 :         &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span>
<span class="lineNum">    1516 </span>            :     {
<span class="lineNum">    1517 </span><span class="lineCov">      20491 :         ssize_t remaining = (size_t)(c-&gt;bulklen+2)-sdslen(c-&gt;querybuf);</span>
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span>            :         /* Note that the 'remaining' variable may be zero in some edge case,
<span class="lineNum">    1520 </span>            :          * for example once we resume a blocked client after CLIENT PAUSE. */
<span class="lineNum">    1521 </span><span class="lineCov">      20491 :         if (remaining &gt; 0 &amp;&amp; remaining &lt; readlen) readlen = remaining;</span>
<span class="lineNum">    1522 </span>            :     }
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineCov">   24401504 :     qblen = sdslen(c-&gt;querybuf);</span>
<span class="lineNum">    1525 </span><span class="lineCov">   24401504 :     if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span>
<span class="lineNum">    1526 </span><span class="lineCov">   24401504 :     c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span>
<span class="lineNum">    1527 </span><span class="lineCov">   24401504 :     nread = read(fd, c-&gt;querybuf+qblen, readlen);</span>
<span class="lineNum">    1528 </span><span class="lineCov">   24401504 :     if (nread == -1) {</span>
<span class="lineNum">    1529 </span><span class="lineCov">        148 :         if (errno == EAGAIN) {</span>
<span class="lineNum">    1530 </span>            :             return;
<span class="lineNum">    1531 </span>            :         } else {
<span class="lineNum">    1532 </span><span class="lineCov">        148 :             serverLog(LL_VERBOSE, &quot;Reading from client: %s&quot;,strerror(errno));</span>
<span class="lineNum">    1533 </span><span class="lineCov">        148 :             freeClient(c);</span>
<span class="lineNum">    1534 </span><span class="lineCov">        148 :             return;</span>
<span class="lineNum">    1535 </span>            :         }
<span class="lineNum">    1536 </span><span class="lineCov">   24401356 :     } else if (nread == 0) {</span>
<span class="lineNum">    1537 </span><span class="lineCov">       1130 :         serverLog(LL_VERBOSE, &quot;Client closed connection&quot;);</span>
<span class="lineNum">    1538 </span><span class="lineCov">       1130 :         freeClient(c);</span>
<span class="lineNum">    1539 </span><span class="lineCov">       1130 :         return;</span>
<span class="lineNum">    1540 </span><span class="lineCov">   24400226 :     } else if (c-&gt;flags &amp; CLIENT_MASTER) {</span>
<span class="lineNum">    1541 </span>            :         /* Append the query buffer to the pending (not applied) buffer
<span class="lineNum">    1542 </span>            :          * of the master. We'll use this buffer later in order to have a
<span class="lineNum">    1543 </span>            :          * copy of the string applied by the last command executed. */
<span class="lineNum">    1544 </span><span class="lineCov">    2878783 :         c-&gt;pending_querybuf = sdscatlen(c-&gt;pending_querybuf,</span>
<span class="lineNum">    1545 </span><span class="lineCov">    2878783 :                                         c-&gt;querybuf+qblen,nread);</span>
<span class="lineNum">    1546 </span>            :     }
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineCov">   24400226 :     sdsIncrLen(c-&gt;querybuf,nread);</span>
<span class="lineNum">    1549 </span><span class="lineCov">   24400226 :     c-&gt;lastinteraction = server.unixtime;</span>
<span class="lineNum">    1550 </span><span class="lineCov">   24400226 :     if (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;read_reploff += nread;</span>
<span class="lineNum">    1551 </span><span class="lineCov">   24400226 :     server.stat_net_input_bytes += nread;</span>
<span class="lineNum">    1552 </span><span class="lineCov">   48800452 :     if (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) {</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :         sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :         bytes = sdscatrepr(bytes,c-&gt;querybuf,64);</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;, ci, bytes);</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         sdsfree(ci);</span>
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :         sdsfree(bytes);</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :         freeClient(c);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1561 </span>            :     }
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :     /* Time to process the buffer. If the client is a master we need to
<span class="lineNum">    1564 </span>            :      * compute the difference between the applied offset before and after
<span class="lineNum">    1565 </span>            :      * processing the buffer, to understand how much of the replication stream
<span class="lineNum">    1566 </span>            :      * was actually applied to the master state: this quantity, and its
<span class="lineNum">    1567 </span>            :      * corresponding part of the replication stream, will be propagated to
<span class="lineNum">    1568 </span>            :      * the sub-slaves and to the replication backlog. */
<span class="lineNum">    1569 </span><span class="lineCov">   24400226 :     processInputBufferAndReplicate(c);</span>
<a name="1570"><span class="lineNum">    1570 </span>            : }</a>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 : void getClientsMaxBuffers(unsigned long *longest_output_list,</span>
<span class="lineNum">    1573 </span>            :                           unsigned long *biggest_input_buffer) {
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :     client *c;</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :     listNode *ln;</span>
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :     listIter li;</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     unsigned long lol = 0, bib = 0;</span>
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :     listRewind(server.clients,&amp;li);</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     while ((ln = listNext(&amp;li)) != NULL) {</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :         c = listNodeValue(ln);</span>
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :         if (listLength(c-&gt;reply) &gt; lol) lol = listLength(c-&gt;reply);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :         if (sdslen(c-&gt;querybuf) &gt; bib) bib = sdslen(c-&gt;querybuf);</span>
<span class="lineNum">    1585 </span>            :     }
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :     *longest_output_list = lol;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :     *biggest_input_buffer = bib;</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            : /* A Redis &quot;Peer ID&quot; is a colon separated ip:port pair.
<span class="lineNum">    1591 </span>            :  * For IPv4 it's in the form x.y.z.k:port, example: &quot;127.0.0.1:1234&quot;.
<span class="lineNum">    1592 </span>            :  * For IPv6 addresses we use [] around the IP part, like in &quot;[::1]:1234&quot;.
<span class="lineNum">    1593 </span>            :  * For Unix sockets we use path:0, like in &quot;/tmp/redis:0&quot;.
<span class="lineNum">    1594 </span>            :  *
<span class="lineNum">    1595 </span>            :  * A Peer ID always fits inside a buffer of NET_PEER_ID_LEN bytes, including
<span class="lineNum">    1596 </span>            :  * the null term.
<span class="lineNum">    1597 </span>            :  *
<span class="lineNum">    1598 </span>            :  * On failure the function still populates 'peerid' with the &quot;?:0&quot; string
<a name="1599"><span class="lineNum">    1599 </span>            :  * in case you want to relax error checking or need to display something</a>
<span class="lineNum">    1600 </span>            :  * anyway (see anetPeerToString implementation for more info). */
<span class="lineNum">    1601 </span><span class="lineCov">        616 : void genClientPeerId(client *client, char *peerid,</span>
<span class="lineNum">    1602 </span>            :                             size_t peerid_len) {
<span class="lineNum">    1603 </span><span class="lineCov">        616 :     if (client-&gt;flags &amp; CLIENT_UNIX_SOCKET) {</span>
<span class="lineNum">    1604 </span>            :         /* Unix socket client. */
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :         snprintf(peerid,peerid_len,&quot;%s:0&quot;,server.unixsocket);</span>
<span class="lineNum">    1606 </span>            :     } else {
<span class="lineNum">    1607 </span>            :         /* TCP client. */
<span class="lineNum">    1608 </span><span class="lineCov">        616 :         anetFormatPeer(client-&gt;fd,peerid,peerid_len);</span>
<span class="lineNum">    1609 </span>            :     }
<span class="lineNum">    1610 </span><span class="lineCov">        616 : }</span>
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            : /* This function returns the client peer id, by creating and caching it
<span class="lineNum">    1613 </span>            :  * if client-&gt;peerid is NULL, otherwise returning the cached value.
<a name="1614"><span class="lineNum">    1614 </span>            :  * The Peer ID never changes during the life of the client, however it</a>
<span class="lineNum">    1615 </span>            :  * is expensive to compute. */
<span class="lineNum">    1616 </span><span class="lineCov">    1680208 : char *getClientPeerId(client *c) {</span>
<span class="lineNum">    1617 </span><span class="lineCov">    1680208 :     char peerid[NET_PEER_ID_LEN];</span>
<span class="lineNum">    1618 </span>            : 
<span class="lineNum">    1619 </span><span class="lineCov">    1680208 :     if (c-&gt;peerid == NULL) {</span>
<span class="lineNum">    1620 </span><span class="lineCov">        616 :         genClientPeerId(c,peerid,sizeof(peerid));</span>
<span class="lineNum">    1621 </span><span class="lineCov">        616 :         c-&gt;peerid = sdsnew(peerid);</span>
<span class="lineNum">    1622 </span>            :     }
<span class="lineNum">    1623 </span><span class="lineCov">    1680208 :     return c-&gt;peerid;</span>
<span class="lineNum">    1624 </span>            : }
<span class="lineNum">    1625 </span>            : 
<a name="1626"><span class="lineNum">    1626 </span>            : /* Concatenate a string representing the state of a client in an human</a>
<span class="lineNum">    1627 </span>            :  * readable format, into the sds string 's'. */
<span class="lineNum">    1628 </span><span class="lineCov">    1675407 : sds catClientInfoString(sds s, client *client) {</span>
<span class="lineNum">    1629 </span><span class="lineCov">    1675407 :     char flags[16], events[3], *p;</span>
<span class="lineNum">    1630 </span><span class="lineCov">    1675407 :     int emask;</span>
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span><span class="lineCov">    1675407 :     p = flags;</span>
<span class="lineNum">    1633 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_SLAVE) {</span>
<span class="lineNum">    1634 </span><span class="lineCov">         20 :         if (client-&gt;flags &amp; CLIENT_MONITOR)</span>
<span class="lineNum">    1635 </span><span class="lineCov">         20 :             *p++ = 'O';</span>
<span class="lineNum">    1636 </span>            :         else
<span class="lineNum">    1637 </span><span class="lineNoCov">          0 :             *p++ = 'S';</span>
<span class="lineNum">    1638 </span>            :     }
<span class="lineNum">    1639 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_MASTER) *p++ = 'M';</span>
<span class="lineNum">    1640 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_PUBSUB) *p++ = 'P';</span>
<span class="lineNum">    1641 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_MULTI) *p++ = 'x';</span>
<span class="lineNum">    1642 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_BLOCKED) *p++ = 'b';</span>
<span class="lineNum">    1643 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_DIRTY_CAS) *p++ = 'd';</span>
<span class="lineNum">    1644 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';</span>
<span class="lineNum">    1645 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_UNBLOCKED) *p++ = 'u';</span>
<span class="lineNum">    1646 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_CLOSE_ASAP) *p++ = 'A';</span>
<span class="lineNum">    1647 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_UNIX_SOCKET) *p++ = 'U';</span>
<span class="lineNum">    1648 </span><span class="lineCov">    1675407 :     if (client-&gt;flags &amp; CLIENT_READONLY) *p++ = 'r';</span>
<span class="lineNum">    1649 </span><span class="lineCov">    1675407 :     if (p == flags) *p++ = 'N';</span>
<span class="lineNum">    1650 </span><span class="lineCov">    1675407 :     *p++ = '\0';</span>
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span><span class="lineCov">    1675407 :     emask = client-&gt;fd == -1 ? 0 : aeGetFileEvents(server.el,client-&gt;fd);</span>
<span class="lineNum">    1653 </span><span class="lineCov">    1675407 :     p = events;</span>
<span class="lineNum">    1654 </span><span class="lineCov">    1675407 :     if (emask &amp; AE_READABLE) *p++ = 'r';</span>
<span class="lineNum">    1655 </span><span class="lineCov">    1675407 :     if (emask &amp; AE_WRITABLE) *p++ = 'w';</span>
<span class="lineNum">    1656 </span><span class="lineCov">    1675407 :     *p = '\0';</span>
<span class="lineNum">    1657 </span><span class="lineCov">    3350805 :     return sdscatfmt(s,</span>
<span class="lineNum">    1658 </span>            :         &quot;id=%U addr=%s fd=%i name=%s age=%I idle=%I flags=%s db=%i sub=%i psub=%i multi=%i qbuf=%U qbuf-free=%U obl=%U oll=%U omem=%U events=%s cmd=%s&quot;,
<span class="lineNum">    1659 </span><span class="lineCov">    1675407 :         (unsigned long long) client-&gt;id,</span>
<span class="lineNum">    1660 </span>            :         getClientPeerId(client),
<span class="lineNum">    1661 </span>            :         client-&gt;fd,
<span class="lineNum">    1662 </span><span class="lineCov">    1675407 :         client-&gt;name ? (char*)client-&gt;name-&gt;ptr : &quot;&quot;,</span>
<span class="lineNum">    1663 </span><span class="lineCov">    1675407 :         (long long)(server.unixtime - client-&gt;ctime),</span>
<span class="lineNum">    1664 </span><span class="lineCov">    1675407 :         (long long)(server.unixtime - client-&gt;lastinteraction),</span>
<span class="lineNum">    1665 </span>            :         flags,
<span class="lineNum">    1666 </span><span class="lineCov">    1675407 :         client-&gt;db-&gt;id,</span>
<span class="lineNum">    1667 </span><span class="lineCov">    1675407 :         (int) dictSize(client-&gt;pubsub_channels),</span>
<span class="lineNum">    1668 </span><span class="lineCov">    1675407 :         (int) listLength(client-&gt;pubsub_patterns),</span>
<span class="lineNum">    1669 </span><span class="lineCov">    1675407 :         (client-&gt;flags &amp; CLIENT_MULTI) ? client-&gt;mstate.count : -1,</span>
<span class="lineNum">    1670 </span><span class="lineCov">    1675407 :         (unsigned long long) sdslen(client-&gt;querybuf),</span>
<span class="lineNum">    1671 </span><span class="lineCov">    1675407 :         (unsigned long long) sdsavail(client-&gt;querybuf),</span>
<span class="lineNum">    1672 </span><span class="lineCov">    1675407 :         (unsigned long long) client-&gt;bufpos,</span>
<span class="lineNum">    1673 </span>            :         (unsigned long long) listLength(client-&gt;reply),
<span class="lineNum">    1674 </span><span class="lineCov">    3350814 :         (unsigned long long) getClientOutputBufferMemoryUsage(client),</span>
<span class="lineNum">    1675 </span>            :         events,
<span class="lineNum">    1676 </span><span class="lineCov">    1675407 :         client-&gt;lastcmd ? client-&gt;lastcmd-&gt;name : &quot;NULL&quot;);</span>
<a name="1677"><span class="lineNum">    1677 </span>            : }</a>
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span><span class="lineCov">     837599 : sds getAllClientsInfoString(int type) {</span>
<span class="lineNum">    1680 </span><span class="lineCov">     837599 :     listNode *ln;</span>
<span class="lineNum">    1681 </span><span class="lineCov">     837599 :     listIter li;</span>
<span class="lineNum">    1682 </span><span class="lineCov">     837599 :     client *client;</span>
<span class="lineNum">    1683 </span><span class="lineCov">     837599 :     sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));</span>
<span class="lineNum">    1684 </span><span class="lineCov">     837599 :     sdsclear(o);</span>
<span class="lineNum">    1685 </span><span class="lineCov">     837599 :     listRewind(server.clients,&amp;li);</span>
<span class="lineNum">    1686 </span><span class="lineCov">    2512794 :     while ((ln = listNext(&amp;li)) != NULL) {</span>
<span class="lineNum">    1687 </span><span class="lineCov">    1675195 :         client = listNodeValue(ln);</span>
<span class="lineNum">    1688 </span><span class="lineCov">    1675195 :         if (type != -1 &amp;&amp; getClientType(client) != type) continue;</span>
<span class="lineNum">    1689 </span><span class="lineCov">    1675195 :         o = catClientInfoString(o,client);</span>
<span class="lineNum">    1690 </span><span class="lineCov">    1675195 :         o = sdscatlen(o,&quot;\n&quot;,1);</span>
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span><span class="lineCov">     837599 :     return o;</span>
<a name="1693"><span class="lineNum">    1693 </span>            : }</a>
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineCov">     837760 : void clientCommand(client *c) {</span>
<span class="lineNum">    1696 </span><span class="lineCov">     837760 :     listNode *ln;</span>
<span class="lineNum">    1697 </span><span class="lineCov">     837760 :     listIter li;</span>
<span class="lineNum">    1698 </span><span class="lineCov">     837760 :     client *client;</span>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span><span class="lineCov">     837760 :     if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :         const char *help[] = {</span>
<span class="lineNum">    1702 </span>            : &quot;id                     -- Return the ID of the current connection.&quot;,
<span class="lineNum">    1703 </span>            : &quot;getname                -- Return the name of the current connection.&quot;,
<span class="lineNum">    1704 </span>            : &quot;kill &lt;ip:port&gt;         -- Kill connection made from &lt;ip:port&gt;.&quot;,
<span class="lineNum">    1705 </span>            : &quot;kill &lt;option&gt; &lt;value&gt; [option value ...] -- Kill connections. Options are:&quot;,
<span class="lineNum">    1706 </span>            : &quot;     addr &lt;ip:port&gt;                      -- Kill connection made from &lt;ip:port&gt;&quot;,
<span class="lineNum">    1707 </span>            : &quot;     type (normal|master|replica|pubsub) -- Kill connections by type.&quot;,
<span class="lineNum">    1708 </span>            : &quot;     skipme (yes|no)   -- Skip killing current connection (default: yes).&quot;,
<span class="lineNum">    1709 </span>            : &quot;list [options ...]     -- Return information about client connections. Options:&quot;,
<span class="lineNum">    1710 </span>            : &quot;     type (normal|master|replica|pubsub) -- Return clients of specified type.&quot;,
<span class="lineNum">    1711 </span>            : &quot;pause &lt;timeout&gt;        -- Suspend all Redis clients for &lt;timout&gt; milliseconds.&quot;,
<span class="lineNum">    1712 </span>            : &quot;reply (on|off|skip)    -- Control the replies sent to the current connection.&quot;,
<span class="lineNum">    1713 </span>            : &quot;setname &lt;name&gt;         -- Assign the name &lt;name&gt; to the current connection.&quot;,
<span class="lineNum">    1714 </span>            : &quot;unblock &lt;clientid&gt; [TIMEOUT|ERROR] -- Unblock the specified blocked client.&quot;,
<span class="lineNum">    1715 </span>            : NULL
<span class="lineNum">    1716 </span>            :         };
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :         addReplyHelp(c, help);</span>
<span class="lineNum">    1718 </span><span class="lineCov">     837760 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;id&quot;) &amp;&amp; c-&gt;argc == 2) {</span>
<span class="lineNum">    1719 </span>            :         /* CLIENT ID */
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :         addReplyLongLong(c,c-&gt;id);</span>
<span class="lineNum">    1721 </span><span class="lineCov">     837760 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;list&quot;)) {</span>
<span class="lineNum">    1722 </span>            :         /* CLIENT LIST */
<span class="lineNum">    1723 </span><span class="lineCov">     837599 :         int type = -1;</span>
<span class="lineNum">    1724 </span><span class="lineCov">     837599 :         if (c-&gt;argc == 4 &amp;&amp; !strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;type&quot;)) {</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :             type = getClientTypeByName(c-&gt;argv[3]-&gt;ptr);</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :             if (type == -1) {</span>
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :                 addReplyErrorFormat(c,&quot;Unknown client type '%s'&quot;,</span>
<span class="lineNum">    1728 </span>            :                     (char*) c-&gt;argv[3]-&gt;ptr);
<span class="lineNum">    1729 </span><span class="lineCov">          2 :                 return;</span>
<span class="lineNum">    1730 </span>            :              }
<span class="lineNum">    1731 </span><span class="lineCov">     837599 :         } else if (c-&gt;argc != 2) {</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :             addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1734 </span>            :         }
<span class="lineNum">    1735 </span><span class="lineCov">     837599 :         sds o = getAllClientsInfoString(type);</span>
<span class="lineNum">    1736 </span><span class="lineCov">    1675198 :         addReplyBulkCBuffer(c,o,sdslen(o));</span>
<span class="lineNum">    1737 </span><span class="lineCov">     837599 :         sdsfree(o);</span>
<span class="lineNum">    1738 </span><span class="lineCov">        161 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;reply&quot;) &amp;&amp; c-&gt;argc == 3) {</span>
<span class="lineNum">    1739 </span>            :         /* CLIENT REPLY ON|OFF|SKIP */
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :         if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;on&quot;)) {</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :             c-&gt;flags &amp;= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;off&quot;)) {</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :             c-&gt;flags |= CLIENT_REPLY_OFF;</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;skip&quot;)) {</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :             if (!(c-&gt;flags &amp; CLIENT_REPLY_OFF))</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :                 c-&gt;flags |= CLIENT_REPLY_SKIP_NEXT;</span>
<span class="lineNum">    1748 </span>            :         } else {
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :             addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1751 </span>            :         }
<span class="lineNum">    1752 </span><span class="lineCov">        161 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;kill&quot;)) {</span>
<span class="lineNum">    1753 </span>            :         /* CLIENT KILL &lt;ip:port&gt;
<span class="lineNum">    1754 </span>            :          * CLIENT KILL &lt;option&gt; [value] ... &lt;option&gt; [value] */
<span class="lineNum">    1755 </span><span class="lineCov">        147 :         char *addr = NULL;</span>
<span class="lineNum">    1756 </span><span class="lineCov">        147 :         int type = -1;</span>
<span class="lineNum">    1757 </span><span class="lineCov">        147 :         uint64_t id = 0;</span>
<span class="lineNum">    1758 </span><span class="lineCov">        147 :         int skipme = 1;</span>
<span class="lineNum">    1759 </span><span class="lineCov">        147 :         int killed = 0, close_this_client = 0;</span>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span><span class="lineCov">        147 :         if (c-&gt;argc == 3) {</span>
<span class="lineNum">    1762 </span>            :             /* Old style syntax: CLIENT KILL &lt;addr&gt; */
<span class="lineNum">    1763 </span><span class="lineCov">         60 :             addr = c-&gt;argv[2]-&gt;ptr;</span>
<span class="lineNum">    1764 </span><span class="lineCov">         60 :             skipme = 0; /* With the old form, you can kill yourself. */</span>
<span class="lineNum">    1765 </span><span class="lineCov">         87 :         } else if (c-&gt;argc &gt; 3) {</span>
<span class="lineNum">    1766 </span>            :             int i = 2; /* Next option index. */
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :             /* New style syntax: parse options. */
<span class="lineNum">    1769 </span><span class="lineCov">        174 :             while(i &lt; c-&gt;argc) {</span>
<span class="lineNum">    1770 </span><span class="lineCov">         87 :                 int moreargs = c-&gt;argc &gt; i+1;</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span><span class="lineCov">         87 :                 if (!strcasecmp(c-&gt;argv[i]-&gt;ptr,&quot;id&quot;) &amp;&amp; moreargs) {</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :                     long long tmp;</span>
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :                     if (getLongLongFromObjectOrReply(c,c-&gt;argv[i+1],&amp;tmp,NULL)</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :                         != C_OK) return;</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :                     id = tmp;</span>
<span class="lineNum">    1778 </span><span class="lineCov">         87 :                 } else if (!strcasecmp(c-&gt;argv[i]-&gt;ptr,&quot;type&quot;) &amp;&amp; moreargs) {</span>
<span class="lineNum">    1779 </span><span class="lineCov">         87 :                     type = getClientTypeByName(c-&gt;argv[i+1]-&gt;ptr);</span>
<span class="lineNum">    1780 </span><span class="lineCov">         87 :                     if (type == -1) {</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :                         addReplyErrorFormat(c,&quot;Unknown client type '%s'&quot;,</span>
<span class="lineNum">    1782 </span>            :                             (char*) c-&gt;argv[i+1]-&gt;ptr);
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    1784 </span>            :                     }
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :                 } else if (!strcasecmp(c-&gt;argv[i]-&gt;ptr,&quot;addr&quot;) &amp;&amp; moreargs) {</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                     addr = c-&gt;argv[i+1]-&gt;ptr;</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                 } else if (!strcasecmp(c-&gt;argv[i]-&gt;ptr,&quot;skipme&quot;) &amp;&amp; moreargs) {</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :                     if (!strcasecmp(c-&gt;argv[i+1]-&gt;ptr,&quot;yes&quot;)) {</span>
<span class="lineNum">    1789 </span>            :                         skipme = 1;
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :                     } else if (!strcasecmp(c-&gt;argv[i+1]-&gt;ptr,&quot;no&quot;)) {</span>
<span class="lineNum">    1791 </span>            :                         skipme = 0;
<span class="lineNum">    1792 </span>            :                     } else {
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :                         addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :                         return;</span>
<span class="lineNum">    1795 </span>            :                     }
<span class="lineNum">    1796 </span>            :                 } else {
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :                     addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :                     return;</span>
<span class="lineNum">    1799 </span>            :                 }
<span class="lineNum">    1800 </span><span class="lineCov">         87 :                 i += 2;</span>
<span class="lineNum">    1801 </span>            :             }
<span class="lineNum">    1802 </span>            :         } else {
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :             addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1805 </span>            :         }
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            :         /* Iterate clients killing all the matching clients. */
<span class="lineNum">    1808 </span><span class="lineCov">        147 :         listRewind(server.clients,&amp;li);</span>
<span class="lineNum">    1809 </span><span class="lineCov">        459 :         while ((ln = listNext(&amp;li)) != NULL) {</span>
<span class="lineNum">    1810 </span><span class="lineCov">        312 :             client = listNodeValue(ln);</span>
<span class="lineNum">    1811 </span><span class="lineCov">        312 :             if (addr &amp;&amp; strcmp(getClientPeerId(client),addr) != 0) continue;</span>
<span class="lineNum">    1812 </span><span class="lineCov">        450 :             if (type != -1 &amp;&amp; getClientType(client) != type) continue;</span>
<span class="lineNum">    1813 </span><span class="lineCov">        125 :             if (id != 0 &amp;&amp; client-&gt;id != id) continue;</span>
<span class="lineNum">    1814 </span><span class="lineCov">        125 :             if (c == client &amp;&amp; skipme) continue;</span>
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            :             /* Kill it. */
<span class="lineNum">    1817 </span><span class="lineCov">        125 :             if (c == client) {</span>
<span class="lineNum">    1818 </span>            :                 close_this_client = 1;
<span class="lineNum">    1819 </span>            :             } else {
<span class="lineNum">    1820 </span><span class="lineCov">        125 :                 freeClient(client);</span>
<span class="lineNum">    1821 </span>            :             }
<span class="lineNum">    1822 </span><span class="lineCov">        125 :             killed++;</span>
<span class="lineNum">    1823 </span>            :         }
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            :         /* Reply according to old/new format. */
<span class="lineNum">    1826 </span><span class="lineCov">        147 :         if (c-&gt;argc == 3) {</span>
<span class="lineNum">    1827 </span><span class="lineCov">         60 :             if (killed == 0)</span>
<span class="lineNum">    1828 </span><span class="lineCov">          6 :                 addReplyError(c,&quot;No such client&quot;);</span>
<span class="lineNum">    1829 </span>            :             else
<span class="lineNum">    1830 </span><span class="lineCov">         54 :                 addReply(c,shared.ok);</span>
<span class="lineNum">    1831 </span>            :         } else {
<span class="lineNum">    1832 </span><span class="lineCov">         87 :             addReplyLongLong(c,killed);</span>
<span class="lineNum">    1833 </span>            :         }
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            :         /* If this client has to be closed, flag it as CLOSE_AFTER_REPLY
<span class="lineNum">    1836 </span>            :          * only after we queued the reply to its output buffers. */
<span class="lineNum">    1837 </span><span class="lineCov">        147 :         if (close_this_client) c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span>
<span class="lineNum">    1838 </span><span class="lineCov">         14 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;unblock&quot;) &amp;&amp; (c-&gt;argc == 3 ||</span>
<span class="lineNum">    1839 </span>            :                                                           c-&gt;argc == 4))
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1841 </span>            :         /* CLIENT UNBLOCK &lt;id&gt; [timeout|error] */
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :         long long id;</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :         int unblock_error = 0;</span>
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :         if (c-&gt;argc == 4) {</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :             if (!strcasecmp(c-&gt;argv[3]-&gt;ptr,&quot;timeout&quot;)) {</span>
<span class="lineNum">    1847 </span>            :                 unblock_error = 0;
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :             } else if (!strcasecmp(c-&gt;argv[3]-&gt;ptr,&quot;error&quot;)) {</span>
<span class="lineNum">    1849 </span>            :                 unblock_error = 1;
<span class="lineNum">    1850 </span>            :             } else {
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :                 addReplyError(c,</span>
<span class="lineNum">    1852 </span>            :                     &quot;CLIENT UNBLOCK reason should be TIMEOUT or ERROR&quot;);
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    1854 </span>            :             }
<span class="lineNum">    1855 </span>            :         }
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :         if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;id,NULL)</span>
<span class="lineNum">    1857 </span>            :             != C_OK) return;
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :         struct client *target = lookupClientByID(id);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :         if (target &amp;&amp; target-&gt;flags &amp; CLIENT_BLOCKED) {</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :             if (unblock_error)</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :                 addReplyError(target,</span>
<span class="lineNum">    1862 </span>            :                     &quot;-UNBLOCKED client unblocked via CLIENT UNBLOCK&quot;);
<span class="lineNum">    1863 </span>            :             else
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :                 replyToBlockedClientTimedOut(target);</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :             unblockClient(target);</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :             addReply(c,shared.cone);</span>
<span class="lineNum">    1867 </span>            :         } else {
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :             addReply(c,shared.czero);</span>
<span class="lineNum">    1869 </span>            :         }
<span class="lineNum">    1870 </span><span class="lineCov">         24 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;setname&quot;) &amp;&amp; c-&gt;argc == 3) {</span>
<span class="lineNum">    1871 </span><span class="lineCov">         12 :         int j, len = sdslen(c-&gt;argv[2]-&gt;ptr);</span>
<span class="lineNum">    1872 </span><span class="lineCov">         12 :         char *p = c-&gt;argv[2]-&gt;ptr;</span>
<span class="lineNum">    1873 </span>            : 
<span class="lineNum">    1874 </span>            :         /* Setting the client name to an empty string actually removes
<span class="lineNum">    1875 </span>            :          * the current name. */
<span class="lineNum">    1876 </span><span class="lineCov">         12 :         if (len == 0) {</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :             if (c-&gt;name) decrRefCount(c-&gt;name);</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :             c-&gt;name = NULL;</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1881 </span>            :         }
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            :         /* Otherwise check if the charset is ok. We need to do this otherwise
<span class="lineNum">    1884 </span>            :          * CLIENT LIST format will break. You should always be able to
<span class="lineNum">    1885 </span>            :          * split by space to get the different fields. */
<span class="lineNum">    1886 </span><span class="lineCov">        112 :         for (j = 0; j &lt; len; j++) {</span>
<span class="lineNum">    1887 </span><span class="lineCov">        102 :             if (p[j] &lt; '!' || p[j] &gt; '~') { /* ASCII is assumed. */</span>
<span class="lineNum">    1888 </span><span class="lineCov">          4 :                 addReplyError(c,</span>
<span class="lineNum">    1889 </span>            :                     &quot;Client names cannot contain spaces, &quot;
<span class="lineNum">    1890 </span>            :                     &quot;newlines or special characters.&quot;);
<span class="lineNum">    1891 </span><span class="lineCov">          2 :                 return;</span>
<span class="lineNum">    1892 </span>            :             }
<span class="lineNum">    1893 </span>            :         }
<span class="lineNum">    1894 </span><span class="lineCov">         10 :         if (c-&gt;name) decrRefCount(c-&gt;name);</span>
<span class="lineNum">    1895 </span><span class="lineCov">         10 :         c-&gt;name = c-&gt;argv[2];</span>
<span class="lineNum">    1896 </span><span class="lineCov">         10 :         incrRefCount(c-&gt;name);</span>
<span class="lineNum">    1897 </span><span class="lineCov">         10 :         addReply(c,shared.ok);</span>
<span class="lineNum">    1898 </span><span class="lineCov">          2 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;getname&quot;) &amp;&amp; c-&gt;argc == 2) {</span>
<span class="lineNum">    1899 </span><span class="lineCov">          2 :         if (c-&gt;name)</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :             addReplyBulk(c,c-&gt;name);</span>
<span class="lineNum">    1901 </span>            :         else
<span class="lineNum">    1902 </span><span class="lineCov">          2 :             addReply(c,shared.nullbulk);</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;pause&quot;) &amp;&amp; c-&gt;argc == 3) {</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :         long long duration;</span>
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :         if (getTimeoutFromObjectOrReply(c,c-&gt;argv[2],&amp;duration,UNIT_MILLISECONDS)</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :                                         != C_OK) return;</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :         pauseClients(duration);</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :         addReply(c,shared.ok);</span>
<span class="lineNum">    1910 </span>            :     } else {
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :         addReplyErrorFormat(c, &quot;Unknown subcommand or wrong number of arguments for '%s'. Try CLIENT HELP&quot;, (char*)c-&gt;argv[1]-&gt;ptr);</span>
<span class="lineNum">    1912 </span>            :     }
<span class="lineNum">    1913 </span>            : }
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            : /* This callback is bound to POST and &quot;Host:&quot; command names. Those are not
<span class="lineNum">    1916 </span>            :  * really commands, but are used in security attacks in order to talk to
<span class="lineNum">    1917 </span>            :  * Redis instances via HTTP, with a technique called &quot;cross protocol scripting&quot;
<span class="lineNum">    1918 </span>            :  * which exploits the fact that services like Redis will discard invalid
<span class="lineNum">    1919 </span>            :  * HTTP headers and will process what follows.
<span class="lineNum">    1920 </span>            :  *
<span class="lineNum">    1921 </span>            :  * As a protection against this attack, Redis will terminate the connection
<a name="1922"><span class="lineNum">    1922 </span>            :  * when a POST or &quot;Host:&quot; header is seen, and will log the event from</a>
<span class="lineNum">    1923 </span>            :  * time to time (to avoid creating a DOS as a result of too many logs). */
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 : void securityWarningCommand(client *c) {</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :     static time_t logged_time;</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :     time_t now = time(NULL);</span>
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     if (labs(now-logged_time) &gt; 60) {</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.&quot;);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :         logged_time = now;</span>
<span class="lineNum">    1931 </span>            :     }
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     freeClientAsync(c);</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span>            : /* Rewrite the command vector of the client. All the new objects ref count
<a name="1936"><span class="lineNum">    1936 </span>            :  * is incremented. The old command vector is freed, and the old objects</a>
<span class="lineNum">    1937 </span>            :  * ref count is decremented. */
<span class="lineNum">    1938 </span><span class="lineCov">      27080 : void rewriteClientCommandVector(client *c, int argc, ...) {</span>
<span class="lineNum">    1939 </span><span class="lineCov">      27080 :     va_list ap;</span>
<span class="lineNum">    1940 </span><span class="lineCov">      27080 :     int j;</span>
<span class="lineNum">    1941 </span><span class="lineCov">      27080 :     robj **argv; /* The new argument vector */</span>
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span><span class="lineCov">      27080 :     argv = zmalloc(sizeof(robj*)*argc);</span>
<span class="lineNum">    1944 </span><span class="lineCov">      27080 :     va_start(ap,argc);</span>
<span class="lineNum">    1945 </span><span class="lineCov">     107944 :     for (j = 0; j &lt; argc; j++) {</span>
<span class="lineNum">    1946 </span><span class="lineCov">      80864 :         robj *a;</span>
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span><span class="lineCov">      80864 :         a = va_arg(ap, robj*);</span>
<span class="lineNum">    1949 </span><span class="lineCov">      80864 :         argv[j] = a;</span>
<span class="lineNum">    1950 </span><span class="lineCov">      80864 :         incrRefCount(a);</span>
<span class="lineNum">    1951 </span>            :     }
<span class="lineNum">    1952 </span>            :     /* We free the objects in the original vector at the end, so we are
<span class="lineNum">    1953 </span>            :      * sure that if the same objects are reused in the new vector the
<span class="lineNum">    1954 </span>            :      * refcount gets incremented before it gets decremented. */
<span class="lineNum">    1955 </span><span class="lineCov">      81821 :     for (j = 0; j &lt; c-&gt;argc; j++) decrRefCount(c-&gt;argv[j]);</span>
<span class="lineNum">    1956 </span><span class="lineCov">      27080 :     zfree(c-&gt;argv);</span>
<span class="lineNum">    1957 </span>            :     /* Replace argv and argc with our new versions. */
<span class="lineNum">    1958 </span><span class="lineCov">      27080 :     c-&gt;argv = argv;</span>
<span class="lineNum">    1959 </span><span class="lineCov">      27080 :     c-&gt;argc = argc;</span>
<span class="lineNum">    1960 </span><span class="lineCov">      27080 :     c-&gt;cmd = lookupCommandOrOriginal(c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">    1961 </span><span class="lineCov">      27080 :     serverAssertWithInfo(c,NULL,c-&gt;cmd != NULL);</span>
<span class="lineNum">    1962 </span><span class="lineCov">      27080 :     va_end(ap);</span>
<span class="lineNum">    1963 </span><span class="lineCov">      27080 : }</span>
<a name="1964"><span class="lineNum">    1964 </span>            : </a>
<span class="lineNum">    1965 </span>            : /* Completely replace the client command vector with the provided one. */
<span class="lineNum">    1966 </span><span class="lineCov">        122 : void replaceClientCommandVector(client *c, int argc, robj **argv) {</span>
<span class="lineNum">    1967 </span><span class="lineCov">        122 :     freeClientArgv(c);</span>
<span class="lineNum">    1968 </span><span class="lineCov">        122 :     zfree(c-&gt;argv);</span>
<span class="lineNum">    1969 </span><span class="lineCov">        122 :     c-&gt;argv = argv;</span>
<span class="lineNum">    1970 </span><span class="lineCov">        122 :     c-&gt;argc = argc;</span>
<span class="lineNum">    1971 </span><span class="lineCov">        122 :     c-&gt;cmd = lookupCommandOrOriginal(c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">    1972 </span><span class="lineCov">        122 :     serverAssertWithInfo(c,NULL,c-&gt;cmd != NULL);</span>
<span class="lineNum">    1973 </span><span class="lineCov">        122 : }</span>
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            : /* Rewrite a single item in the command vector.
<span class="lineNum">    1976 </span>            :  * The new val ref count is incremented, and the old decremented.
<span class="lineNum">    1977 </span>            :  *
<span class="lineNum">    1978 </span>            :  * It is possible to specify an argument over the current size of the
<span class="lineNum">    1979 </span>            :  * argument vector: in this case the array of objects gets reallocated
<span class="lineNum">    1980 </span>            :  * and c-&gt;argc set to the max value. However it's up to the caller to
<span class="lineNum">    1981 </span>            :  *
<span class="lineNum">    1982 </span>            :  * 1. Make sure there are no &quot;holes&quot; and all the arguments are set.
<span class="lineNum">    1983 </span>            :  * 2. If the original argument vector was longer than the one we
<a name="1984"><span class="lineNum">    1984 </span>            :  *    want to end with, it's up to the caller to set c-&gt;argc and</a>
<span class="lineNum">    1985 </span>            :  *    free the no longer used objects on c-&gt;argv. */
<span class="lineNum">    1986 </span><span class="lineCov">      64356 : void rewriteClientCommandArgument(client *c, int i, robj *newval) {</span>
<span class="lineNum">    1987 </span><span class="lineCov">      64356 :     robj *oldval;</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineCov">      64356 :     if (i &gt;= c-&gt;argc) {</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         c-&gt;argv = zrealloc(c-&gt;argv,sizeof(robj*)*(i+1));</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :         c-&gt;argc = i+1;</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :         c-&gt;argv[i] = NULL;</span>
<span class="lineNum">    1993 </span>            :     }
<span class="lineNum">    1994 </span><span class="lineCov">      64356 :     oldval = c-&gt;argv[i];</span>
<span class="lineNum">    1995 </span><span class="lineCov">      64356 :     c-&gt;argv[i] = newval;</span>
<span class="lineNum">    1996 </span><span class="lineCov">      64356 :     incrRefCount(newval);</span>
<span class="lineNum">    1997 </span><span class="lineCov">      64356 :     if (oldval) decrRefCount(oldval);</span>
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span>            :     /* If this is the command name make sure to fix c-&gt;cmd. */
<span class="lineNum">    2000 </span><span class="lineCov">      64356 :     if (i == 0) {</span>
<span class="lineNum">    2001 </span><span class="lineCov">         60 :         c-&gt;cmd = lookupCommandOrOriginal(c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">    2002 </span><span class="lineCov">         60 :         serverAssertWithInfo(c,NULL,c-&gt;cmd != NULL);</span>
<span class="lineNum">    2003 </span>            :     }
<span class="lineNum">    2004 </span><span class="lineCov">      64356 : }</span>
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span>            : /* This function returns the number of bytes that Redis is virtually
<span class="lineNum">    2007 </span>            :  * using to store the reply still not read by the client.
<span class="lineNum">    2008 </span>            :  * It is &quot;virtual&quot; since the reply output list may contain objects that
<span class="lineNum">    2009 </span>            :  * are shared and are not really using additional memory.
<span class="lineNum">    2010 </span>            :  *
<span class="lineNum">    2011 </span>            :  * The function returns the total sum of the length of all the objects
<span class="lineNum">    2012 </span>            :  * stored in the output list, plus the memory used to allocate every
<span class="lineNum">    2013 </span>            :  * list node. The static reply buffer is not taken into account since it
<span class="lineNum">    2014 </span>            :  * is allocated anyway.
<span class="lineNum">    2015 </span>            :  *
<span class="lineNum">    2016 </span>            :  * Note: this function is very fast so can be called as many time as
<a name="2017"><span class="lineNum">    2017 </span>            :  * the caller wishes. The main usage of this function currently is</a>
<span class="lineNum">    2018 </span>            :  * enforcing the client output length limits. */
<span class="lineNum">    2019 </span><span class="lineCov">     277410 : unsigned long getClientOutputBufferMemoryUsage(client *c) {</span>
<span class="lineNum">    2020 </span><span class="lineCov">  106838753 :     unsigned long list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);</span>
<span class="lineNum">    2021 </span><span class="lineCov">    1675407 :     return c-&gt;reply_bytes + (list_item_size*listLength(c-&gt;reply));</span>
<span class="lineNum">    2022 </span>            : }
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            : /* Get the class of a client, used in order to enforce limits to different
<span class="lineNum">    2025 </span>            :  * classes of clients.
<span class="lineNum">    2026 </span>            :  *
<span class="lineNum">    2027 </span>            :  * The function will return one of the following:
<span class="lineNum">    2028 </span>            :  * CLIENT_TYPE_NORMAL -&gt; Normal client
<span class="lineNum">    2029 </span>            :  * CLIENT_TYPE_SLAVE  -&gt; Slave or client executing MONITOR command
<span class="lineNum">    2030 </span>            :  * CLIENT_TYPE_PUBSUB -&gt; Client subscribed to Pub/Sub channels
<a name="2031"><span class="lineNum">    2031 </span>            :  * CLIENT_TYPE_MASTER -&gt; The client representing our replication master.</a>
<span class="lineNum">    2032 </span>            :  */
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 : int getClientType(client *c) {</span>
<span class="lineNum">    2034 </span><span class="lineCov">        198 :     if (c-&gt;flags &amp; CLIENT_MASTER) return CLIENT_TYPE_MASTER;</span>
<span class="lineNum">    2035 </span><span class="lineCov">  104886067 :     if ((c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; !(c-&gt;flags &amp; CLIENT_MONITOR))</span>
<span class="lineNum">    2036 </span>            :         return CLIENT_TYPE_SLAVE;
<span class="lineNum">    2037 </span><span class="lineCov">   13070264 :     if (c-&gt;flags &amp; CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;</span>
<span class="lineNum">    2038 </span>            :     return CLIENT_TYPE_NORMAL;
<a name="2039"><span class="lineNum">    2039 </span>            : }</a>
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span><span class="lineCov">        115 : int getClientTypeByName(char *name) {</span>
<span class="lineNum">    2042 </span><span class="lineCov">        115 :     if (!strcasecmp(name,&quot;normal&quot;)) return CLIENT_TYPE_NORMAL;</span>
<span class="lineNum">    2043 </span><span class="lineCov">        115 :     else if (!strcasecmp(name,&quot;slave&quot;)) return CLIENT_TYPE_SLAVE;</span>
<span class="lineNum">    2044 </span><span class="lineCov">        111 :     else if (!strcasecmp(name,&quot;replica&quot;)) return CLIENT_TYPE_SLAVE;</span>
<span class="lineNum">    2045 </span><span class="lineCov">         95 :     else if (!strcasecmp(name,&quot;pubsub&quot;)) return CLIENT_TYPE_PUBSUB;</span>
<span class="lineNum">    2046 </span><span class="lineCov">         83 :     else if (!strcasecmp(name,&quot;master&quot;)) return CLIENT_TYPE_MASTER;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :     else return -1;</span>
<a name="2048"><span class="lineNum">    2048 </span>            : }</a>
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 : char *getClientTypeName(int class) {</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :     switch(class) {</span>
<span class="lineNum">    2052 </span>            :     case CLIENT_TYPE_NORMAL: return &quot;normal&quot;;
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :     case CLIENT_TYPE_SLAVE:  return &quot;slave&quot;;</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :     case CLIENT_TYPE_PUBSUB: return &quot;pubsub&quot;;</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     case CLIENT_TYPE_MASTER: return &quot;master&quot;;</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :     default:                       return NULL;</span>
<span class="lineNum">    2057 </span>            :     }
<span class="lineNum">    2058 </span>            : }
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : /* The function checks if the client reached output buffer soft or hard
<span class="lineNum">    2061 </span>            :  * limit, and also update the state needed to check the soft limit as
<span class="lineNum">    2062 </span>            :  * a side effect.
<span class="lineNum">    2063 </span>            :  *
<a name="2064"><span class="lineNum">    2064 </span>            :  * Return value: non-zero if the client reached the soft or the hard limit.</a>
<span class="lineNum">    2065 </span>            :  *               Otherwise zero is returned. */
<span class="lineNum">    2066 </span><span class="lineCov">  104885936 : int checkClientOutputBufferLimits(client *c) {</span>
<span class="lineNum">    2067 </span><span class="lineCov">  104885936 :     int soft = 0, hard = 0, class;</span>
<span class="lineNum">    2068 </span><span class="lineCov">  209771872 :     unsigned long used_mem = getClientOutputBufferMemoryUsage(c);</span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineCov">  104885936 :     class = getClientType(c);</span>
<span class="lineNum">    2071 </span>            :     /* For the purpose of output buffer limiting, masters are handled
<span class="lineNum">    2072 </span>            :      * like normal clients. */
<span class="lineNum">    2073 </span><span class="lineCov">   10672773 :     if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span><span class="lineCov">  104885936 :     if (server.client_obuf_limits[class].hard_limit_bytes &amp;&amp;</span>
<span class="lineNum">    2076 </span>            :         used_mem &gt;= server.client_obuf_limits[class].hard_limit_bytes)
<span class="lineNum">    2077 </span><span class="lineCov">          2 :         hard = 1;</span>
<span class="lineNum">    2078 </span><span class="lineCov">  104885936 :     if (server.client_obuf_limits[class].soft_limit_bytes &amp;&amp;</span>
<span class="lineNum">    2079 </span>            :         used_mem &gt;= server.client_obuf_limits[class].soft_limit_bytes)
<span class="lineNum">    2080 </span><span class="lineCov">    2285146 :         soft = 1;</span>
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span>            :     /* We need to check if the soft limit is reached continuously for the
<span class="lineNum">    2083 </span>            :      * specified amount of seconds. */
<span class="lineNum">    2084 </span><span class="lineCov">    2285146 :     if (soft) {</span>
<span class="lineNum">    2085 </span><span class="lineCov">    2285146 :         if (c-&gt;obuf_soft_limit_reached_time == 0) {</span>
<span class="lineNum">    2086 </span><span class="lineCov">          4 :             c-&gt;obuf_soft_limit_reached_time = server.unixtime;</span>
<span class="lineNum">    2087 </span><span class="lineCov">          4 :             soft = 0; /* First time we see the soft limit reached */</span>
<span class="lineNum">    2088 </span>            :         } else {
<span class="lineNum">    2089 </span><span class="lineCov">    2285142 :             time_t elapsed = server.unixtime - c-&gt;obuf_soft_limit_reached_time;</span>
<span class="lineNum">    2090 </span>            : 
<span class="lineNum">    2091 </span><span class="lineCov">    4570284 :             if (elapsed &lt;=</span>
<span class="lineNum">    2092 </span><span class="lineCov">    2285142 :                 server.client_obuf_limits[class].soft_limit_seconds) {</span>
<span class="lineNum">    2093 </span><span class="lineCov">    2285140 :                 soft = 0; /* The client still did not reached the max number of</span>
<span class="lineNum">    2094 </span>            :                              seconds for the soft limit to be considered
<span class="lineNum">    2095 </span>            :                              reached. */
<span class="lineNum">    2096 </span>            :             }
<span class="lineNum">    2097 </span>            :         }
<span class="lineNum">    2098 </span>            :     } else {
<span class="lineNum">    2099 </span><span class="lineCov">  102600790 :         c-&gt;obuf_soft_limit_reached_time = 0;</span>
<span class="lineNum">    2100 </span>            :     }
<span class="lineNum">    2101 </span><span class="lineCov">  104885936 :     return soft || hard;</span>
<span class="lineNum">    2102 </span>            : }
<span class="lineNum">    2103 </span>            : 
<span class="lineNum">    2104 </span>            : /* Asynchronously close a client if soft or hard limit is reached on the
<span class="lineNum">    2105 </span>            :  * output buffer size. The caller can check if the client will be closed
<span class="lineNum">    2106 </span>            :  * checking if the client CLIENT_CLOSE_ASAP flag is set.
<span class="lineNum">    2107 </span>            :  *
<span class="lineNum">    2108 </span>            :  * Note: we need to close the client asynchronously because this function is
<a name="2109"><span class="lineNum">    2109 </span>            :  * called from contexts where the client can't be freed safely, i.e. from the</a>
<span class="lineNum">    2110 </span>            :  * lower level functions pushing data inside the client output buffers. */
<span class="lineNum">    2111 </span><span class="lineCov">  104924468 : void asyncCloseClientOnOutputBufferLimitReached(client *c) {</span>
<span class="lineNum">    2112 </span><span class="lineCov">  104924468 :     if (c-&gt;fd == -1) return; /* It is unsafe to free fake clients. */</span>
<span class="lineNum">    2113 </span><span class="lineCov">  104924176 :     serverAssert(c-&gt;reply_bytes &lt; SIZE_MAX-(1024*64));</span>
<span class="lineNum">    2114 </span><span class="lineCov">  104924176 :     if (c-&gt;reply_bytes == 0 || c-&gt;flags &amp; CLIENT_CLOSE_ASAP) return;</span>
<span class="lineNum">    2115 </span><span class="lineCov">  104885936 :     if (checkClientOutputBufferLimits(c)) {</span>
<span class="lineNum">    2116 </span><span class="lineCov">          4 :         sds client = catClientInfoString(sdsempty(),c);</span>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span><span class="lineCov">          4 :         freeClientAsync(c);</span>
<span class="lineNum">    2119 </span><span class="lineCov">          4 :         serverLog(LL_WARNING,&quot;Client %s scheduled to be closed ASAP for overcoming of output buffer limits.&quot;, client);</span>
<span class="lineNum">    2120 </span><span class="lineCov">          4 :         sdsfree(client);</span>
<span class="lineNum">    2121 </span>            :     }
<span class="lineNum">    2122 </span>            : }
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span>            : /* Helper function used by freeMemoryIfNeeded() in order to flush slaves
<span class="lineNum">    2125 </span>            :  * output buffers without returning control to the event loop.
<a name="2126"><span class="lineNum">    2126 </span>            :  * This is also called by SHUTDOWN for a best-effort attempt to send</a>
<span class="lineNum">    2127 </span>            :  * slaves the latest writes. */
<span class="lineNum">    2128 </span><span class="lineCov">        411 : void flushSlavesOutputBuffers(void) {</span>
<span class="lineNum">    2129 </span><span class="lineCov">        411 :     listIter li;</span>
<span class="lineNum">    2130 </span><span class="lineCov">        411 :     listNode *ln;</span>
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span><span class="lineCov">        411 :     listRewind(server.slaves,&amp;li);</span>
<span class="lineNum">    2133 </span><span class="lineCov">        439 :     while((ln = listNext(&amp;li))) {</span>
<span class="lineNum">    2134 </span><span class="lineCov">         28 :         client *slave = listNodeValue(ln);</span>
<span class="lineNum">    2135 </span><span class="lineCov">         28 :         int events;</span>
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            :         /* Note that the following will not flush output buffers of slaves
<span class="lineNum">    2138 </span>            :          * in STATE_ONLINE but having put_online_on_ack set to true: in this
<span class="lineNum">    2139 </span>            :          * case the writable event is never installed, since the purpose
<span class="lineNum">    2140 </span>            :          * of put_online_on_ack is to postpone the moment it is installed.
<span class="lineNum">    2141 </span>            :          * This is what we want since slaves in this state should not receive
<span class="lineNum">    2142 </span>            :          * writes before the first ACK. */
<span class="lineNum">    2143 </span><span class="lineCov">         28 :         events = aeGetFileEvents(server.el,slave-&gt;fd);</span>
<span class="lineNum">    2144 </span><span class="lineCov">         28 :         if (events &amp; AE_WRITABLE &amp;&amp;</span>
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :             slave-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp;</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :             clientHasPendingReplies(slave))</span>
<span class="lineNum">    2147 </span>            :         {
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :             writeToClient(slave-&gt;fd,slave,0);</span>
<span class="lineNum">    2149 </span>            :         }
<span class="lineNum">    2150 </span>            :     }
<span class="lineNum">    2151 </span><span class="lineCov">        411 : }</span>
<span class="lineNum">    2152 </span>            : 
<span class="lineNum">    2153 </span>            : /* Pause clients up to the specified unixtime (in ms). While clients
<span class="lineNum">    2154 </span>            :  * are paused no command is processed from clients, so the data set can't
<span class="lineNum">    2155 </span>            :  * change during that time.
<span class="lineNum">    2156 </span>            :  *
<span class="lineNum">    2157 </span>            :  * However while this function pauses normal and Pub/Sub clients, slaves are
<span class="lineNum">    2158 </span>            :  * still served, so this function can be used on server upgrades where it is
<span class="lineNum">    2159 </span>            :  * required that slaves process the latest bytes from the replication stream
<span class="lineNum">    2160 </span>            :  * before being turned to masters.
<span class="lineNum">    2161 </span>            :  *
<span class="lineNum">    2162 </span>            :  * This function is also internally used by Redis Cluster for the manual
<span class="lineNum">    2163 </span>            :  * failover procedure implemented by CLUSTER FAILOVER.
<span class="lineNum">    2164 </span>            :  *
<span class="lineNum">    2165 </span>            :  * The function always succeed, even if there is already a pause in progress.
<span class="lineNum">    2166 </span>            :  * In such a case, the pause is extended if the duration is more than the
<span class="lineNum">    2167 </span>            :  * time left for the previous duration. However if the duration is smaller
<a name="2168"><span class="lineNum">    2168 </span>            :  * than the time left for the previous pause, no change is made to the</a>
<span class="lineNum">    2169 </span>            :  * left duration. */
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 : void pauseClients(mstime_t end) {</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :     if (!server.clients_paused || end &gt; server.clients_pause_end_time)</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         server.clients_pause_end_time = end;</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :     server.clients_paused = 1;</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2175 </span>            : 
<a name="2176"><span class="lineNum">    2176 </span>            : /* Return non-zero if clients are currently paused. As a side effect the</a>
<span class="lineNum">    2177 </span>            :  * function checks if the pause time was reached and clear it. */
<span class="lineNum">    2178 </span><span class="lineCov">   75419155 : int clientsArePaused(void) {</span>
<span class="lineNum">    2179 </span><span class="lineCov">   75419155 :     if (server.clients_paused &amp;&amp;</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :         server.clients_pause_end_time &lt; server.mstime)</span>
<span class="lineNum">    2181 </span>            :     {
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :         listNode *ln;</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :         listIter li;</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :         client *c;</span>
<span class="lineNum">    2185 </span>            : 
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :         server.clients_paused = 0;</span>
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            :         /* Put all the clients in the unblocked clients queue in order to
<span class="lineNum">    2189 </span>            :          * force the re-processing of the input buffer if any. */
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :         listRewind(server.clients,&amp;li);</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :         while ((ln = listNext(&amp;li)) != NULL) {</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :             c = listNodeValue(ln);</span>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            :             /* Don't touch slaves and blocked clients.
<span class="lineNum">    2195 </span>            :              * The latter pending requests will be processed when unblocked. */
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :             if (c-&gt;flags &amp; (CLIENT_SLAVE|CLIENT_BLOCKED)) continue;</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :             queueClientForReprocessing(c);</span>
<span class="lineNum">    2198 </span>            :         }
<span class="lineNum">    2199 </span>            :     }
<span class="lineNum">    2200 </span><span class="lineCov">   75419155 :     return server.clients_paused;</span>
<span class="lineNum">    2201 </span>            : }
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            : /* This function is called by Redis in order to process a few events from
<span class="lineNum">    2204 </span>            :  * time to time while blocked into some not interruptible operation.
<span class="lineNum">    2205 </span>            :  * This allows to reply to clients with the -LOADING error while loading the
<span class="lineNum">    2206 </span>            :  * data set at startup or after a full resynchronization with the master
<span class="lineNum">    2207 </span>            :  * and so forth.
<span class="lineNum">    2208 </span>            :  *
<span class="lineNum">    2209 </span>            :  * It calls the event loop in order to process a few events. Specifically we
<span class="lineNum">    2210 </span>            :  * try to call the event loop 4 times as long as we receive acknowledge that
<span class="lineNum">    2211 </span>            :  * some event was processed, in order to go forward with the accept, read,
<span class="lineNum">    2212 </span>            :  * write, close sequence needed to serve a client.
<a name="2213"><span class="lineNum">    2213 </span>            :  *</a>
<span class="lineNum">    2214 </span>            :  * The function returns the total number of events processed. */
<span class="lineNum">    2215 </span><span class="lineCov">      96236 : int processEventsWhileBlocked(void) {</span>
<span class="lineNum">    2216 </span><span class="lineCov">      96236 :     int iterations = 4; /* See the function top-comment. */</span>
<span class="lineNum">    2217 </span><span class="lineCov">      96236 :     int count = 0;</span>
<span class="lineNum">    2218 </span><span class="lineCov">      96847 :     while (iterations--) {</span>
<span class="lineNum">    2219 </span><span class="lineCov">      96845 :         int events = 0;</span>
<span class="lineNum">    2220 </span><span class="lineCov">      96845 :         events += aeProcessEvents(server.el, AE_FILE_EVENTS|AE_DONT_WAIT);</span>
<span class="lineNum">    2221 </span><span class="lineCov">      96843 :         events += handleClientsWithPendingWrites();</span>
<span class="lineNum">    2222 </span><span class="lineCov">      96843 :         if (!events) break;</span>
<span class="lineNum">    2223 </span><span class="lineCov">        611 :         count += events;</span>
<span class="lineNum">    2224 </span>            :     }
<span class="lineNum">    2225 </span><span class="lineCov">      96234 :     return count;</span>
<span class="lineNum">    2226 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
