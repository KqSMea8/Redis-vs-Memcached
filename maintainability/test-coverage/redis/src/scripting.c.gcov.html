<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - redis.info - src/scripting.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - scripting.c<span style="font-size: 80%;"> (source / <a href="scripting.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">redis.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">623</td>
            <td class="headerCovTableEntry">1323</td>
            <td class="headerCovTableEntryLo">47.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-11-29 23:16:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">35</td>
            <td class="headerCovTableEntry">77</td>
            <td class="headerCovTableEntryLo">45.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
<span class="lineNum">       3 </span>            :  * All rights reserved.
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *   * Redistributions of source code must retain the above copyright notice,
<span class="lineNum">       9 </span>            :  *     this list of conditions and the following disclaimer.
<span class="lineNum">      10 </span>            :  *   * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      11 </span>            :  *     notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      12 </span>            :  *     documentation and/or other materials provided with the distribution.
<span class="lineNum">      13 </span>            :  *   * Neither the name of Redis nor the names of its contributors may be used
<span class="lineNum">      14 </span>            :  *     to endorse or promote products derived from this software without
<span class="lineNum">      15 </span>            :  *     specific prior written permission.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      18 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      19 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      20 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      21 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      22 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      23 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      24 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      25 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      26 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      27 </span>            :  * POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      28 </span>            :  */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;server.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;sha1.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;rand.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;cluster.h&quot;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : #include &lt;lua.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;lauxlib.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;lualib.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : char *redisProtocolToLuaType_Int(lua_State *lua, char *reply);
<span class="lineNum">      42 </span>            : char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);
<span class="lineNum">      43 </span>            : char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);
<span class="lineNum">      44 </span>            : char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);
<span class="lineNum">      45 </span>            : char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);
<span class="lineNum">      46 </span>            : int redis_math_random (lua_State *L);
<span class="lineNum">      47 </span>            : int redis_math_randomseed (lua_State *L);
<span class="lineNum">      48 </span>            : void ldbInit(void);
<span class="lineNum">      49 </span>            : void ldbDisable(client *c);
<span class="lineNum">      50 </span>            : void ldbEnable(client *c);
<span class="lineNum">      51 </span>            : void evalGenericCommandWithDebugging(client *c, int evalsha);
<span class="lineNum">      52 </span>            : void luaLdbLineHook(lua_State *lua, lua_Debug *ar);
<span class="lineNum">      53 </span>            : void ldbLog(sds entry);
<span class="lineNum">      54 </span>            : void ldbLogRedisReply(char *reply);
<span class="lineNum">      55 </span>            : sds ldbCatStackValue(sds s, lua_State *lua, int idx);
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /* Debugger shared state is stored inside this global structure. */
<span class="lineNum">      58 </span>            : #define LDB_BREAKPOINTS_MAX 64  /* Max number of breakpoints. */
<span class="lineNum">      59 </span>            : #define LDB_MAX_LEN_DEFAULT 256 /* Default len limit for replies / var dumps. */
<span class="lineNum">      60 </span>            : struct ldbState {
<span class="lineNum">      61 </span>            :     int fd;     /* Socket of the debugging client. */
<span class="lineNum">      62 </span>            :     int active; /* Are we debugging EVAL right now? */
<span class="lineNum">      63 </span>            :     int forked; /* Is this a fork()ed debugging session? */
<span class="lineNum">      64 </span>            :     list *logs; /* List of messages to send to the client. */
<span class="lineNum">      65 </span>            :     list *traces; /* Messages about Redis commands executed since last stop.*/
<span class="lineNum">      66 </span>            :     list *children; /* All forked debugging sessions pids. */
<span class="lineNum">      67 </span>            :     int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */
<span class="lineNum">      68 </span>            :     int bpcount; /* Number of valid entries inside bp. */
<span class="lineNum">      69 </span>            :     int step;   /* Stop at next line ragardless of breakpoints. */
<span class="lineNum">      70 </span>            :     int luabp;  /* Stop at next line because redis.breakpoint() was called. */
<span class="lineNum">      71 </span>            :     sds *src;   /* Lua script source code split by line. */
<span class="lineNum">      72 </span>            :     int lines;  /* Number of lines in 'src'. */
<span class="lineNum">      73 </span>            :     int currentline;    /* Current line number. */
<span class="lineNum">      74 </span>            :     sds cbuf;   /* Debugger client command buffer. */
<span class="lineNum">      75 </span>            :     size_t maxlen;  /* Max var dump / reply length. */
<span class="lineNum">      76 </span>            :     int maxlen_hint_sent; /* Did we already hint about &quot;set maxlen&quot;? */
<span class="lineNum">      77 </span>            : } ldb;
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">      80 </span>            :  * Utility functions.
<span class="lineNum">      81 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /* Perform the SHA1 of the input string. We use this both for hashing script
<span class="lineNum">      84 </span>            :  * bodies in order to obtain the Lua function name, and in the implementation
<span class="lineNum">      85 </span>            :  * of redis.sha1().
<span class="lineNum">      86 </span>            :  *
<a name="87"><span class="lineNum">      87 </span>            :  * 'digest' should point to a 41 bytes buffer: 40 for SHA1 converted into an</a>
<span class="lineNum">      88 </span>            :  * hexadecimal number, plus 1 byte for null term. */
<span class="lineNum">      89 </span><span class="lineCov">     910577 : void sha1hex(char *digest, char *script, size_t len) {</span>
<span class="lineNum">      90 </span><span class="lineCov">     910577 :     SHA1_CTX ctx;</span>
<span class="lineNum">      91 </span><span class="lineCov">     910577 :     unsigned char hash[20];</span>
<span class="lineNum">      92 </span><span class="lineCov">     910577 :     char *cset = &quot;0123456789abcdef&quot;;</span>
<span class="lineNum">      93 </span><span class="lineCov">     910577 :     int j;</span>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineCov">     910577 :     SHA1Init(&amp;ctx);</span>
<span class="lineNum">      96 </span><span class="lineCov">     910577 :     SHA1Update(&amp;ctx,(unsigned char*)script,len);</span>
<span class="lineNum">      97 </span><span class="lineCov">     910577 :     SHA1Final(hash,&amp;ctx);</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">   19122117 :     for (j = 0; j &lt; 20; j++) {</span>
<span class="lineNum">     100 </span><span class="lineCov">   18211540 :         digest[j*2] = cset[((hash[j]&amp;0xF0)&gt;&gt;4)];</span>
<span class="lineNum">     101 </span><span class="lineCov">   18211540 :         digest[j*2+1] = cset[(hash[j]&amp;0xF)];</span>
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span><span class="lineCov">     910577 :     digest[40] = '\0';</span>
<span class="lineNum">     104 </span><span class="lineCov">     910577 : }</span>
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">     107 </span>            :  * Redis reply to Lua type conversion functions.
<span class="lineNum">     108 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : /* Take a Redis reply in the Redis protocol format and convert it into a
<span class="lineNum">     111 </span>            :  * Lua type. Thanks to this function, and the introduction of not connected
<span class="lineNum">     112 </span>            :  * clients, it is trivial to implement the redis() lua function.
<span class="lineNum">     113 </span>            :  *
<span class="lineNum">     114 </span>            :  * Basically we take the arguments, execute the Redis command in the context
<span class="lineNum">     115 </span>            :  * of a non connected client, then take the generated reply and convert it
<span class="lineNum">     116 </span>            :  * into a suitable Lua type. With this trick the scripting feature does not
<span class="lineNum">     117 </span>            :  * need the introduction of a full Redis internals API. The script
<span class="lineNum">     118 </span>            :  * is like a normal client that bypasses all the slow I/O paths.
<span class="lineNum">     119 </span>            :  *
<span class="lineNum">     120 </span>            :  * Note: in this function we do not do any sanity check as the reply is
<span class="lineNum">     121 </span>            :  * generated by Redis directly. This allows us to go faster.
<span class="lineNum">     122 </span>            :  *
<span class="lineNum">     123 </span>            :  * Errors are returned as a table with a single 'err' field set to the
<span class="lineNum">     124 </span>            :  * error string.
<a name="125"><span class="lineNum">     125 </span>            :  */</a>
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span><span class="lineCov">     690983 : char *redisProtocolToLuaType(lua_State *lua, char* reply) {</span>
<span class="lineNum">     128 </span><span class="lineCov">     690983 :     char *p = reply;</span>
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span><span class="lineCov">     690983 :     switch(*p) {</span>
<span class="lineNum">     131 </span><span class="lineCov">     490123 :     case ':': p = redisProtocolToLuaType_Int(lua,reply); break;</span>
<span class="lineNum">     132 </span><span class="lineCov">        700 :     case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;</span>
<span class="lineNum">     133 </span><span class="lineCov">     200078 :     case '+': p = redisProtocolToLuaType_Status(lua,reply); break;</span>
<span class="lineNum">     134 </span><span class="lineCov">          8 :     case '-': p = redisProtocolToLuaType_Error(lua,reply); break;</span>
<span class="lineNum">     135 </span><span class="lineCov">         74 :     case '*': p = redisProtocolToLuaType_MultiBulk(lua,reply); break;</span>
<span class="lineNum">     136 </span>            :     }
<span class="lineNum">     137 </span><span class="lineCov">     690983 :     return p;</span>
<a name="138"><span class="lineNum">     138 </span>            : }</a>
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">     490123 : char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {</span>
<span class="lineNum">     141 </span><span class="lineCov">     490123 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">     142 </span><span class="lineCov">     490123 :     long long value;</span>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">     490123 :     string2ll(reply+1,p-reply-1,&amp;value);</span>
<span class="lineNum">     145 </span><span class="lineCov">     490123 :     lua_pushnumber(lua,(lua_Number)value);</span>
<span class="lineNum">     146 </span><span class="lineCov">     490123 :     return p+2;</span>
<a name="147"><span class="lineNum">     147 </span>            : }</a>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineCov">        700 : char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {</span>
<span class="lineNum">     150 </span><span class="lineCov">        700 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">     151 </span><span class="lineCov">        700 :     long long bulklen;</span>
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span><span class="lineCov">        700 :     string2ll(reply+1,p-reply-1,&amp;bulklen);</span>
<span class="lineNum">     154 </span><span class="lineCov">        700 :     if (bulklen == -1) {</span>
<span class="lineNum">     155 </span><span class="lineCov">         60 :         lua_pushboolean(lua,0);</span>
<span class="lineNum">     156 </span><span class="lineCov">         60 :         return p+2;</span>
<span class="lineNum">     157 </span>            :     } else {
<span class="lineNum">     158 </span><span class="lineCov">        640 :         lua_pushlstring(lua,p+2,bulklen);</span>
<span class="lineNum">     159 </span><span class="lineCov">        640 :         return p+2+bulklen+2;</span>
<span class="lineNum">     160 </span>            :     }
<a name="161"><span class="lineNum">     161 </span>            : }</a>
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">     200078 : char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {</span>
<span class="lineNum">     164 </span><span class="lineCov">     200078 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineCov">     200078 :     lua_newtable(lua);</span>
<span class="lineNum">     167 </span><span class="lineCov">     200078 :     lua_pushstring(lua,&quot;ok&quot;);</span>
<span class="lineNum">     168 </span><span class="lineCov">     200078 :     lua_pushlstring(lua,reply+1,p-reply-1);</span>
<span class="lineNum">     169 </span><span class="lineCov">     200078 :     lua_settable(lua,-3);</span>
<span class="lineNum">     170 </span><span class="lineCov">     200078 :     return p+2;</span>
<a name="171"><span class="lineNum">     171 </span>            : }</a>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineCov">          8 : char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {</span>
<span class="lineNum">     174 </span><span class="lineCov">          8 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">          8 :     lua_newtable(lua);</span>
<span class="lineNum">     177 </span><span class="lineCov">          8 :     lua_pushstring(lua,&quot;err&quot;);</span>
<span class="lineNum">     178 </span><span class="lineCov">          8 :     lua_pushlstring(lua,reply+1,p-reply-1);</span>
<span class="lineNum">     179 </span><span class="lineCov">          8 :     lua_settable(lua,-3);</span>
<span class="lineNum">     180 </span><span class="lineCov">          8 :     return p+2;</span>
<a name="181"><span class="lineNum">     181 </span>            : }</a>
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span><span class="lineCov">         74 : char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {</span>
<span class="lineNum">     184 </span><span class="lineCov">         74 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">     185 </span><span class="lineCov">         74 :     long long mbulklen;</span>
<span class="lineNum">     186 </span><span class="lineCov">         74 :     int j = 0;</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span><span class="lineCov">         74 :     string2ll(reply+1,p-reply-1,&amp;mbulklen);</span>
<span class="lineNum">     189 </span><span class="lineCov">         74 :     p += 2;</span>
<span class="lineNum">     190 </span><span class="lineCov">         74 :     if (mbulklen == -1) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         lua_pushboolean(lua,0);</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :         return p;</span>
<span class="lineNum">     193 </span>            :     }
<span class="lineNum">     194 </span><span class="lineCov">         74 :     lua_newtable(lua);</span>
<span class="lineNum">     195 </span><span class="lineCov">        688 :     for (j = 0; j &lt; mbulklen; j++) {</span>
<span class="lineNum">     196 </span><span class="lineCov">        614 :         lua_pushnumber(lua,j+1);</span>
<span class="lineNum">     197 </span><span class="lineCov">        614 :         p = redisProtocolToLuaType(lua,p);</span>
<span class="lineNum">     198 </span><span class="lineCov">        614 :         lua_settable(lua,-3);</span>
<span class="lineNum">     199 </span>            :     }
<span class="lineNum">     200 </span>            :     return p;
<span class="lineNum">     201 </span>            : }
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : /* This function is used in order to push an error on the Lua stack in the
<span class="lineNum">     204 </span>            :  * format used by redis.pcall to return errors, which is a lua table
<span class="lineNum">     205 </span>            :  * with a single &quot;err&quot; field set to the error string. Note that this
<a name="206"><span class="lineNum">     206 </span>            :  * table is never a valid reply by proper commands, since the returned</a>
<span class="lineNum">     207 </span>            :  * tables are otherwise always indexed by integers, never by strings. */
<span class="lineNum">     208 </span><span class="lineCov">         32 : void luaPushError(lua_State *lua, char *error) {</span>
<span class="lineNum">     209 </span><span class="lineCov">         32 :     lua_Debug dbg;</span>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :     /* If debugging is active and in step mode, log errors resulting from
<span class="lineNum">     212 </span>            :      * Redis commands. */
<span class="lineNum">     213 </span><span class="lineCov">         32 :     if (ldb.active &amp;&amp; ldb.step) {</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         ldbLog(sdscatprintf(sdsempty(),&quot;&lt;error&gt; %s&quot;,error));</span>
<span class="lineNum">     215 </span>            :     }
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">         32 :     lua_newtable(lua);</span>
<span class="lineNum">     218 </span><span class="lineCov">         32 :     lua_pushstring(lua,&quot;err&quot;);</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :     /* Attempt to figure out where this function was called, if possible */
<span class="lineNum">     221 </span><span class="lineCov">         64 :     if(lua_getstack(lua, 1, &amp;dbg) &amp;&amp; lua_getinfo(lua, &quot;nSl&quot;, &amp;dbg)) {</span>
<span class="lineNum">     222 </span><span class="lineCov">         32 :         sds msg = sdscatprintf(sdsempty(), &quot;%s: %d: %s&quot;,</span>
<span class="lineNum">     223 </span>            :             dbg.source, dbg.currentline, error);
<span class="lineNum">     224 </span><span class="lineCov">         32 :         lua_pushstring(lua, msg);</span>
<span class="lineNum">     225 </span><span class="lineCov">         32 :         sdsfree(msg);</span>
<span class="lineNum">     226 </span>            :     } else {
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :         lua_pushstring(lua, error);</span>
<span class="lineNum">     228 </span>            :     }
<span class="lineNum">     229 </span><span class="lineCov">         32 :     lua_settable(lua,-3);</span>
<span class="lineNum">     230 </span><span class="lineCov">         32 : }</span>
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : /* In case the error set into the Lua stack by luaPushError() was generated
<span class="lineNum">     233 </span>            :  * by the non-error-trapping version of redis.pcall(), which is redis.call(),
<a name="234"><span class="lineNum">     234 </span>            :  * this function will raise the Lua error so that the execution of the</a>
<span class="lineNum">     235 </span>            :  * script will be halted. */
<span class="lineNum">     236 </span><span class="lineCov">         28 : int luaRaiseError(lua_State *lua) {</span>
<span class="lineNum">     237 </span><span class="lineCov">         28 :     lua_pushstring(lua,&quot;err&quot;);</span>
<span class="lineNum">     238 </span><span class="lineCov">         28 :     lua_gettable(lua,-2);</span>
<span class="lineNum">     239 </span><span class="lineCov">         28 :     return lua_error(lua);</span>
<span class="lineNum">     240 </span>            : }
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : /* Sort the array currently in the stack. We do this to make the output
<span class="lineNum">     243 </span>            :  * of commands like KEYS or SMEMBERS something deterministic when called
<span class="lineNum">     244 </span>            :  * from Lua (to play well with AOf/replication).
<span class="lineNum">     245 </span>            :  *
<a name="246"><span class="lineNum">     246 </span>            :  * The array is sorted using table.sort itself, and assuming all the</a>
<span class="lineNum">     247 </span>            :  * list elements are strings. */
<span class="lineNum">     248 </span><span class="lineCov">          4 : void luaSortArray(lua_State *lua) {</span>
<span class="lineNum">     249 </span>            :     /* Initial Stack: array */
<span class="lineNum">     250 </span><span class="lineCov">          4 :     lua_getglobal(lua,&quot;table&quot;);</span>
<span class="lineNum">     251 </span><span class="lineCov">          4 :     lua_pushstring(lua,&quot;sort&quot;);</span>
<span class="lineNum">     252 </span><span class="lineCov">          4 :     lua_gettable(lua,-2);       /* Stack: array, table, table.sort */</span>
<span class="lineNum">     253 </span><span class="lineCov">          4 :     lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */</span>
<span class="lineNum">     254 </span><span class="lineCov">          4 :     if (lua_pcall(lua,1,0,0)) {</span>
<span class="lineNum">     255 </span>            :         /* Stack: array, table, error */
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            :         /* We are not interested in the error, we assume that the problem is
<span class="lineNum">     258 </span>            :          * that there are 'false' elements inside the array, so we try
<span class="lineNum">     259 </span>            :          * again with a slower function but able to handle this case, that
<span class="lineNum">     260 </span>            :          * is: table.sort(table, __redis__compare_helper) */
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);             /* Stack: array, table */</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :         lua_pushstring(lua,&quot;sort&quot;); /* Stack: array, table, sort */</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         lua_gettable(lua,-2);       /* Stack: array, table, table.sort */</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :         lua_pushvalue(lua,-3);      /* Stack: array, table, table.sort, array */</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         lua_getglobal(lua,&quot;__redis__compare_helper&quot;);</span>
<span class="lineNum">     266 </span>            :         /* Stack: array, table, table.sort, array, __redis__compare_helper */
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         lua_call(lua,2,0);</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span>            :     /* Stack: array (sorted), table */
<span class="lineNum">     270 </span><span class="lineCov">          4 :     lua_pop(lua,1);             /* Stack: array (sorted) */</span>
<span class="lineNum">     271 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">     274 </span>            :  * Lua reply to Redis reply conversion functions.
<a name="275"><span class="lineNum">     275 </span>            :  * ------------------------------------------------------------------------- */</a>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">     640890 : void luaReplyToRedisReply(client *c, lua_State *lua) {</span>
<span class="lineNum">     278 </span><span class="lineCov">     640890 :     int t = lua_type(lua,-1);</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">     640890 :     switch(t) {</span>
<span class="lineNum">     281 </span><span class="lineCov">     150627 :     case LUA_TSTRING:</span>
<span class="lineNum">     282 </span><span class="lineCov">     150627 :         addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));</span>
<span class="lineNum">     283 </span><span class="lineCov">     150627 :         break;</span>
<span class="lineNum">     284 </span><span class="lineCov">         36 :     case LUA_TBOOLEAN:</span>
<span class="lineNum">     285 </span><span class="lineCov">         36 :         addReply(c,lua_toboolean(lua,-1) ? shared.cone : shared.nullbulk);</span>
<span class="lineNum">     286 </span><span class="lineCov">         36 :         break;</span>
<span class="lineNum">     287 </span><span class="lineCov">     490085 :     case LUA_TNUMBER:</span>
<span class="lineNum">     288 </span><span class="lineCov">     490085 :         addReplyLongLong(c,(long long)lua_tonumber(lua,-1));</span>
<span class="lineNum">     289 </span><span class="lineCov">     490085 :         break;</span>
<span class="lineNum">     290 </span><span class="lineCov">         91 :     case LUA_TTABLE:</span>
<span class="lineNum">     291 </span>            :         /* We need to check if it is an array, an error, or a status reply.
<span class="lineNum">     292 </span>            :          * Error are returned as a single element table with 'err' field.
<span class="lineNum">     293 </span>            :          * Status replies are returned as single element table with 'ok'
<span class="lineNum">     294 </span>            :          * field. */
<span class="lineNum">     295 </span><span class="lineCov">         91 :         lua_pushstring(lua,&quot;err&quot;);</span>
<span class="lineNum">     296 </span><span class="lineCov">         91 :         lua_gettable(lua,-2);</span>
<span class="lineNum">     297 </span><span class="lineCov">         91 :         t = lua_type(lua,-1);</span>
<span class="lineNum">     298 </span><span class="lineCov">         91 :         if (t == LUA_TSTRING) {</span>
<span class="lineNum">     299 </span><span class="lineCov">         12 :             sds err = sdsnew(lua_tostring(lua,-1));</span>
<span class="lineNum">     300 </span><span class="lineCov">         12 :             sdsmapchars(err,&quot;\r\n&quot;,&quot;  &quot;,2);</span>
<span class="lineNum">     301 </span><span class="lineCov">         12 :             addReplySds(c,sdscatprintf(sdsempty(),&quot;-%s\r\n&quot;,err));</span>
<span class="lineNum">     302 </span><span class="lineCov">         12 :             sdsfree(err);</span>
<span class="lineNum">     303 </span><span class="lineCov">         12 :             lua_pop(lua,2);</span>
<span class="lineNum">     304 </span><span class="lineCov">         12 :             return;</span>
<span class="lineNum">     305 </span>            :         }
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span><span class="lineCov">         79 :         lua_pop(lua,1);</span>
<span class="lineNum">     308 </span><span class="lineCov">         79 :         lua_pushstring(lua,&quot;ok&quot;);</span>
<span class="lineNum">     309 </span><span class="lineCov">         79 :         lua_gettable(lua,-2);</span>
<span class="lineNum">     310 </span><span class="lineCov">         79 :         t = lua_type(lua,-1);</span>
<span class="lineNum">     311 </span><span class="lineCov">         79 :         if (t == LUA_TSTRING) {</span>
<span class="lineNum">     312 </span><span class="lineCov">          8 :             sds ok = sdsnew(lua_tostring(lua,-1));</span>
<span class="lineNum">     313 </span><span class="lineCov">          8 :             sdsmapchars(ok,&quot;\r\n&quot;,&quot;  &quot;,2);</span>
<span class="lineNum">     314 </span><span class="lineCov">          8 :             addReplySds(c,sdscatprintf(sdsempty(),&quot;+%s\r\n&quot;,ok));</span>
<span class="lineNum">     315 </span><span class="lineCov">          8 :             sdsfree(ok);</span>
<span class="lineNum">     316 </span><span class="lineCov">          8 :             lua_pop(lua,1);</span>
<span class="lineNum">     317 </span>            :         } else {
<span class="lineNum">     318 </span><span class="lineCov">         71 :             void *replylen = addDeferredMultiBulkLength(c);</span>
<span class="lineNum">     319 </span><span class="lineCov">         71 :             int j = 1, mbulklen = 0;</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineCov">         71 :             lua_pop(lua,1); /* Discard the 'ok' field value we popped */</span>
<span class="lineNum">     322 </span><span class="lineCov">        667 :             while(1) {</span>
<span class="lineNum">     323 </span><span class="lineCov">        667 :                 lua_pushnumber(lua,j++);</span>
<span class="lineNum">     324 </span><span class="lineCov">        667 :                 lua_gettable(lua,-2);</span>
<span class="lineNum">     325 </span><span class="lineCov">        667 :                 t = lua_type(lua,-1);</span>
<span class="lineNum">     326 </span><span class="lineCov">        667 :                 if (t == LUA_TNIL) {</span>
<span class="lineNum">     327 </span><span class="lineCov">         71 :                     lua_pop(lua,1);</span>
<span class="lineNum">     328 </span><span class="lineCov">         71 :                     break;</span>
<span class="lineNum">     329 </span>            :                 }
<span class="lineNum">     330 </span><span class="lineCov">        596 :                 luaReplyToRedisReply(c, lua);</span>
<span class="lineNum">     331 </span><span class="lineCov">        596 :                 mbulklen++;</span>
<span class="lineNum">     332 </span>            :             }
<span class="lineNum">     333 </span><span class="lineCov">         71 :             setDeferredMultiBulkLength(c,replylen,mbulklen);</span>
<span class="lineNum">     334 </span>            :         }
<span class="lineNum">     335 </span>            :         break;
<span class="lineNum">     336 </span><span class="lineCov">         51 :     default:</span>
<span class="lineNum">     337 </span><span class="lineCov">         51 :         addReply(c,shared.nullbulk);</span>
<span class="lineNum">     338 </span>            :     }
<span class="lineNum">     339 </span><span class="lineCov">     640878 :     lua_pop(lua,1);</span>
<span class="lineNum">     340 </span>            : }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">     343 </span>            :  * Lua redis.* functions implementations.
<span class="lineNum">     344 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">     345 </span>            : 
<a name="346"><span class="lineNum">     346 </span>            : #define LUA_CMD_OBJCACHE_SIZE 32</a>
<span class="lineNum">     347 </span>            : #define LUA_CMD_OBJCACHE_MAX_LEN 64
<span class="lineNum">     348 </span><span class="lineCov">     690401 : int luaRedisGenericCommand(lua_State *lua, int raise_error) {</span>
<span class="lineNum">     349 </span><span class="lineCov">     690401 :     int j, argc = lua_gettop(lua);</span>
<span class="lineNum">     350 </span><span class="lineCov">     690401 :     struct redisCommand *cmd;</span>
<span class="lineNum">     351 </span><span class="lineCov">     690401 :     client *c = server.lua_client;</span>
<span class="lineNum">     352 </span><span class="lineCov">     690401 :     sds reply;</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            :     /* Cached across calls. */
<span class="lineNum">     355 </span><span class="lineCov">     690401 :     static robj **argv = NULL;</span>
<span class="lineNum">     356 </span><span class="lineCov">     690401 :     static int argv_size = 0;</span>
<span class="lineNum">     357 </span><span class="lineCov">     690401 :     static robj *cached_objects[LUA_CMD_OBJCACHE_SIZE];</span>
<span class="lineNum">     358 </span><span class="lineCov">     690401 :     static size_t cached_objects_len[LUA_CMD_OBJCACHE_SIZE];</span>
<span class="lineNum">     359 </span><span class="lineCov">     690401 :     static int inuse = 0;   /* Recursive calls detection. */</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            :     /* Reflect MULTI state */
<span class="lineNum">     362 </span><span class="lineCov">     690401 :     if (server.lua_multi_emitted || (server.lua_caller-&gt;flags &amp; CLIENT_MULTI)) {</span>
<span class="lineNum">     363 </span><span class="lineCov">        177 :         c-&gt;flags |= CLIENT_MULTI;</span>
<span class="lineNum">     364 </span>            :     } else {
<span class="lineNum">     365 </span><span class="lineCov">     690224 :         c-&gt;flags &amp;= ~CLIENT_MULTI;</span>
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :     /* By using Lua debug hooks it is possible to trigger a recursive call
<span class="lineNum">     369 </span>            :      * to luaRedisGenericCommand(), which normally should never happen.
<span class="lineNum">     370 </span>            :      * To make this function reentrant is futile and makes it slower, but
<span class="lineNum">     371 </span>            :      * we should at least detect such a misuse, and abort. */
<span class="lineNum">     372 </span><span class="lineCov">     690401 :     if (inuse) {</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         char *recursion_warning =</span>
<span class="lineNum">     374 </span>            :             &quot;luaRedisGenericCommand() recursive call detected. &quot;
<span class="lineNum">     375 </span>            :             &quot;Are you doing funny stuff with Lua debug hooks?&quot;;
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;%s&quot;,recursion_warning);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         luaPushError(lua,recursion_warning);</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span><span class="lineCov">     690401 :     inuse++;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            :     /* Require at least one argument */
<span class="lineNum">     383 </span><span class="lineCov">     690401 :     if (argc == 0) {</span>
<span class="lineNum">     384 </span><span class="lineCov">          4 :         luaPushError(lua,</span>
<span class="lineNum">     385 </span>            :             &quot;Please specify at least one argument for redis.call()&quot;);
<span class="lineNum">     386 </span><span class="lineCov">          4 :         inuse--;</span>
<span class="lineNum">     387 </span><span class="lineCov">          4 :         return raise_error ? luaRaiseError(lua) : 1;</span>
<span class="lineNum">     388 </span>            :     }
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :     /* Build the arguments vector */
<span class="lineNum">     391 </span><span class="lineCov">     690397 :     if (argv_size &lt; argc) {</span>
<span class="lineNum">     392 </span><span class="lineCov">         97 :         argv = zrealloc(argv,sizeof(robj*)*argc);</span>
<span class="lineNum">     393 </span><span class="lineCov">         97 :         argv_size = argc;</span>
<span class="lineNum">     394 </span>            :     }
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">    1871639 :     for (j = 0; j &lt; argc; j++) {</span>
<span class="lineNum">     397 </span><span class="lineCov">    1181242 :         char *obj_s;</span>
<span class="lineNum">     398 </span><span class="lineCov">    1181242 :         size_t obj_len;</span>
<span class="lineNum">     399 </span><span class="lineCov">    1181242 :         char dbuf[64];</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">    1181242 :         if (lua_type(lua,j+1) == LUA_TNUMBER) {</span>
<span class="lineNum">     402 </span>            :             /* We can't use lua_tolstring() for number -&gt; string conversion
<span class="lineNum">     403 </span>            :              * since Lua uses a format specifier that loses precision. */
<span class="lineNum">     404 </span><span class="lineCov">        248 :             lua_Number num = lua_tonumber(lua,j+1);</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span><span class="lineCov">        248 :             obj_len = snprintf(dbuf,sizeof(dbuf),&quot;%.17g&quot;,(double)num);</span>
<span class="lineNum">     407 </span><span class="lineCov">        248 :             obj_s = dbuf;</span>
<span class="lineNum">     408 </span>            :         } else {
<span class="lineNum">     409 </span><span class="lineCov">    1180994 :             obj_s = (char*)lua_tolstring(lua,j+1,&amp;obj_len);</span>
<span class="lineNum">     410 </span><span class="lineCov">    1180994 :             if (obj_s == NULL) break; /* Not a string. */</span>
<span class="lineNum">     411 </span>            :         }
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :         /* Try to use a cached object. */
<span class="lineNum">     414 </span><span class="lineCov">    1181242 :         if (j &lt; LUA_CMD_OBJCACHE_SIZE &amp;&amp; cached_objects[j] &amp;&amp;</span>
<span class="lineNum">     415 </span><span class="lineCov">    1180869 :             cached_objects_len[j] &gt;= obj_len)</span>
<span class="lineNum">     416 </span>            :         {
<span class="lineNum">     417 </span><span class="lineCov">    1180748 :             sds s = cached_objects[j]-&gt;ptr;</span>
<span class="lineNum">     418 </span><span class="lineCov">    1180748 :             argv[j] = cached_objects[j];</span>
<span class="lineNum">     419 </span><span class="lineCov">    1180748 :             cached_objects[j] = NULL;</span>
<span class="lineNum">     420 </span><span class="lineCov">    1180748 :             memcpy(s,obj_s,obj_len+1);</span>
<span class="lineNum">     421 </span><span class="lineCov">    1180748 :             sdssetlen(s, obj_len);</span>
<span class="lineNum">     422 </span>            :         } else {
<span class="lineNum">     423 </span><span class="lineCov">        494 :             argv[j] = createStringObject(obj_s, obj_len);</span>
<span class="lineNum">     424 </span>            :         }
<span class="lineNum">     425 </span>            :     }
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :     /* Check if one of the arguments passed by the Lua script
<span class="lineNum">     428 </span>            :      * is not a string or an integer (lua_isstring() return true for
<span class="lineNum">     429 </span>            :      * integers as well). */
<span class="lineNum">     430 </span><span class="lineCov">     690397 :     if (j != argc) {</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :         j--;</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :         while (j &gt;= 0) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :             decrRefCount(argv[j]);</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :             j--;</span>
<span class="lineNum">     435 </span>            :         }
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         luaPushError(lua,</span>
<span class="lineNum">     437 </span>            :             &quot;Lua redis() command arguments must be strings or integers&quot;);
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :         inuse--;</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :         return raise_error ? luaRaiseError(lua) : 1;</span>
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span>            :     /* Setup our fake client for command execution */
<span class="lineNum">     443 </span><span class="lineCov">     690397 :     c-&gt;argv = argv;</span>
<span class="lineNum">     444 </span><span class="lineCov">     690397 :     c-&gt;argc = argc;</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :     /* Log the command if debugging is active. */
<span class="lineNum">     447 </span><span class="lineCov">     690397 :     if (ldb.active &amp;&amp; ldb.step) {</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :         sds cmdlog = sdsnew(&quot;&lt;redis&gt;&quot;);</span>
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :         for (j = 0; j &lt; c-&gt;argc; j++) {</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :             if (j == 10) {</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                 cmdlog = sdscatprintf(cmdlog,&quot; ... (%d more)&quot;,</span>
<span class="lineNum">     452 </span>            :                     c-&gt;argc-j-1);
<span class="lineNum">     453 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     454 </span>            :             } else {
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 cmdlog = sdscatlen(cmdlog,&quot; &quot;,1);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :                 cmdlog = sdscatsds(cmdlog,c-&gt;argv[j]-&gt;ptr);</span>
<span class="lineNum">     457 </span>            :             }
<span class="lineNum">     458 </span>            :         }
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :         ldbLog(cmdlog);</span>
<span class="lineNum">     460 </span>            :     }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            :     /* Command lookup */
<span class="lineNum">     463 </span><span class="lineCov">     690397 :     cmd = lookupCommand(argv[0]-&gt;ptr);</span>
<span class="lineNum">     464 </span><span class="lineCov">     690397 :     if (!cmd || ((cmd-&gt;arity &gt; 0 &amp;&amp; cmd-&gt;arity != argc) ||</span>
<span class="lineNum">     465 </span><span class="lineCov">     690377 :                    (argc &lt; -cmd-&gt;arity)))</span>
<span class="lineNum">     466 </span>            :     {
<span class="lineNum">     467 </span><span class="lineCov">         20 :         if (cmd)</span>
<span class="lineNum">     468 </span><span class="lineCov">          4 :             luaPushError(lua,</span>
<span class="lineNum">     469 </span>            :                 &quot;Wrong number of args calling Redis command From Lua script&quot;);
<span class="lineNum">     470 </span>            :         else
<span class="lineNum">     471 </span><span class="lineCov">         16 :             luaPushError(lua,&quot;Unknown Redis command called from Lua script&quot;);</span>
<span class="lineNum">     472 </span><span class="lineCov">         20 :         goto cleanup;</span>
<span class="lineNum">     473 </span>            :     }
<span class="lineNum">     474 </span><span class="lineCov">     690377 :     c-&gt;cmd = c-&gt;lastcmd = cmd;</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            :     /* There are commands that are not allowed inside scripts. */
<span class="lineNum">     477 </span><span class="lineCov">     690377 :     if (cmd-&gt;flags &amp; CMD_NOSCRIPT) {</span>
<span class="lineNum">     478 </span><span class="lineCov">          4 :         luaPushError(lua, &quot;This Redis command is not allowed from scripts&quot;);</span>
<span class="lineNum">     479 </span><span class="lineCov">          4 :         goto cleanup;</span>
<span class="lineNum">     480 </span>            :     }
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :     /* Write commands are forbidden against read-only slaves, or if a
<span class="lineNum">     483 </span>            :      * command marked as non-deterministic was already called in the context
<span class="lineNum">     484 </span>            :      * of this script. */
<span class="lineNum">     485 </span><span class="lineCov">     690373 :     if (cmd-&gt;flags &amp; CMD_WRITE) {</span>
<span class="lineNum">     486 </span><span class="lineCov">     490211 :         int deny_write_type = writeCommandsDeniedByDiskError();</span>
<span class="lineNum">     487 </span><span class="lineCov">     490211 :         if (server.lua_random_dirty &amp;&amp; !server.lua_replicate_commands) {</span>
<span class="lineNum">     488 </span><span class="lineCov">          4 :             luaPushError(lua,</span>
<span class="lineNum">     489 </span>            :                 &quot;Write commands not allowed after non deterministic commands. Call redis.replicate_commands() at the start of your script in order to switch to single commands replication mode.&quot;);
<span class="lineNum">     490 </span><span class="lineCov">          4 :             goto cleanup;</span>
<span class="lineNum">     491 </span><span class="lineCov">     490207 :         } else if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                    !server.loading &amp;&amp;</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                    !(server.lua_caller-&gt;flags &amp; CLIENT_MASTER))</span>
<span class="lineNum">     494 </span>            :         {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :             luaPushError(lua, shared.roslaveerr-&gt;ptr);</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :             goto cleanup;</span>
<span class="lineNum">     497 </span><span class="lineCov">     490207 :         } else if (deny_write_type != DISK_ERROR_TYPE_NONE) {</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :             if (deny_write_type == DISK_ERROR_TYPE_RDB) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :                 luaPushError(lua, shared.bgsaveerr-&gt;ptr);</span>
<span class="lineNum">     500 </span>            :             } else {
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :                 sds aof_write_err = sdscatfmt(sdsempty(),</span>
<span class="lineNum">     502 </span>            :                     &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,
<span class="lineNum">     503 </span>            :                     strerror(server.aof_last_write_errno));
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                 luaPushError(lua, aof_write_err);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                 sdsfree(aof_write_err);</span>
<span class="lineNum">     506 </span>            :             }
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :             goto cleanup;</span>
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span>            :     }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :     /* If we reached the memory limit configured via maxmemory, commands that
<span class="lineNum">     512 </span>            :      * could enlarge the memory usage are not allowed, but only if this is the
<span class="lineNum">     513 </span>            :      * first write in the context of this script, otherwise we can't stop
<span class="lineNum">     514 </span>            :      * in the middle. */
<span class="lineNum">     515 </span><span class="lineCov">     690369 :     if (server.maxmemory &amp;&amp;             /* Maxmemory is actually enabled. */</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :         !server.loading &amp;&amp;              /* Don't care about mem if loading. */</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :         !server.masterhost &amp;&amp;           /* Slave must execute the script. */</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         server.lua_write_dirty == 0 &amp;&amp;  /* Script had no side effects so far. */</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :         (cmd-&gt;flags &amp; CMD_DENYOOM))</span>
<span class="lineNum">     520 </span>            :     {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :         if (getMaxmemoryState(NULL,NULL,NULL,NULL) != C_OK) {</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :             luaPushError(lua, shared.oomerr-&gt;ptr);</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :             goto cleanup;</span>
<span class="lineNum">     524 </span>            :         }
<span class="lineNum">     525 </span>            :     }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">     690369 :     if (cmd-&gt;flags &amp; CMD_RANDOM) server.lua_random_dirty = 1;</span>
<span class="lineNum">     528 </span><span class="lineCov">     690369 :     if (cmd-&gt;flags &amp; CMD_WRITE) server.lua_write_dirty = 1;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :     /* If this is a Redis Cluster node, we need to make sure Lua is not
<span class="lineNum">     531 </span>            :      * trying to access non-local keys, with the exception of commands
<span class="lineNum">     532 </span>            :      * received from our master or when loading the AOF back in memory. */
<span class="lineNum">     533 </span><span class="lineCov">     690369 :     if (server.cluster_enabled &amp;&amp; !server.loading &amp;&amp;</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :         !(server.lua_caller-&gt;flags &amp; CLIENT_MASTER))</span>
<span class="lineNum">     535 </span>            :     {
<span class="lineNum">     536 </span>            :         /* Duplicate relevant flags in the lua client. */
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :         c-&gt;flags &amp;= ~(CLIENT_READONLY|CLIENT_ASKING);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :         c-&gt;flags |= server.lua_caller-&gt;flags &amp; (CLIENT_READONLY|CLIENT_ASKING);</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         if (getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,NULL,NULL) !=</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :                            server.cluster-&gt;myself)</span>
<span class="lineNum">     541 </span>            :         {
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :             luaPushError(lua,</span>
<span class="lineNum">     543 </span>            :                 &quot;Lua script attempted to access a non local key in a &quot;
<span class="lineNum">     544 </span>            :                 &quot;cluster node&quot;);
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :             goto cleanup;</span>
<span class="lineNum">     546 </span>            :         }
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :     /* If we are using single commands replication, we need to wrap what
<span class="lineNum">     550 </span>            :      * we propagate into a MULTI/EXEC block, so that it will be atomic like
<span class="lineNum">     551 </span>            :      * a Lua script in the context of AOF and slaves. */
<span class="lineNum">     552 </span><span class="lineCov">     690369 :     if (server.lua_replicate_commands &amp;&amp;</span>
<span class="lineNum">     553 </span><span class="lineCov">     690361 :         !server.lua_multi_emitted &amp;&amp;</span>
<span class="lineNum">     554 </span><span class="lineCov">     690196 :         !(server.lua_caller-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span>
<span class="lineNum">     555 </span><span class="lineCov">     690196 :         server.lua_write_dirty &amp;&amp;</span>
<span class="lineNum">     556 </span><span class="lineCov">     490130 :         server.lua_repl != PROPAGATE_NONE)</span>
<span class="lineNum">     557 </span>            :     {
<span class="lineNum">     558 </span><span class="lineCov">     490130 :         execCommandPropagateMulti(server.lua_caller);</span>
<span class="lineNum">     559 </span><span class="lineCov">     490130 :         server.lua_multi_emitted = 1;</span>
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            :     /* Run the command */
<span class="lineNum">     563 </span><span class="lineCov">     690369 :     int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;</span>
<span class="lineNum">     564 </span><span class="lineCov">     690369 :     if (server.lua_replicate_commands) {</span>
<span class="lineNum">     565 </span>            :         /* Set flags according to redis.set_repl() settings. */
<span class="lineNum">     566 </span><span class="lineCov">     690361 :         if (server.lua_repl &amp; PROPAGATE_AOF)</span>
<span class="lineNum">     567 </span><span class="lineCov">     690359 :             call_flags |= CMD_CALL_PROPAGATE_AOF;</span>
<span class="lineNum">     568 </span><span class="lineCov">     690361 :         if (server.lua_repl &amp; PROPAGATE_REPL)</span>
<span class="lineNum">     569 </span><span class="lineCov">     690357 :             call_flags |= CMD_CALL_PROPAGATE_REPL;</span>
<span class="lineNum">     570 </span>            :     }
<span class="lineNum">     571 </span><span class="lineCov">     690369 :     call(c,call_flags);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :     /* Convert the result of the Redis command into a suitable Lua type.
<span class="lineNum">     574 </span>            :      * The first thing we need is to create a single string from the client
<span class="lineNum">     575 </span>            :      * output buffers. */
<span class="lineNum">     576 </span><span class="lineCov">     690369 :     if (listLength(c-&gt;reply) == 0 &amp;&amp; c-&gt;bufpos &lt; PROTO_REPLY_CHUNK_BYTES) {</span>
<span class="lineNum">     577 </span>            :         /* This is a fast path for the common case of a reply inside the
<span class="lineNum">     578 </span>            :          * client static buffer. Don't create an SDS string but just use
<span class="lineNum">     579 </span>            :          * the client buffer directly. */
<span class="lineNum">     580 </span><span class="lineCov">     690365 :         c-&gt;buf[c-&gt;bufpos] = '\0';</span>
<span class="lineNum">     581 </span><span class="lineCov">     690365 :         reply = c-&gt;buf;</span>
<span class="lineNum">     582 </span><span class="lineCov">     690365 :         c-&gt;bufpos = 0;</span>
<span class="lineNum">     583 </span>            :     } else {
<span class="lineNum">     584 </span><span class="lineCov">          4 :         reply = sdsnewlen(c-&gt;buf,c-&gt;bufpos);</span>
<span class="lineNum">     585 </span><span class="lineCov">          4 :         c-&gt;bufpos = 0;</span>
<span class="lineNum">     586 </span><span class="lineCov">          8 :         while(listLength(c-&gt;reply)) {</span>
<span class="lineNum">     587 </span><span class="lineCov">          4 :             clientReplyBlock *o = listNodeValue(listFirst(c-&gt;reply));</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineCov">          4 :             reply = sdscatlen(reply,o-&gt;buf,o-&gt;used);</span>
<span class="lineNum">     590 </span><span class="lineCov">          4 :             listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span>
<span class="lineNum">     591 </span>            :         }
<span class="lineNum">     592 </span>            :     }
<span class="lineNum">     593 </span><span class="lineCov">     690369 :     if (raise_error &amp;&amp; reply[0] != '-') raise_error = 0;</span>
<span class="lineNum">     594 </span><span class="lineCov">     690369 :     redisProtocolToLuaType(lua,reply);</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :     /* If the debugger is active, log the reply from Redis. */
<span class="lineNum">     597 </span><span class="lineCov">     690369 :     if (ldb.active &amp;&amp; ldb.step)</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 :         ldbLogRedisReply(reply);</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            :     /* Sort the output array if needed, assuming it is a non-null multi bulk
<span class="lineNum">     601 </span>            :      * reply as expected. */
<span class="lineNum">     602 </span><span class="lineCov">     690369 :     if ((cmd-&gt;flags &amp; CMD_SORT_FOR_SCRIPT) &amp;&amp;</span>
<span class="lineNum">     603 </span><span class="lineCov">          4 :         (server.lua_replicate_commands == 0) &amp;&amp;</span>
<span class="lineNum">     604 </span><span class="lineCov">          4 :         (reply[0] == '*' &amp;&amp; reply[1] != '-')) {</span>
<span class="lineNum">     605 </span><span class="lineCov">          4 :             luaSortArray(lua);</span>
<span class="lineNum">     606 </span>            :     }
<span class="lineNum">     607 </span><span class="lineCov">     690369 :     if (reply != c-&gt;buf) sdsfree(reply);</span>
<span class="lineNum">     608 </span><span class="lineCov">     690369 :     c-&gt;reply_bytes = 0;</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">     690397 : cleanup:</span>
<span class="lineNum">     611 </span>            :     /* Clean up. Command code may have changed argv/argc so we use the
<span class="lineNum">     612 </span>            :      * argv/argc of the client instead of the local variables. */
<span class="lineNum">     613 </span><span class="lineCov">    1871613 :     for (j = 0; j &lt; c-&gt;argc; j++) {</span>
<span class="lineNum">     614 </span><span class="lineCov">    1181216 :         robj *o = c-&gt;argv[j];</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :         /* Try to cache the object in the cached_objects array.
<span class="lineNum">     617 </span>            :          * The object must be small, SDS-encoded, and with refcount = 1
<span class="lineNum">     618 </span>            :          * (we must be the only owner) for us to cache it. */
<span class="lineNum">     619 </span><span class="lineCov">    1181216 :         if (j &lt; LUA_CMD_OBJCACHE_SIZE &amp;&amp;</span>
<span class="lineNum">     620 </span><span class="lineCov">    1181076 :             o-&gt;refcount == 1 &amp;&amp;</span>
<span class="lineNum">     621 </span><span class="lineCov">    1180990 :             (o-&gt;encoding == OBJ_ENCODING_RAW ||</span>
<span class="lineNum">     622 </span><span class="lineCov">    1180990 :              o-&gt;encoding == OBJ_ENCODING_EMBSTR) &amp;&amp;</span>
<span class="lineNum">     623 </span><span class="lineCov">    2361980 :             sdslen(o-&gt;ptr) &lt;= LUA_CMD_OBJCACHE_MAX_LEN)</span>
<span class="lineNum">     624 </span><span class="lineCov">    1180990 :         {</span>
<span class="lineNum">     625 </span><span class="lineCov">    1180990 :             sds s = o-&gt;ptr;</span>
<span class="lineNum">     626 </span><span class="lineCov">    1180990 :             if (cached_objects[j]) decrRefCount(cached_objects[j]);</span>
<span class="lineNum">     627 </span><span class="lineCov">    1180990 :             cached_objects[j] = o;</span>
<span class="lineNum">     628 </span><span class="lineCov">    2361980 :             cached_objects_len[j] = sdsalloc(s);</span>
<span class="lineNum">     629 </span>            :         } else {
<span class="lineNum">     630 </span><span class="lineCov">        226 :             decrRefCount(o);</span>
<span class="lineNum">     631 </span>            :         }
<span class="lineNum">     632 </span>            :     }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineCov">     690397 :     if (c-&gt;argv != argv) {</span>
<span class="lineNum">     635 </span><span class="lineCov">         26 :         zfree(c-&gt;argv);</span>
<span class="lineNum">     636 </span><span class="lineCov">         26 :         argv = NULL;</span>
<span class="lineNum">     637 </span><span class="lineCov">         26 :         argv_size = 0;</span>
<span class="lineNum">     638 </span>            :     }
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineCov">     690397 :     if (raise_error) {</span>
<span class="lineNum">     641 </span>            :         /* If we are here we should have an error in the stack, in the
<span class="lineNum">     642 </span>            :          * form of a table with an &quot;err&quot; field. Extract the string to
<span class="lineNum">     643 </span>            :          * return the plain error. */
<span class="lineNum">     644 </span><span class="lineCov">         24 :         inuse--;</span>
<span class="lineNum">     645 </span><span class="lineCov">         24 :         return luaRaiseError(lua);</span>
<span class="lineNum">     646 </span>            :     }
<span class="lineNum">     647 </span><span class="lineCov">     690373 :     inuse--;</span>
<span class="lineNum">     648 </span><span class="lineCov">     690373 :     return 1;</span>
<span class="lineNum">     649 </span>            : }
<a name="650"><span class="lineNum">     650 </span>            : </a>
<span class="lineNum">     651 </span>            : /* redis.call() */
<span class="lineNum">     652 </span><span class="lineCov">     690357 : int luaRedisCallCommand(lua_State *lua) {</span>
<span class="lineNum">     653 </span><span class="lineCov">     690357 :     return luaRedisGenericCommand(lua,1);</span>
<span class="lineNum">     654 </span>            : }
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : /* redis.pcall() */
<span class="lineNum">     657 </span><span class="lineCov">         44 : int luaRedisPCallCommand(lua_State *lua) {</span>
<span class="lineNum">     658 </span><span class="lineCov">         44 :     return luaRedisGenericCommand(lua,0);</span>
<span class="lineNum">     659 </span>            : }
<span class="lineNum">     660 </span>            : 
<a name="661"><span class="lineNum">     661 </span>            : /* This adds redis.sha1hex(string) to Lua scripts using the same hashing</a>
<span class="lineNum">     662 </span>            :  * function used for sha1ing lua scripts. */
<span class="lineNum">     663 </span><span class="lineCov">     150013 : int luaRedisSha1hexCommand(lua_State *lua) {</span>
<span class="lineNum">     664 </span><span class="lineCov">     150013 :     int argc = lua_gettop(lua);</span>
<span class="lineNum">     665 </span><span class="lineCov">     150013 :     char digest[41];</span>
<span class="lineNum">     666 </span><span class="lineCov">     150013 :     size_t len;</span>
<span class="lineNum">     667 </span><span class="lineCov">     150013 :     char *s;</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">     150013 :     if (argc != 1) {</span>
<span class="lineNum">     670 </span><span class="lineCov">          2 :         lua_pushstring(lua, &quot;wrong number of arguments&quot;);</span>
<span class="lineNum">     671 </span><span class="lineCov">          2 :         return lua_error(lua);</span>
<span class="lineNum">     672 </span>            :     }
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineCov">     150011 :     s = (char*)lua_tolstring(lua,1,&amp;len);</span>
<span class="lineNum">     675 </span><span class="lineCov">     150011 :     sha1hex(digest,s,len);</span>
<span class="lineNum">     676 </span><span class="lineCov">     150011 :     lua_pushstring(lua,digest);</span>
<span class="lineNum">     677 </span><span class="lineCov">     150011 :     return 1;</span>
<span class="lineNum">     678 </span>            : }
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : /* Returns a table with a single field 'field' set to the string value
<span class="lineNum">     681 </span>            :  * passed as argument. This helper function is handy when returning
<span class="lineNum">     682 </span>            :  * a Redis Protocol error or status reply from Lua:
<span class="lineNum">     683 </span>            :  *
<span class="lineNum">     684 </span>            :  * return redis.error_reply(&quot;ERR Some Error&quot;)
<a name="685"><span class="lineNum">     685 </span>            :  * return redis.status_reply(&quot;ERR Some Error&quot;)</a>
<span class="lineNum">     686 </span>            :  */
<span class="lineNum">     687 </span><span class="lineNoCov">          0 : int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :     if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :         luaPushError(lua, &quot;wrong number or type of arguments&quot;);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     691 </span>            :     }
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :     lua_newtable(lua);</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     lua_pushstring(lua, field);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     lua_pushvalue(lua, -3);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :     lua_settable(lua, -3);</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     698 </span>            : }
<a name="699"><span class="lineNum">     699 </span>            : </a>
<span class="lineNum">     700 </span>            : /* redis.error_reply() */
<span class="lineNum">     701 </span><span class="lineNoCov">          0 : int luaRedisErrorReplyCommand(lua_State *lua) {</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :     return luaRedisReturnSingleFieldTable(lua,&quot;err&quot;);</span>
<span class="lineNum">     703 </span>            : }
<a name="704"><span class="lineNum">     704 </span>            : </a>
<span class="lineNum">     705 </span>            : /* redis.status_reply() */
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : int luaRedisStatusReplyCommand(lua_State *lua) {</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :     return luaRedisReturnSingleFieldTable(lua,&quot;ok&quot;);</span>
<span class="lineNum">     708 </span>            : }
<span class="lineNum">     709 </span>            : 
<span class="lineNum">     710 </span>            : /* redis.replicate_commands()
<span class="lineNum">     711 </span>            :  *
<span class="lineNum">     712 </span>            :  * Turn on single commands replication if the script never called
<span class="lineNum">     713 </span>            :  * a write command so far, and returns true. Otherwise if the script
<a name="714"><span class="lineNum">     714 </span>            :  * already started to write, returns false and stick to whole scripts</a>
<span class="lineNum">     715 </span>            :  * replication, which is our default. */
<span class="lineNum">     716 </span><span class="lineCov">         14 : int luaRedisReplicateCommandsCommand(lua_State *lua) {</span>
<span class="lineNum">     717 </span><span class="lineCov">         14 :     if (server.lua_write_dirty) {</span>
<span class="lineNum">     718 </span><span class="lineCov">          2 :         lua_pushboolean(lua,0);</span>
<span class="lineNum">     719 </span>            :     } else {
<span class="lineNum">     720 </span><span class="lineCov">         12 :         server.lua_replicate_commands = 1;</span>
<span class="lineNum">     721 </span>            :         /* When we switch to single commands replication, we can provide
<span class="lineNum">     722 </span>            :          * different math.random() sequences at every call, which is what
<span class="lineNum">     723 </span>            :          * the user normally expects. */
<span class="lineNum">     724 </span><span class="lineCov">         12 :         redisSrand48(rand());</span>
<span class="lineNum">     725 </span><span class="lineCov">         12 :         lua_pushboolean(lua,1);</span>
<span class="lineNum">     726 </span>            :     }
<span class="lineNum">     727 </span><span class="lineCov">         14 :     return 1;</span>
<span class="lineNum">     728 </span>            : }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            : /* redis.breakpoint()
<span class="lineNum">     731 </span>            :  *
<span class="lineNum">     732 </span>            :  * Allows to stop execution during a debuggign session from within
<a name="733"><span class="lineNum">     733 </span>            :  * the Lua code implementation, like if a breakpoint was set in the code</a>
<span class="lineNum">     734 </span>            :  * immediately after the function. */
<span class="lineNum">     735 </span><span class="lineNoCov">          0 : int luaRedisBreakpointCommand(lua_State *lua) {</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :     if (ldb.active) {</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         ldb.luabp = 1;</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         lua_pushboolean(lua,1);</span>
<span class="lineNum">     739 </span>            :     } else {
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :         lua_pushboolean(lua,0);</span>
<span class="lineNum">     741 </span>            :     }
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">     743 </span>            : }
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            : /* redis.debug()
<span class="lineNum">     746 </span>            :  *
<span class="lineNum">     747 </span>            :  * Log a string message into the output console.
<a name="748"><span class="lineNum">     748 </span>            :  * Can take multiple arguments that will be separated by commas.</a>
<span class="lineNum">     749 </span>            :  * Nothing is returned to the caller. */
<span class="lineNum">     750 </span><span class="lineNoCov">          0 : int luaRedisDebugCommand(lua_State *lua) {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :     if (!ldb.active) return 0;</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :     int argc = lua_gettop(lua);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :     sds log = sdscatprintf(sdsempty(),&quot;&lt;debug&gt; line %d: &quot;, ldb.currentline);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :     while(argc--) {</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :         log = ldbCatStackValue(log,lua,-1 - argc);</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :         if (argc != 0) log = sdscatlen(log,&quot;, &quot;,2);</span>
<span class="lineNum">     757 </span>            :     }
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :     ldbLog(log);</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     760 </span>            : }
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            : /* redis.set_repl()
<span class="lineNum">     763 </span>            :  *
<a name="764"><span class="lineNum">     764 </span>            :  * Set the propagation of write commands executed in the context of the</a>
<span class="lineNum">     765 </span>            :  * script to on/off for AOF and slaves. */
<span class="lineNum">     766 </span><span class="lineCov">         10 : int luaRedisSetReplCommand(lua_State *lua) {</span>
<span class="lineNum">     767 </span><span class="lineCov">         10 :     int argc = lua_gettop(lua);</span>
<span class="lineNum">     768 </span><span class="lineCov">         10 :     int flags;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineCov">         10 :     if (server.lua_replicate_commands == 0) {</span>
<span class="lineNum">     771 </span><span class="lineCov">          2 :         lua_pushstring(lua, &quot;You can set the replication behavior only after turning on single commands replication with redis.replicate_commands().&quot;);</span>
<span class="lineNum">     772 </span><span class="lineCov">          2 :         return lua_error(lua);</span>
<span class="lineNum">     773 </span><span class="lineCov">          8 :     } else if (argc != 1) {</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :         lua_pushstring(lua, &quot;redis.set_repl() requires two arguments.&quot;);</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :         return lua_error(lua);</span>
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineCov">          8 :     flags = lua_tonumber(lua,-1);</span>
<span class="lineNum">     779 </span><span class="lineCov">          8 :     if ((flags &amp; ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {</span>
<span class="lineNum">     780 </span><span class="lineCov">          2 :         lua_pushstring(lua, &quot;Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE.&quot;);</span>
<span class="lineNum">     781 </span><span class="lineCov">          2 :         return lua_error(lua);</span>
<span class="lineNum">     782 </span>            :     }
<span class="lineNum">     783 </span><span class="lineCov">          6 :     server.lua_repl = flags;</span>
<span class="lineNum">     784 </span><span class="lineCov">          6 :     return 0;</span>
<span class="lineNum">     785 </span>            : }
<a name="786"><span class="lineNum">     786 </span>            : </a>
<span class="lineNum">     787 </span>            : /* redis.log() */
<span class="lineNum">     788 </span><span class="lineNoCov">          0 : int luaLogCommand(lua_State *lua) {</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     int j, argc = lua_gettop(lua);</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     int level;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     sds log;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     if (argc &lt; 2) {</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         lua_pushstring(lua, &quot;redis.log() requires two arguments or more.&quot;);</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         return lua_error(lua);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     } else if (!lua_isnumber(lua,-argc)) {</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         lua_pushstring(lua, &quot;First argument must be a number (log level).&quot;);</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :         return lua_error(lua);</span>
<span class="lineNum">     799 </span>            :     }
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :     level = lua_tonumber(lua,-argc);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :     if (level &lt; LL_DEBUG || level &gt; LL_WARNING) {</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         lua_pushstring(lua, &quot;Invalid debug level.&quot;);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         return lua_error(lua);</span>
<span class="lineNum">     804 </span>            :     }
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :     /* Glue together all the arguments */
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     log = sdsempty();</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     for (j = 1; j &lt; argc; j++) {</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :         size_t len;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         char *s;</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         s = (char*)lua_tolstring(lua,(-argc)+j,&amp;len);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         if (s) {</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :             if (j != 1) log = sdscatlen(log,&quot; &quot;,1);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :             log = sdscatlen(log,s,len);</span>
<span class="lineNum">     816 </span>            :         }
<span class="lineNum">     817 </span>            :     }
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :     serverLogRaw(level,log);</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :     sdsfree(log);</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     821 </span>            : }
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">     824 </span>            :  * Lua engine initialization and reset.
<a name="825"><span class="lineNum">     825 </span>            :  * ------------------------------------------------------------------------- */</a>
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineCov">       5940 : void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {</span>
<span class="lineNum">     828 </span><span class="lineCov">       5940 :   lua_pushcfunction(lua, luafunc);</span>
<span class="lineNum">     829 </span><span class="lineCov">       5940 :   lua_pushstring(lua, libname);</span>
<span class="lineNum">     830 </span><span class="lineCov">       5940 :   lua_call(lua, 1, 0);</span>
<span class="lineNum">     831 </span><span class="lineCov">       5940 : }</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            : LUALIB_API int (luaopen_cjson) (lua_State *L);
<span class="lineNum">     834 </span>            : LUALIB_API int (luaopen_struct) (lua_State *L);
<span class="lineNum">     835 </span>            : LUALIB_API int (luaopen_cmsgpack) (lua_State *L);
<a name="836"><span class="lineNum">     836 </span>            : LUALIB_API int (luaopen_bit) (lua_State *L);</a>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span><span class="lineCov">        660 : void luaLoadLibraries(lua_State *lua) {</span>
<span class="lineNum">     839 </span><span class="lineCov">        660 :     luaLoadLib(lua, &quot;&quot;, luaopen_base);</span>
<span class="lineNum">     840 </span><span class="lineCov">        660 :     luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);</span>
<span class="lineNum">     841 </span><span class="lineCov">        660 :     luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);</span>
<span class="lineNum">     842 </span><span class="lineCov">        660 :     luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);</span>
<span class="lineNum">     843 </span><span class="lineCov">        660 :     luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);</span>
<span class="lineNum">     844 </span><span class="lineCov">        660 :     luaLoadLib(lua, &quot;cjson&quot;, luaopen_cjson);</span>
<span class="lineNum">     845 </span><span class="lineCov">        660 :     luaLoadLib(lua, &quot;struct&quot;, luaopen_struct);</span>
<span class="lineNum">     846 </span><span class="lineCov">        660 :     luaLoadLib(lua, &quot;cmsgpack&quot;, luaopen_cmsgpack);</span>
<span class="lineNum">     847 </span><span class="lineCov">        660 :     luaLoadLib(lua, &quot;bit&quot;, luaopen_bit);</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : #if 0 /* Stuff that we don't load currently, for sandboxing concerns. */
<span class="lineNum">     850 </span>            :     luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
<span class="lineNum">     851 </span>            :     luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
<span class="lineNum">     852 </span>            : #endif
<span class="lineNum">     853 </span><span class="lineCov">        660 : }</span>
<span class="lineNum">     854 </span>            : 
<a name="855"><span class="lineNum">     855 </span>            : /* Remove a functions that we don't want to expose to the Redis scripting</a>
<span class="lineNum">     856 </span>            :  * environment. */
<span class="lineNum">     857 </span><span class="lineCov">        660 : void luaRemoveUnsupportedFunctions(lua_State *lua) {</span>
<span class="lineNum">     858 </span><span class="lineCov">        660 :     lua_pushnil(lua);</span>
<span class="lineNum">     859 </span><span class="lineCov">        660 :     lua_setglobal(lua,&quot;loadfile&quot;);</span>
<span class="lineNum">     860 </span><span class="lineCov">        660 :     lua_pushnil(lua);</span>
<span class="lineNum">     861 </span><span class="lineCov">        660 :     lua_setglobal(lua,&quot;dofile&quot;);</span>
<span class="lineNum">     862 </span><span class="lineCov">        660 : }</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            : /* This function installs metamethods in the global table _G that prevent
<span class="lineNum">     865 </span>            :  * the creation of globals accidentally.
<span class="lineNum">     866 </span>            :  *
<a name="867"><span class="lineNum">     867 </span>            :  * It should be the last to be called in the scripting engine initialization</a>
<span class="lineNum">     868 </span>            :  * sequence, because it may interact with creation of globals. */
<span class="lineNum">     869 </span><span class="lineCov">        660 : void scriptingEnableGlobalsProtection(lua_State *lua) {</span>
<span class="lineNum">     870 </span><span class="lineCov">        660 :     char *s[32];</span>
<span class="lineNum">     871 </span><span class="lineCov">        660 :     sds code = sdsempty();</span>
<span class="lineNum">     872 </span><span class="lineCov">        660 :     int j = 0;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :     /* strict.lua from: http://metalua.luaforge.net/src/lib/strict.lua.html.
<span class="lineNum">     875 </span>            :      * Modified to be adapted to Redis. */
<span class="lineNum">     876 </span><span class="lineCov">        660 :     s[j++]=&quot;local dbg=debug\n&quot;;</span>
<span class="lineNum">     877 </span><span class="lineCov">        660 :     s[j++]=&quot;local mt = {}\n&quot;;</span>
<span class="lineNum">     878 </span><span class="lineCov">        660 :     s[j++]=&quot;setmetatable(_G, mt)\n&quot;;</span>
<span class="lineNum">     879 </span><span class="lineCov">        660 :     s[j++]=&quot;mt.__newindex = function (t, n, v)\n&quot;;</span>
<span class="lineNum">     880 </span><span class="lineCov">        660 :     s[j++]=&quot;  if dbg.getinfo(2) then\n&quot;;</span>
<span class="lineNum">     881 </span><span class="lineCov">        660 :     s[j++]=&quot;    local w = dbg.getinfo(2, \&quot;S\&quot;).what\n&quot;;</span>
<span class="lineNum">     882 </span><span class="lineCov">        660 :     s[j++]=&quot;    if w ~= \&quot;main\&quot; and w ~= \&quot;C\&quot; then\n&quot;;</span>
<span class="lineNum">     883 </span><span class="lineCov">        660 :     s[j++]=&quot;      error(\&quot;Script attempted to create global variable '\&quot;..tostring(n)..\&quot;'\&quot;, 2)\n&quot;;</span>
<span class="lineNum">     884 </span><span class="lineCov">        660 :     s[j++]=&quot;    end\n&quot;;</span>
<span class="lineNum">     885 </span><span class="lineCov">        660 :     s[j++]=&quot;  end\n&quot;;</span>
<span class="lineNum">     886 </span><span class="lineCov">        660 :     s[j++]=&quot;  rawset(t, n, v)\n&quot;;</span>
<span class="lineNum">     887 </span><span class="lineCov">        660 :     s[j++]=&quot;end\n&quot;;</span>
<span class="lineNum">     888 </span><span class="lineCov">        660 :     s[j++]=&quot;mt.__index = function (t, n)\n&quot;;</span>
<span class="lineNum">     889 </span><span class="lineCov">        660 :     s[j++]=&quot;  if dbg.getinfo(2) and dbg.getinfo(2, \&quot;S\&quot;).what ~= \&quot;C\&quot; then\n&quot;;</span>
<span class="lineNum">     890 </span><span class="lineCov">        660 :     s[j++]=&quot;    error(\&quot;Script attempted to access nonexistent global variable '\&quot;..tostring(n)..\&quot;'\&quot;, 2)\n&quot;;</span>
<span class="lineNum">     891 </span><span class="lineCov">        660 :     s[j++]=&quot;  end\n&quot;;</span>
<span class="lineNum">     892 </span><span class="lineCov">        660 :     s[j++]=&quot;  return rawget(t, n)\n&quot;;</span>
<span class="lineNum">     893 </span><span class="lineCov">        660 :     s[j++]=&quot;end\n&quot;;</span>
<span class="lineNum">     894 </span><span class="lineCov">        660 :     s[j++]=&quot;debug = nil\n&quot;;</span>
<span class="lineNum">     895 </span><span class="lineCov">        660 :     s[j++]=NULL;</span>
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">      13200 :     for (j = 0; s[j] != NULL; j++) code = sdscatlen(code,s[j],strlen(s[j]));</span>
<span class="lineNum">     898 </span><span class="lineCov">       1320 :     luaL_loadbuffer(lua,code,sdslen(code),&quot;@enable_strict_lua&quot;);</span>
<span class="lineNum">     899 </span><span class="lineCov">        660 :     lua_pcall(lua,0,0,0);</span>
<span class="lineNum">     900 </span><span class="lineCov">        660 :     sdsfree(code);</span>
<span class="lineNum">     901 </span><span class="lineCov">        660 : }</span>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            : /* Initialize the scripting environment.
<span class="lineNum">     904 </span>            :  *
<span class="lineNum">     905 </span>            :  * This function is called the first time at server startup with
<span class="lineNum">     906 </span>            :  * the 'setup' argument set to 1.
<span class="lineNum">     907 </span>            :  *
<span class="lineNum">     908 </span>            :  * It can be called again multiple times during the lifetime of the Redis
<span class="lineNum">     909 </span>            :  * process, with 'setup' set to 0, and following a scriptingRelease() call,
<span class="lineNum">     910 </span>            :  * in order to reset the Lua scripting environment.
<a name="911"><span class="lineNum">     911 </span>            :  *</a>
<span class="lineNum">     912 </span>            :  * However it is simpler to just call scriptingReset() that does just that. */
<span class="lineNum">     913 </span><span class="lineCov">        660 : void scriptingInit(int setup) {</span>
<span class="lineNum">     914 </span><span class="lineCov">        660 :     lua_State *lua = lua_open();</span>
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span><span class="lineCov">        660 :     if (setup) {</span>
<span class="lineNum">     917 </span><span class="lineCov">        656 :         server.lua_client = NULL;</span>
<span class="lineNum">     918 </span><span class="lineCov">        656 :         server.lua_caller = NULL;</span>
<span class="lineNum">     919 </span><span class="lineCov">        656 :         server.lua_timedout = 0;</span>
<span class="lineNum">     920 </span><span class="lineCov">        656 :         ldbInit();</span>
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineCov">        660 :     luaLoadLibraries(lua);</span>
<span class="lineNum">     924 </span><span class="lineCov">        660 :     luaRemoveUnsupportedFunctions(lua);</span>
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :     /* Initialize a dictionary we use to map SHAs to scripts.
<span class="lineNum">     927 </span>            :      * This is useful for replication, as we need to replicate EVALSHA
<span class="lineNum">     928 </span>            :      * as EVAL, so we need to remember the associated script. */
<span class="lineNum">     929 </span><span class="lineCov">        660 :     server.lua_scripts = dictCreate(&amp;shaScriptObjectDictType,NULL);</span>
<span class="lineNum">     930 </span><span class="lineCov">        660 :     server.lua_scripts_mem = 0;</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span>            :     /* Register the redis commands table and fields */
<span class="lineNum">     933 </span><span class="lineCov">        660 :     lua_newtable(lua);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            :     /* redis.call */
<span class="lineNum">     936 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;call&quot;);</span>
<span class="lineNum">     937 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaRedisCallCommand);</span>
<span class="lineNum">     938 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span>            :     /* redis.pcall */
<span class="lineNum">     941 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;pcall&quot;);</span>
<span class="lineNum">     942 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaRedisPCallCommand);</span>
<span class="lineNum">     943 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :     /* redis.log and log levels. */
<span class="lineNum">     946 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;log&quot;);</span>
<span class="lineNum">     947 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaLogCommand);</span>
<span class="lineNum">     948 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;LOG_DEBUG&quot;);</span>
<span class="lineNum">     951 </span><span class="lineCov">        660 :     lua_pushnumber(lua,LL_DEBUG);</span>
<span class="lineNum">     952 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;LOG_VERBOSE&quot;);</span>
<span class="lineNum">     955 </span><span class="lineCov">        660 :     lua_pushnumber(lua,LL_VERBOSE);</span>
<span class="lineNum">     956 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;LOG_NOTICE&quot;);</span>
<span class="lineNum">     959 </span><span class="lineCov">        660 :     lua_pushnumber(lua,LL_NOTICE);</span>
<span class="lineNum">     960 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;LOG_WARNING&quot;);</span>
<span class="lineNum">     963 </span><span class="lineCov">        660 :     lua_pushnumber(lua,LL_WARNING);</span>
<span class="lineNum">     964 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span>            :     /* redis.sha1hex */
<span class="lineNum">     967 </span><span class="lineCov">        660 :     lua_pushstring(lua, &quot;sha1hex&quot;);</span>
<span class="lineNum">     968 </span><span class="lineCov">        660 :     lua_pushcfunction(lua, luaRedisSha1hexCommand);</span>
<span class="lineNum">     969 </span><span class="lineCov">        660 :     lua_settable(lua, -3);</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            :     /* redis.error_reply and redis.status_reply */
<span class="lineNum">     972 </span><span class="lineCov">        660 :     lua_pushstring(lua, &quot;error_reply&quot;);</span>
<span class="lineNum">     973 </span><span class="lineCov">        660 :     lua_pushcfunction(lua, luaRedisErrorReplyCommand);</span>
<span class="lineNum">     974 </span><span class="lineCov">        660 :     lua_settable(lua, -3);</span>
<span class="lineNum">     975 </span><span class="lineCov">        660 :     lua_pushstring(lua, &quot;status_reply&quot;);</span>
<span class="lineNum">     976 </span><span class="lineCov">        660 :     lua_pushcfunction(lua, luaRedisStatusReplyCommand);</span>
<span class="lineNum">     977 </span><span class="lineCov">        660 :     lua_settable(lua, -3);</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :     /* redis.replicate_commands */
<span class="lineNum">     980 </span><span class="lineCov">        660 :     lua_pushstring(lua, &quot;replicate_commands&quot;);</span>
<span class="lineNum">     981 </span><span class="lineCov">        660 :     lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);</span>
<span class="lineNum">     982 </span><span class="lineCov">        660 :     lua_settable(lua, -3);</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span>            :     /* redis.set_repl and associated flags. */
<span class="lineNum">     985 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;set_repl&quot;);</span>
<span class="lineNum">     986 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaRedisSetReplCommand);</span>
<span class="lineNum">     987 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;REPL_NONE&quot;);</span>
<span class="lineNum">     990 </span><span class="lineCov">        660 :     lua_pushnumber(lua,PROPAGATE_NONE);</span>
<span class="lineNum">     991 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;REPL_AOF&quot;);</span>
<span class="lineNum">     994 </span><span class="lineCov">        660 :     lua_pushnumber(lua,PROPAGATE_AOF);</span>
<span class="lineNum">     995 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;REPL_SLAVE&quot;);</span>
<span class="lineNum">     998 </span><span class="lineCov">        660 :     lua_pushnumber(lua,PROPAGATE_REPL);</span>
<span class="lineNum">     999 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;REPL_REPLICA&quot;);</span>
<span class="lineNum">    1002 </span><span class="lineCov">        660 :     lua_pushnumber(lua,PROPAGATE_REPL);</span>
<span class="lineNum">    1003 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;REPL_ALL&quot;);</span>
<span class="lineNum">    1006 </span><span class="lineCov">        660 :     lua_pushnumber(lua,PROPAGATE_AOF|PROPAGATE_REPL);</span>
<span class="lineNum">    1007 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :     /* redis.breakpoint */
<span class="lineNum">    1010 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;breakpoint&quot;);</span>
<span class="lineNum">    1011 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaRedisBreakpointCommand);</span>
<span class="lineNum">    1012 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :     /* redis.debug */
<span class="lineNum">    1015 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;debug&quot;);</span>
<span class="lineNum">    1016 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,luaRedisDebugCommand);</span>
<span class="lineNum">    1017 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :     /* Finally set the table as 'redis' global var. */
<span class="lineNum">    1020 </span><span class="lineCov">        660 :     lua_setglobal(lua,&quot;redis&quot;);</span>
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span>            :     /* Replace math.random and math.randomseed with our implementations. */
<span class="lineNum">    1023 </span><span class="lineCov">        660 :     lua_getglobal(lua,&quot;math&quot;);</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;random&quot;);</span>
<span class="lineNum">    1026 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,redis_math_random);</span>
<span class="lineNum">    1027 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineCov">        660 :     lua_pushstring(lua,&quot;randomseed&quot;);</span>
<span class="lineNum">    1030 </span><span class="lineCov">        660 :     lua_pushcfunction(lua,redis_math_randomseed);</span>
<span class="lineNum">    1031 </span><span class="lineCov">        660 :     lua_settable(lua,-3);</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineCov">        660 :     lua_setglobal(lua,&quot;math&quot;);</span>
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :     /* Add a helper function that we use to sort the multi bulk output of non
<span class="lineNum">    1036 </span>            :      * deterministic commands, when containing 'false' elements. */
<span class="lineNum">    1037 </span>            :     {
<span class="lineNum">    1038 </span><span class="lineCov">        660 :         char *compare_func =    &quot;function __redis__compare_helper(a,b)\n&quot;</span>
<span class="lineNum">    1039 </span>            :                                 &quot;  if a == false then a = '' end\n&quot;
<span class="lineNum">    1040 </span>            :                                 &quot;  if b == false then b = '' end\n&quot;
<span class="lineNum">    1041 </span>            :                                 &quot;  return a&lt;b\n&quot;
<span class="lineNum">    1042 </span>            :                                 &quot;end\n&quot;;
<span class="lineNum">    1043 </span><span class="lineCov">        660 :         luaL_loadbuffer(lua,compare_func,strlen(compare_func),&quot;@cmp_func_def&quot;);</span>
<span class="lineNum">    1044 </span><span class="lineCov">        660 :         lua_pcall(lua,0,0,0);</span>
<span class="lineNum">    1045 </span>            :     }
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span>            :     /* Add a helper function we use for pcall error reporting.
<span class="lineNum">    1048 </span>            :      * Note that when the error is in the C function we want to report the
<span class="lineNum">    1049 </span>            :      * information about the caller, that's what makes sense from the point
<span class="lineNum">    1050 </span>            :      * of view of the user debugging a script. */
<span class="lineNum">    1051 </span>            :     {
<span class="lineNum">    1052 </span><span class="lineCov">        660 :         char *errh_func =       &quot;local dbg = debug\n&quot;</span>
<span class="lineNum">    1053 </span>            :                                 &quot;function __redis__err__handler(err)\n&quot;
<span class="lineNum">    1054 </span>            :                                 &quot;  local i = dbg.getinfo(2,'nSl')\n&quot;
<span class="lineNum">    1055 </span>            :                                 &quot;  if i and i.what == 'C' then\n&quot;
<span class="lineNum">    1056 </span>            :                                 &quot;    i = dbg.getinfo(3,'nSl')\n&quot;
<span class="lineNum">    1057 </span>            :                                 &quot;  end\n&quot;
<span class="lineNum">    1058 </span>            :                                 &quot;  if i then\n&quot;
<span class="lineNum">    1059 </span>            :                                 &quot;    return i.source .. ':' .. i.currentline .. ': ' .. err\n&quot;
<span class="lineNum">    1060 </span>            :                                 &quot;  else\n&quot;
<span class="lineNum">    1061 </span>            :                                 &quot;    return err\n&quot;
<span class="lineNum">    1062 </span>            :                                 &quot;  end\n&quot;
<span class="lineNum">    1063 </span>            :                                 &quot;end\n&quot;;
<span class="lineNum">    1064 </span><span class="lineCov">        660 :         luaL_loadbuffer(lua,errh_func,strlen(errh_func),&quot;@err_handler_def&quot;);</span>
<span class="lineNum">    1065 </span><span class="lineCov">        660 :         lua_pcall(lua,0,0,0);</span>
<span class="lineNum">    1066 </span>            :     }
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :     /* Create the (non connected) client that we use to execute Redis commands
<span class="lineNum">    1069 </span>            :      * inside the Lua interpreter.
<span class="lineNum">    1070 </span>            :      * Note: there is no need to create it again when this function is called
<span class="lineNum">    1071 </span>            :      * by scriptingReset(). */
<span class="lineNum">    1072 </span><span class="lineCov">        660 :     if (server.lua_client == NULL) {</span>
<span class="lineNum">    1073 </span><span class="lineCov">        656 :         server.lua_client = createClient(-1);</span>
<span class="lineNum">    1074 </span><span class="lineCov">        656 :         server.lua_client-&gt;flags |= CLIENT_LUA;</span>
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span>            :     /* Lua beginners often don't use &quot;local&quot;, this is likely to introduce
<span class="lineNum">    1078 </span>            :      * subtle bugs in their code. To prevent problems we protect accesses
<span class="lineNum">    1079 </span>            :      * to global variables. */
<span class="lineNum">    1080 </span><span class="lineCov">        660 :     scriptingEnableGlobalsProtection(lua);</span>
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineCov">        660 :     server.lua = lua;</span>
<span class="lineNum">    1083 </span><span class="lineCov">        660 : }</span>
<span class="lineNum">    1084 </span>            : 
<a name="1085"><span class="lineNum">    1085 </span>            : /* Release resources related to Lua scripting.</a>
<span class="lineNum">    1086 </span>            :  * This function is used in order to reset the scripting environment. */
<span class="lineNum">    1087 </span><span class="lineCov">          4 : void scriptingRelease(void) {</span>
<span class="lineNum">    1088 </span><span class="lineCov">          4 :     dictRelease(server.lua_scripts);</span>
<span class="lineNum">    1089 </span><span class="lineCov">          4 :     server.lua_scripts_mem = 0;</span>
<span class="lineNum">    1090 </span><span class="lineCov">          4 :     lua_close(server.lua);</span>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineCov">          4 : }</span></a>
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 : void scriptingReset(void) {</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :     scriptingRelease();</span>
<span class="lineNum">    1095 </span><span class="lineCov">          4 :     scriptingInit(0);</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1097 </span>            : 
<a name="1098"><span class="lineNum">    1098 </span>            : /* Set an array of Redis String Objects as a Lua array (table) stored into a</a>
<span class="lineNum">    1099 </span>            :  * global variable. */
<span class="lineNum">    1100 </span><span class="lineCov">    1280680 : void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {</span>
<span class="lineNum">    1101 </span><span class="lineCov">    1280680 :     int j;</span>
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">    1280680 :     lua_newtable(lua);</span>
<span class="lineNum">    1104 </span><span class="lineCov">    1320881 :     for (j = 0; j &lt; elec; j++) {</span>
<span class="lineNum">    1105 </span><span class="lineCov">      80402 :         lua_pushlstring(lua,(char*)elev[j]-&gt;ptr,sdslen(elev[j]-&gt;ptr));</span>
<span class="lineNum">    1106 </span><span class="lineCov">      40201 :         lua_rawseti(lua,-2,j+1);</span>
<span class="lineNum">    1107 </span>            :     }
<span class="lineNum">    1108 </span><span class="lineCov">    1280680 :     lua_setglobal(lua,var);</span>
<span class="lineNum">    1109 </span><span class="lineCov">    1280680 : }</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">    1112 </span>            :  * Redis provided math.random
<span class="lineNum">    1113 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span>            : /* We replace math.random() with our implementation that is not affected
<span class="lineNum">    1116 </span>            :  * by specific libc random() implementations and will output the same sequence
<span class="lineNum">    1117 </span>            :  * (for the same seed) in every arch. */
<span class="lineNum">    1118 </span>            : 
<a name="1119"><span class="lineNum">    1119 </span>            : /* The following implementation is the one shipped with Lua itself but with</a>
<span class="lineNum">    1120 </span>            :  * rand() replaced by redisLrand48(). */
<span class="lineNum">    1121 </span><span class="lineCov">         24 : int redis_math_random (lua_State *L) {</span>
<span class="lineNum">    1122 </span>            :   /* the `%' avoids the (rare) case of r==1, and is needed also because on
<span class="lineNum">    1123 </span>            :      some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
<span class="lineNum">    1124 </span><span class="lineCov">         24 :   lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /</span>
<span class="lineNum">    1125 </span>            :                                 (lua_Number)REDIS_LRAND48_MAX;
<span class="lineNum">    1126 </span><span class="lineCov">         24 :   switch (lua_gettop(L)) {  /* check number of arguments */</span>
<span class="lineNum">    1127 </span><span class="lineCov">         24 :     case 0: {  /* no arguments */</span>
<span class="lineNum">    1128 </span><span class="lineCov">         24 :       lua_pushnumber(L, r);  /* Number between 0 and 1 */</span>
<span class="lineNum">    1129 </span><span class="lineCov">         24 :       break;</span>
<span class="lineNum">    1130 </span>            :     }
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     case 1: {  /* only upper limit */</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :       int u = luaL_checkint(L, 1);</span>
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       luaL_argcheck(L, 1&lt;=u, 1, &quot;interval is empty&quot;);</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1136 </span>            :     }
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :     case 2: {  /* lower and upper limits */</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :       int l = luaL_checkint(L, 1);</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :       int u = luaL_checkint(L, 2);</span>
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :       luaL_argcheck(L, l&lt;=u, 2, &quot;interval is empty&quot;);</span>
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :       lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1143 </span>            :     }
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :     default: return luaL_error(L, &quot;wrong number of arguments&quot;);</span>
<span class="lineNum">    1145 </span>            :   }
<span class="lineNum">    1146 </span>            :   return 1;
<a name="1147"><span class="lineNum">    1147 </span>            : }</a>
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineCov">         12 : int redis_math_randomseed (lua_State *L) {</span>
<span class="lineNum">    1150 </span><span class="lineCov">         12 :   redisSrand48(luaL_checkint(L, 1));</span>
<span class="lineNum">    1151 </span><span class="lineCov">         12 :   return 0;</span>
<span class="lineNum">    1152 </span>            : }
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">    1155 </span>            :  * EVAL and SCRIPT commands implementation
<span class="lineNum">    1156 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : /* Define a Lua function with the specified body.
<span class="lineNum">    1159 </span>            :  * The function name will be generated in the following form:
<span class="lineNum">    1160 </span>            :  *
<span class="lineNum">    1161 </span>            :  *   f_&lt;hex sha1 sum&gt;
<span class="lineNum">    1162 </span>            :  *
<span class="lineNum">    1163 </span>            :  * The function increments the reference count of the 'body' object as a
<span class="lineNum">    1164 </span>            :  * side effect of a successful call.
<span class="lineNum">    1165 </span>            :  *
<span class="lineNum">    1166 </span>            :  * On success a pointer to an SDS string representing the function SHA1 of the
<span class="lineNum">    1167 </span>            :  * just added function is returned (and will be valid until the next call
<span class="lineNum">    1168 </span>            :  * to scriptingReset() function), otherwise NULL is returned.
<span class="lineNum">    1169 </span>            :  *
<span class="lineNum">    1170 </span>            :  * The function handles the fact of being called with a script that already
<span class="lineNum">    1171 </span>            :  * exists, and in such a case, it behaves like in the success case.
<span class="lineNum">    1172 </span>            :  *
<a name="1173"><span class="lineNum">    1173 </span>            :  * If 'c' is not NULL, on error the client is informed with an appropriate</a>
<span class="lineNum">    1174 </span>            :  * error describing the nature of the problem and the Lua interpreter error. */
<span class="lineNum">    1175 </span><span class="lineCov">     420273 : sds luaCreateFunction(client *c, lua_State *lua, robj *body) {</span>
<span class="lineNum">    1176 </span><span class="lineCov">     420273 :     char funcname[43];</span>
<span class="lineNum">    1177 </span><span class="lineCov">     420273 :     dictEntry *de;</span>
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span><span class="lineCov">     420273 :     funcname[0] = 'f';</span>
<span class="lineNum">    1180 </span><span class="lineCov">     420273 :     funcname[1] = '_';</span>
<span class="lineNum">    1181 </span><span class="lineCov">     840546 :     sha1hex(funcname+2,body-&gt;ptr,sdslen(body-&gt;ptr));</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineCov">     420273 :     sds sha = sdsnewlen(funcname+2,40);</span>
<span class="lineNum">    1184 </span><span class="lineCov">     420273 :     if ((de = dictFind(server.lua_scripts,sha)) != NULL) {</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :         sdsfree(sha);</span>
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         return dictGetKey(de);</span>
<span class="lineNum">    1187 </span>            :     }
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span><span class="lineCov">     420273 :     sds funcdef = sdsempty();</span>
<span class="lineNum">    1190 </span><span class="lineCov">     420273 :     funcdef = sdscat(funcdef,&quot;function &quot;);</span>
<span class="lineNum">    1191 </span><span class="lineCov">     420273 :     funcdef = sdscatlen(funcdef,funcname,42);</span>
<span class="lineNum">    1192 </span><span class="lineCov">     420273 :     funcdef = sdscatlen(funcdef,&quot;() &quot;,3);</span>
<span class="lineNum">    1193 </span><span class="lineCov">     840546 :     funcdef = sdscatlen(funcdef,body-&gt;ptr,sdslen(body-&gt;ptr));</span>
<span class="lineNum">    1194 </span><span class="lineCov">     420273 :     funcdef = sdscatlen(funcdef,&quot;\nend&quot;,4);</span>
<span class="lineNum">    1195 </span>            : 
<span class="lineNum">    1196 </span><span class="lineCov">     840546 :     if (luaL_loadbuffer(lua,funcdef,sdslen(funcdef),&quot;@user_script&quot;)) {</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :         if (c != NULL) {</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :             addReplyErrorFormat(c,</span>
<span class="lineNum">    1199 </span>            :                 &quot;Error compiling script (new function): %s\n&quot;,
<span class="lineNum">    1200 </span>            :                 lua_tostring(lua,-1));
<span class="lineNum">    1201 </span>            :         }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         sdsfree(sha);</span>
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         sdsfree(funcdef);</span>
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1206 </span>            :     }
<span class="lineNum">    1207 </span><span class="lineCov">     420273 :     sdsfree(funcdef);</span>
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineCov">     420273 :     if (lua_pcall(lua,0,0,0)) {</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :         if (c != NULL) {</span>
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :             addReplyErrorFormat(c,&quot;Error running script (new function): %s\n&quot;,</span>
<span class="lineNum">    1212 </span>            :                 lua_tostring(lua,-1));
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :         sdsfree(sha);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    1217 </span>            :     }
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :     /* We also save a SHA1 -&gt; Original script map in a dictionary
<span class="lineNum">    1220 </span>            :      * so that we can replicate / write in the AOF all the
<span class="lineNum">    1221 </span>            :      * EVALSHA commands as EVAL using the original script. */
<span class="lineNum">    1222 </span><span class="lineCov">     420273 :     int retval = dictAdd(server.lua_scripts,sha,body);</span>
<span class="lineNum">    1223 </span><span class="lineCov">     420273 :     serverAssertWithInfo(c ? c : server.lua_client,NULL,retval == DICT_OK);</span>
<span class="lineNum">    1224 </span><span class="lineCov">     420273 :     server.lua_scripts_mem += sdsZmallocSize(sha) + getStringObjectSdsUsedMemory(body);</span>
<span class="lineNum">    1225 </span><span class="lineCov">     420273 :     incrRefCount(body);</span>
<span class="lineNum">    1226 </span><span class="lineCov">     420273 :     return sha;</span>
<span class="lineNum">    1227 </span>            : }
<a name="1228"><span class="lineNum">    1228 </span>            : </a>
<span class="lineNum">    1229 </span>            : /* This is the Lua script &quot;count&quot; hook that we use to detect scripts timeout. */
<span class="lineNum">    1230 </span><span class="lineCov">      92680 : void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {</span>
<span class="lineNum">    1231 </span><span class="lineCov">      92680 :     long long elapsed = mstime() - server.lua_time_start;</span>
<span class="lineNum">    1232 </span><span class="lineCov">      92680 :     UNUSED(ar);</span>
<span class="lineNum">    1233 </span><span class="lineCov">      92680 :     UNUSED(lua);</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span>            :     /* Set the timeout condition if not already set and the maximum
<span class="lineNum">    1236 </span>            :      * execution time was reached. */
<span class="lineNum">    1237 </span><span class="lineCov">      92680 :     if (elapsed &gt;= server.lua_time_limit &amp;&amp; server.lua_timedout == 0) {</span>
<span class="lineNum">    1238 </span><span class="lineCov">          9 :         serverLog(LL_WARNING,&quot;Lua slow script detected: still in execution after %lld milliseconds. You can try killing the script using the SCRIPT KILL command.&quot;,elapsed);</span>
<span class="lineNum">    1239 </span><span class="lineCov">          9 :         server.lua_timedout = 1;</span>
<span class="lineNum">    1240 </span>            :         /* Once the script timeouts we reenter the event loop to permit others
<span class="lineNum">    1241 </span>            :          * to call SCRIPT KILL or SHUTDOWN NOSAVE if needed. For this reason
<span class="lineNum">    1242 </span>            :          * we need to mask the client executing the script from the event loop.
<span class="lineNum">    1243 </span>            :          * If we don't do that the client may disconnect and could no longer be
<span class="lineNum">    1244 </span>            :          * here when the EVAL command will return. */
<span class="lineNum">    1245 </span><span class="lineCov">          9 :         protectClient(server.lua_caller);</span>
<span class="lineNum">    1246 </span>            :     }
<span class="lineNum">    1247 </span><span class="lineCov">      92680 :     if (server.lua_timedout) processEventsWhileBlocked();</span>
<span class="lineNum">    1248 </span><span class="lineCov">      92678 :     if (server.lua_kill) {</span>
<span class="lineNum">    1249 </span><span class="lineCov">          2 :         serverLog(LL_WARNING,&quot;Lua script killed by user with SCRIPT KILL.&quot;);</span>
<span class="lineNum">    1250 </span><span class="lineCov">          2 :         lua_pushstring(lua,&quot;Script killed by user with SCRIPT KILL...&quot;);</span>
<span class="lineNum">    1251 </span><span class="lineCov">          2 :         lua_error(lua);</span>
<span class="lineNum">    1252 </span>            :     }
<a name="1253"><span class="lineNum">    1253 </span><span class="lineCov">      92676 : }</span></a>
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineCov">     640350 : void evalGenericCommand(client *c, int evalsha) {</span>
<span class="lineNum">    1256 </span><span class="lineCov">     640350 :     lua_State *lua = server.lua;</span>
<span class="lineNum">    1257 </span><span class="lineCov">     640350 :     char funcname[43];</span>
<span class="lineNum">    1258 </span><span class="lineCov">     640350 :     long long numkeys;</span>
<span class="lineNum">    1259 </span><span class="lineCov">     640350 :     long long initial_server_dirty = server.dirty;</span>
<span class="lineNum">    1260 </span><span class="lineCov">     640350 :     int delhook = 0, err;</span>
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span>            :     /* When we replicate whole scripts, we want the same PRNG sequence at
<span class="lineNum">    1263 </span>            :      * every call so that our PRNG is not affected by external state. */
<span class="lineNum">    1264 </span><span class="lineCov">     640350 :     redisSrand48(0);</span>
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            :     /* We set this flag to zero to remember that so far no random command
<span class="lineNum">    1267 </span>            :      * was called. This way we can allow the user to call commands like
<span class="lineNum">    1268 </span>            :      * SRANDMEMBER or RANDOMKEY from Lua scripts as far as no write command
<span class="lineNum">    1269 </span>            :      * is called (otherwise the replication and AOF would end with non
<span class="lineNum">    1270 </span>            :      * deterministic sequences).
<span class="lineNum">    1271 </span>            :      *
<span class="lineNum">    1272 </span>            :      * Thanks to this flag we'll raise an error every time a write command
<span class="lineNum">    1273 </span>            :      * is called after a random command was used. */
<span class="lineNum">    1274 </span><span class="lineCov">     640350 :     server.lua_random_dirty = 0;</span>
<span class="lineNum">    1275 </span><span class="lineCov">     640350 :     server.lua_write_dirty = 0;</span>
<span class="lineNum">    1276 </span><span class="lineCov">     640350 :     server.lua_replicate_commands = server.lua_always_replicate_commands;</span>
<span class="lineNum">    1277 </span><span class="lineCov">     640350 :     server.lua_multi_emitted = 0;</span>
<span class="lineNum">    1278 </span><span class="lineCov">     640350 :     server.lua_repl = PROPAGATE_AOF|PROPAGATE_REPL;</span>
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            :     /* Get the number of arguments that are keys */
<span class="lineNum">    1281 </span><span class="lineCov">     640350 :     if (getLongLongFromObjectOrReply(c,c-&gt;argv[2],&amp;numkeys,NULL) != C_OK)</span>
<span class="lineNum">    1282 </span><span class="lineCov">         10 :         return;</span>
<span class="lineNum">    1283 </span><span class="lineCov">     640350 :     if (numkeys &gt; (c-&gt;argc - 3)) {</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :         addReplyError(c,&quot;Number of keys can't be greater than number of args&quot;);</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1286 </span><span class="lineCov">     640350 :     } else if (numkeys &lt; 0) {</span>
<span class="lineNum">    1287 </span><span class="lineCov">          2 :         addReplyError(c,&quot;Number of keys can't be negative&quot;);</span>
<span class="lineNum">    1288 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">    1289 </span>            :     }
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            :     /* We obtain the script SHA1, then check if this function is already
<span class="lineNum">    1292 </span>            :      * defined into the Lua state */
<span class="lineNum">    1293 </span><span class="lineCov">     640348 :     funcname[0] = 'f';</span>
<span class="lineNum">    1294 </span><span class="lineCov">     640348 :     funcname[1] = '_';</span>
<span class="lineNum">    1295 </span><span class="lineCov">     640348 :     if (!evalsha) {</span>
<span class="lineNum">    1296 </span>            :         /* Hash the code if this is an EVAL call */
<span class="lineNum">    1297 </span><span class="lineCov">     680586 :         sha1hex(funcname+2,c-&gt;argv[1]-&gt;ptr,sdslen(c-&gt;argv[1]-&gt;ptr));</span>
<span class="lineNum">    1298 </span>            :     } else {
<span class="lineNum">    1299 </span>            :         /* We already have the SHA if it is a EVALSHA */
<span class="lineNum">    1300 </span><span class="lineCov">     300055 :         int j;</span>
<span class="lineNum">    1301 </span><span class="lineCov">     300055 :         char *sha = c-&gt;argv[1]-&gt;ptr;</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span>            :         /* Convert to lowercase. We don't use tolower since the function
<span class="lineNum">    1304 </span>            :          * managed to always show up in the profiler output consuming
<span class="lineNum">    1305 </span>            :          * a non trivial amount of time. */
<span class="lineNum">    1306 </span><span class="lineCov">   12302255 :         for (j = 0; j &lt; 40; j++)</span>
<span class="lineNum">    1307 </span><span class="lineCov">   12002264 :             funcname[j+2] = (sha[j] &gt;= 'A' &amp;&amp; sha[j] &lt;= 'Z') ?</span>
<span class="lineNum">    1308 </span><span class="lineCov">         64 :                 sha[j]+('a'-'A') : sha[j];</span>
<span class="lineNum">    1309 </span><span class="lineCov">     300055 :         funcname[42] = '\0';</span>
<span class="lineNum">    1310 </span>            :     }
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span>            :     /* Push the pcall error handler function on the stack. */
<span class="lineNum">    1313 </span><span class="lineCov">     640348 :     lua_getglobal(lua, &quot;__redis__err__handler&quot;);</span>
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span>            :     /* Try to lookup the Lua function */
<span class="lineNum">    1316 </span><span class="lineCov">     640348 :     lua_getglobal(lua, funcname);</span>
<span class="lineNum">    1317 </span><span class="lineCov">     640348 :     if (lua_isnil(lua,-1)) {</span>
<span class="lineNum">    1318 </span><span class="lineCov">     300269 :         lua_pop(lua,1); /* remove the nil from the stack */</span>
<span class="lineNum">    1319 </span>            :         /* Function not defined... let's define it if we have the
<span class="lineNum">    1320 </span>            :          * body of the function. If this is an EVALSHA call we can just
<span class="lineNum">    1321 </span>            :          * return an error. */
<span class="lineNum">    1322 </span><span class="lineCov">     300269 :         if (evalsha) {</span>
<span class="lineNum">    1323 </span><span class="lineCov">          8 :             lua_pop(lua,1); /* remove the error handler from the stack. */</span>
<span class="lineNum">    1324 </span><span class="lineCov">          8 :             addReply(c, shared.noscripterr);</span>
<span class="lineNum">    1325 </span><span class="lineCov">          8 :             return;</span>
<span class="lineNum">    1326 </span>            :         }
<span class="lineNum">    1327 </span><span class="lineCov">     300261 :         if (luaCreateFunction(c,lua,c-&gt;argv[1]) == NULL) {</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             lua_pop(lua,1); /* remove the error handler from the stack. */</span>
<span class="lineNum">    1329 </span>            :             /* The error is sent to the client by luaCreateFunction()
<span class="lineNum">    1330 </span>            :              * itself when it returns NULL. */
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1332 </span>            :         }
<span class="lineNum">    1333 </span>            :         /* Now the following is guaranteed to return non nil */
<span class="lineNum">    1334 </span><span class="lineCov">     300261 :         lua_getglobal(lua, funcname);</span>
<span class="lineNum">    1335 </span><span class="lineCov">     300261 :         serverAssert(!lua_isnil(lua,-1));</span>
<span class="lineNum">    1336 </span>            :     }
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :     /* Populate the argv and keys table accordingly to the arguments that
<span class="lineNum">    1339 </span>            :      * EVAL received. */
<span class="lineNum">    1340 </span><span class="lineCov">     640340 :     luaSetGlobalArray(lua,&quot;KEYS&quot;,c-&gt;argv+3,numkeys);</span>
<span class="lineNum">    1341 </span><span class="lineCov">     640340 :     luaSetGlobalArray(lua,&quot;ARGV&quot;,c-&gt;argv+3+numkeys,c-&gt;argc-3-numkeys);</span>
<span class="lineNum">    1342 </span>            : 
<span class="lineNum">    1343 </span>            :     /* Select the right DB in the context of the Lua client */
<span class="lineNum">    1344 </span><span class="lineCov">     640340 :     selectDb(server.lua_client,c-&gt;db-&gt;id);</span>
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :     /* Set a hook in order to be able to stop the script execution if it
<span class="lineNum">    1347 </span>            :      * is running for too much time.
<span class="lineNum">    1348 </span>            :      * We set the hook only if the time limit is enabled as the hook will
<span class="lineNum">    1349 </span>            :      * make the Lua script execution slower.
<span class="lineNum">    1350 </span>            :      *
<span class="lineNum">    1351 </span>            :      * If we are debugging, we set instead a &quot;line&quot; hook so that the
<span class="lineNum">    1352 </span>            :      * debugger is call-back at every line executed by the script. */
<span class="lineNum">    1353 </span><span class="lineCov">     640340 :     server.lua_caller = c;</span>
<span class="lineNum">    1354 </span><span class="lineCov">     640340 :     server.lua_time_start = mstime();</span>
<span class="lineNum">    1355 </span><span class="lineCov">     640340 :     server.lua_kill = 0;</span>
<span class="lineNum">    1356 </span><span class="lineCov">     640340 :     if (server.lua_time_limit &gt; 0 &amp;&amp; ldb.active == 0) {</span>
<span class="lineNum">    1357 </span><span class="lineCov">     640340 :         lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);</span>
<span class="lineNum">    1358 </span><span class="lineCov">     640340 :         delhook = 1;</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :     } else if (ldb.active) {</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         lua_sethook(server.lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);</span>
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :         delhook = 1;</span>
<span class="lineNum">    1362 </span>            :     }
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :     /* At this point whether this script was never seen before or if it was
<span class="lineNum">    1365 </span>            :      * already defined, we can call it. We have zero arguments and expect
<span class="lineNum">    1366 </span>            :      * a single return value. */
<span class="lineNum">    1367 </span><span class="lineCov">     640340 :     err = lua_pcall(lua,0,1,-2);</span>
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span>            :     /* Perform some cleanup that we need to do both on error and success. */
<span class="lineNum">    1370 </span><span class="lineCov">     640338 :     if (delhook) lua_sethook(lua,NULL,0,0); /* Disable hook */</span>
<span class="lineNum">    1371 </span><span class="lineCov">     640338 :     if (server.lua_timedout) {</span>
<span class="lineNum">    1372 </span><span class="lineCov">          7 :         server.lua_timedout = 0;</span>
<span class="lineNum">    1373 </span>            :         /* Restore the client that was protected when the script timeout
<span class="lineNum">    1374 </span>            :          * was detected. */
<span class="lineNum">    1375 </span><span class="lineCov">          7 :         unprotectClient(c);</span>
<span class="lineNum">    1376 </span><span class="lineCov">          7 :         if (server.masterhost &amp;&amp; server.master)</span>
<span class="lineNum">    1377 </span><span class="lineCov">          3 :             queueClientForReprocessing(server.master);</span>
<span class="lineNum">    1378 </span>            :     }
<span class="lineNum">    1379 </span><span class="lineCov">     640338 :     server.lua_caller = NULL;</span>
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :     /* Call the Lua garbage collector from time to time to avoid a
<span class="lineNum">    1382 </span>            :      * full cycle performed by Lua, which adds too latency.
<span class="lineNum">    1383 </span>            :      *
<span class="lineNum">    1384 </span>            :      * The call is performed every LUA_GC_CYCLE_PERIOD executed commands
<span class="lineNum">    1385 </span>            :      * (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it
<span class="lineNum">    1386 </span>            :      * for every command uses too much CPU. */
<span class="lineNum">    1387 </span>            :     #define LUA_GC_CYCLE_PERIOD 50
<span class="lineNum">    1388 </span>            :     {
<span class="lineNum">    1389 </span><span class="lineCov">     640338 :         static long gc_count = 0;</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineCov">     640338 :         gc_count++;</span>
<span class="lineNum">    1392 </span><span class="lineCov">     640338 :         if (gc_count == LUA_GC_CYCLE_PERIOD) {</span>
<span class="lineNum">    1393 </span><span class="lineCov">      12804 :             lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);</span>
<span class="lineNum">    1394 </span><span class="lineCov">      12804 :             gc_count = 0;</span>
<span class="lineNum">    1395 </span>            :         }
<span class="lineNum">    1396 </span>            :     }
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span><span class="lineCov">     640338 :     if (err) {</span>
<span class="lineNum">    1399 </span><span class="lineCov">         44 :         addReplyErrorFormat(c,&quot;Error running script (call to %s): %s\n&quot;,</span>
<span class="lineNum">    1400 </span>            :             funcname, lua_tostring(lua,-1));
<span class="lineNum">    1401 </span><span class="lineCov">         44 :         lua_pop(lua,2); /* Consume the Lua reply and remove error handler. */</span>
<span class="lineNum">    1402 </span>            :     } else {
<span class="lineNum">    1403 </span>            :         /* On success convert the Lua return value into Redis protocol, and
<span class="lineNum">    1404 </span>            :          * send it to * the client. */
<span class="lineNum">    1405 </span><span class="lineCov">     640294 :         luaReplyToRedisReply(c,lua); /* Convert and consume the reply. */</span>
<span class="lineNum">    1406 </span><span class="lineCov">     640294 :         lua_pop(lua,1); /* Remove the error handler. */</span>
<span class="lineNum">    1407 </span>            :     }
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            :     /* If we are using single commands replication, emit EXEC if there
<span class="lineNum">    1410 </span>            :      * was at least a write. */
<span class="lineNum">    1411 </span><span class="lineCov">     640338 :     if (server.lua_replicate_commands) {</span>
<span class="lineNum">    1412 </span><span class="lineCov">     640328 :         preventCommandPropagation(c);</span>
<span class="lineNum">    1413 </span><span class="lineCov">     640328 :         if (server.lua_multi_emitted) {</span>
<span class="lineNum">    1414 </span><span class="lineCov">     490128 :             robj *propargv[1];</span>
<span class="lineNum">    1415 </span><span class="lineCov">     490128 :             propargv[0] = createStringObject(&quot;EXEC&quot;,4);</span>
<span class="lineNum">    1416 </span><span class="lineCov">     490128 :             alsoPropagate(server.execCommand,c-&gt;db-&gt;id,propargv,1,</span>
<span class="lineNum">    1417 </span>            :                 PROPAGATE_AOF|PROPAGATE_REPL);
<span class="lineNum">    1418 </span><span class="lineCov">     490128 :             decrRefCount(propargv[0]);</span>
<span class="lineNum">    1419 </span>            :         }
<span class="lineNum">    1420 </span>            :     }
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            :     /* EVALSHA should be propagated to Slave and AOF file as full EVAL, unless
<span class="lineNum">    1423 </span>            :      * we are sure that the script was already in the context of all the
<span class="lineNum">    1424 </span>            :      * attached slaves *and* the current AOF file if enabled.
<span class="lineNum">    1425 </span>            :      *
<span class="lineNum">    1426 </span>            :      * To do so we use a cache of SHA1s of scripts that we already propagated
<span class="lineNum">    1427 </span>            :      * as full EVAL, that's called the Replication Script Cache.
<span class="lineNum">    1428 </span>            :      *
<span class="lineNum">    1429 </span>            :      * For repliation, everytime a new slave attaches to the master, we need to
<span class="lineNum">    1430 </span>            :      * flush our cache of scripts that can be replicated as EVALSHA, while
<span class="lineNum">    1431 </span>            :      * for AOF we need to do so every time we rewrite the AOF file. */
<span class="lineNum">    1432 </span><span class="lineCov">     640338 :     if (evalsha &amp;&amp; !server.lua_replicate_commands) {</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :         if (!replicationScriptCacheExists(c-&gt;argv[1]-&gt;ptr)) {</span>
<span class="lineNum">    1434 </span>            :             /* This script is not in our script cache, replicate it as
<span class="lineNum">    1435 </span>            :              * EVAL, then add it into the script cache, as from now on
<span class="lineNum">    1436 </span>            :              * slaves and AOF know about it. */
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :             robj *script = dictFetchValue(server.lua_scripts,c-&gt;argv[1]-&gt;ptr);</span>
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :             replicationScriptCacheAdd(c-&gt;argv[1]-&gt;ptr);</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :             serverAssertWithInfo(c,NULL,script != NULL);</span>
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span>            :             /* If the script did not produce any changes in the dataset we want
<span class="lineNum">    1443 </span>            :              * just to replicate it as SCRIPT LOAD, otherwise we risk running
<span class="lineNum">    1444 </span>            :              * an aborted script on slaves (that may then produce results there)
<span class="lineNum">    1445 </span>            :              * or just running a CPU costly read-only script on the slaves. */
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :             if (server.dirty == initial_server_dirty) {</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :                 rewriteClientCommandVector(c,3,</span>
<span class="lineNum">    1448 </span>            :                     resetRefCount(createStringObject(&quot;SCRIPT&quot;,6)),
<span class="lineNum">    1449 </span>            :                     resetRefCount(createStringObject(&quot;LOAD&quot;,4)),
<span class="lineNum">    1450 </span>            :                     script);
<span class="lineNum">    1451 </span>            :             } else {
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :                 rewriteClientCommandArgument(c,0,</span>
<span class="lineNum">    1453 </span>            :                     resetRefCount(createStringObject(&quot;EVAL&quot;,4)));
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :                 rewriteClientCommandArgument(c,1,script);</span>
<span class="lineNum">    1455 </span>            :             }
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :             forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);</span>
<span class="lineNum">    1457 </span>            :         }
<span class="lineNum">    1458 </span>            :     }
<a name="1459"><span class="lineNum">    1459 </span>            : }</a>
<span class="lineNum">    1460 </span>            : 
<span class="lineNum">    1461 </span><span class="lineCov">     340295 : void evalCommand(client *c) {</span>
<span class="lineNum">    1462 </span><span class="lineCov">     340295 :     if (!(c-&gt;flags &amp; CLIENT_LUA_DEBUG))</span>
<span class="lineNum">    1463 </span><span class="lineCov">     340295 :         evalGenericCommand(c,0);</span>
<span class="lineNum">    1464 </span>            :     else
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :         evalGenericCommandWithDebugging(c,0);</span>
<a name="1466"><span class="lineNum">    1466 </span><span class="lineCov">     340293 : }</span></a>
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineCov">     300059 : void evalShaCommand(client *c) {</span>
<span class="lineNum">    1469 </span><span class="lineCov">     600118 :     if (sdslen(c-&gt;argv[1]-&gt;ptr) != 40) {</span>
<span class="lineNum">    1470 </span>            :         /* We know that a match is not possible if the provided SHA is
<span class="lineNum">    1471 </span>            :          * not the right length. So we return an error ASAP, this way
<span class="lineNum">    1472 </span>            :          * evalGenericCommand() can be implemented without string length
<span class="lineNum">    1473 </span>            :          * sanity check */
<span class="lineNum">    1474 </span><span class="lineCov">          4 :         addReply(c, shared.noscripterr);</span>
<span class="lineNum">    1475 </span><span class="lineCov">          4 :         return;</span>
<span class="lineNum">    1476 </span>            :     }
<span class="lineNum">    1477 </span><span class="lineCov">     300055 :     if (!(c-&gt;flags &amp; CLIENT_LUA_DEBUG))</span>
<span class="lineNum">    1478 </span><span class="lineCov">     300055 :         evalGenericCommand(c,1);</span>
<span class="lineNum">    1479 </span>            :     else {
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :         addReplyError(c,&quot;Please use EVAL instead of EVALSHA for debugging&quot;);</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    1482 </span>            :     }
<a name="1483"><span class="lineNum">    1483 </span>            : }</a>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">         16 : void scriptCommand(client *c) {</span>
<span class="lineNum">    1486 </span><span class="lineCov">         16 :     if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :         const char *help[] = {</span>
<span class="lineNum">    1488 </span>            : &quot;DEBUG (yes|sync|no) -- Set the debug mode for subsequent scripts executed.&quot;,
<span class="lineNum">    1489 </span>            : &quot;EXISTS &lt;sha1&gt; [&lt;sha1&gt; ...] -- Return information about the existence of the scripts in the script cache.&quot;,
<span class="lineNum">    1490 </span>            : &quot;FLUSH -- Flush the Lua scripts cache. Very dangerous on replicas.&quot;,
<span class="lineNum">    1491 </span>            : &quot;KILL -- Kill the currently executing Lua script.&quot;,
<span class="lineNum">    1492 </span>            : &quot;LOAD &lt;script&gt; -- Load a script into the scripts cache, without executing it.&quot;,
<span class="lineNum">    1493 </span>            : NULL
<span class="lineNum">    1494 </span>            :         };
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         addReplyHelp(c, help);</span>
<span class="lineNum">    1496 </span><span class="lineCov">         16 :     } else if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;flush&quot;)) {</span>
<span class="lineNum">    1497 </span><span class="lineCov">          4 :         scriptingReset();</span>
<span class="lineNum">    1498 </span><span class="lineCov">          4 :         addReply(c,shared.ok);</span>
<span class="lineNum">    1499 </span><span class="lineCov">          4 :         replicationScriptCacheFlush();</span>
<span class="lineNum">    1500 </span><span class="lineCov">          4 :         server.dirty++; /* Propagating this command is a good idea. */</span>
<span class="lineNum">    1501 </span><span class="lineCov">         12 :     } else if (c-&gt;argc &gt;= 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;exists&quot;)) {</span>
<span class="lineNum">    1502 </span><span class="lineCov">          4 :         int j;</span>
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineCov">          4 :         addReplyMultiBulkLen(c, c-&gt;argc-2);</span>
<span class="lineNum">    1505 </span><span class="lineCov">         12 :         for (j = 2; j &lt; c-&gt;argc; j++) {</span>
<span class="lineNum">    1506 </span><span class="lineCov">          8 :             if (dictFind(server.lua_scripts,c-&gt;argv[j]-&gt;ptr))</span>
<span class="lineNum">    1507 </span><span class="lineCov">          4 :                 addReply(c,shared.cone);</span>
<span class="lineNum">    1508 </span>            :             else
<span class="lineNum">    1509 </span><span class="lineCov">          4 :                 addReply(c,shared.czero);</span>
<span class="lineNum">    1510 </span>            :         }
<span class="lineNum">    1511 </span><span class="lineCov">         12 :     } else if (c-&gt;argc == 3 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;load&quot;)) {</span>
<span class="lineNum">    1512 </span><span class="lineCov">          4 :         sds sha = luaCreateFunction(c,server.lua,c-&gt;argv[2]);</span>
<span class="lineNum">    1513 </span><span class="lineCov">          4 :         if (sha == NULL) return; /* The error was sent by luaCreateFunction(). */</span>
<span class="lineNum">    1514 </span><span class="lineCov">          4 :         addReplyBulkCBuffer(c,sha,40);</span>
<span class="lineNum">    1515 </span><span class="lineCov">          4 :         forceCommandPropagation(c,PROPAGATE_REPL|PROPAGATE_AOF);</span>
<span class="lineNum">    1516 </span><span class="lineCov">          4 :     } else if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;kill&quot;)) {</span>
<span class="lineNum">    1517 </span><span class="lineCov">          4 :         if (server.lua_caller == NULL) {</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :             addReplySds(c,sdsnew(&quot;-NOTBUSY No scripts in execution right now.\r\n&quot;));</span>
<span class="lineNum">    1519 </span><span class="lineCov">          4 :         } else if (server.lua_caller-&gt;flags &amp; CLIENT_MASTER) {</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :             addReplySds(c,sdsnew(&quot;-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed.\r\n&quot;));</span>
<span class="lineNum">    1521 </span><span class="lineCov">          4 :         } else if (server.lua_write_dirty) {</span>
<span class="lineNum">    1522 </span><span class="lineCov">          2 :             addReplySds(c,sdsnew(&quot;-UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.\r\n&quot;));</span>
<span class="lineNum">    1523 </span>            :         } else {
<span class="lineNum">    1524 </span><span class="lineCov">          2 :             server.lua_kill = 1;</span>
<span class="lineNum">    1525 </span><span class="lineCov">          2 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1526 </span>            :         }
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :     } else if (c-&gt;argc == 3 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;debug&quot;)) {</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         if (clientHasPendingReplies(c)) {</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;SCRIPT DEBUG must be called outside a pipeline&quot;);</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1531 </span>            :         }
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;no&quot;)) {</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :             ldbDisable(c);</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;yes&quot;)) {</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :             ldbEnable(c);</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(c-&gt;argv[2]-&gt;ptr,&quot;sync&quot;)) {</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :             ldbEnable(c);</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :             addReply(c,shared.ok);</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :             c-&gt;flags |= CLIENT_LUA_DEBUG_SYNC;</span>
<span class="lineNum">    1542 </span>            :         } else {
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;Use SCRIPT DEBUG yes/sync/no&quot;);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    1545 </span>            :         }
<span class="lineNum">    1546 </span>            :     } else {
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :         addReplySubcommandSyntaxError(c);</span>
<span class="lineNum">    1548 </span>            :     }
<span class="lineNum">    1549 </span>            : }
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            : /* ---------------------------------------------------------------------------
<span class="lineNum">    1552 </span>            :  * LDB: Redis Lua debugging facilities
<span class="lineNum">    1553 </span>            :  * ------------------------------------------------------------------------- */
<a name="1554"><span class="lineNum">    1554 </span>            : </a>
<span class="lineNum">    1555 </span>            : /* Initialize Lua debugger data structures. */
<span class="lineNum">    1556 </span><span class="lineCov">        656 : void ldbInit(void) {</span>
<span class="lineNum">    1557 </span><span class="lineCov">        656 :     ldb.fd = -1;</span>
<span class="lineNum">    1558 </span><span class="lineCov">        656 :     ldb.active = 0;</span>
<span class="lineNum">    1559 </span><span class="lineCov">        656 :     ldb.logs = listCreate();</span>
<span class="lineNum">    1560 </span><span class="lineCov">        656 :     listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);</span>
<span class="lineNum">    1561 </span><span class="lineCov">        656 :     ldb.children = listCreate();</span>
<span class="lineNum">    1562 </span><span class="lineCov">        656 :     ldb.src = NULL;</span>
<span class="lineNum">    1563 </span><span class="lineCov">        656 :     ldb.lines = 0;</span>
<span class="lineNum">    1564 </span><span class="lineCov">        656 :     ldb.cbuf = sdsempty();</span>
<span class="lineNum">    1565 </span><span class="lineCov">        656 : }</span>
<a name="1566"><span class="lineNum">    1566 </span>            : </a>
<span class="lineNum">    1567 </span>            : /* Remove all the pending messages in the specified list. */
<span class="lineNum">    1568 </span><span class="lineNoCov">          0 : void ldbFlushLog(list *log) {</span>
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     listNode *ln;</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     while((ln = listFirst(log)) != NULL)</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :         listDelNode(log,ln);</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 : }</span>
<a name="1574"><span class="lineNum">    1574 </span>            : </a>
<span class="lineNum">    1575 </span>            : /* Enable debug mode of Lua scripts for this client. */
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 : void ldbEnable(client *c) {</span>
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :     c-&gt;flags |= CLIENT_LUA_DEBUG;</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :     ldbFlushLog(ldb.logs);</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :     ldb.fd = c-&gt;fd;</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :     ldb.step = 1;</span>
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :     ldb.bpcount = 0;</span>
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :     ldb.luabp = 0;</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :     sdsfree(ldb.cbuf);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :     ldb.cbuf = sdsempty();</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :     ldb.maxlen = LDB_MAX_LEN_DEFAULT;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :     ldb.maxlen_hint_sent = 0;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            : /* Exit debugging mode from the POV of client. This function is not enough
<a name="1590"><span class="lineNum">    1590 </span>            :  * to properly shut down a client debugging session, see ldbEndSession()</a>
<span class="lineNum">    1591 </span>            :  * for more information. */
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 : void ldbDisable(client *c) {</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :     c-&gt;flags &amp;= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 : }</span>
<a name="1595"><span class="lineNum">    1595 </span>            : </a>
<span class="lineNum">    1596 </span>            : /* Append a log entry to the specified LDB log. */
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 : void ldbLog(sds entry) {</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :     listAddNodeTail(ldb.logs,entry);</span>
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span>            : /* A version of ldbLog() which prevents producing logs greater than
<span class="lineNum">    1602 </span>            :  * ldb.maxlen. The first time the limit is reached an hint is generated
<a name="1603"><span class="lineNum">    1603 </span>            :  * to inform the user that reply trimming can be disabled using the</a>
<span class="lineNum">    1604 </span>            :  * debugger &quot;maxlen&quot; command. */
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 : void ldbLogWithMaxLen(sds entry) {</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :     int trimmed = 0;</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :     if (ldb.maxlen &amp;&amp; sdslen(entry) &gt; ldb.maxlen) {</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :         sdsrange(entry,0,ldb.maxlen-1);</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :         entry = sdscatlen(entry,&quot; ...&quot;,4);</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :         trimmed = 1;</span>
<span class="lineNum">    1611 </span>            :     }
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :     ldbLog(entry);</span>
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :     if (trimmed &amp;&amp; ldb.maxlen_hint_sent == 0) {</span>
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :         ldb.maxlen_hint_sent = 1;</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :         ldbLog(sdsnew(</span>
<span class="lineNum">    1616 </span>            :         &quot;&lt;hint&gt; The above reply was trimmed. Use 'maxlen 0' to disable trimming.&quot;));
<span class="lineNum">    1617 </span>            :     }
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            : /* Send ldb.logs to the debugging client as a multi-bulk reply
<a name="1621"><span class="lineNum">    1621 </span>            :  * consisting of simple strings. Log entries which include newlines have them</a>
<span class="lineNum">    1622 </span>            :  * replaced with spaces. The entries sent are also consumed. */
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 : void ldbSendLogs(void) {</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :     sds proto = sdsempty();</span>
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     proto = sdscatfmt(proto,&quot;*%i\r\n&quot;, (int)listLength(ldb.logs));</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     while(listLength(ldb.logs)) {</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :         listNode *ln = listFirst(ldb.logs);</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :         proto = sdscatlen(proto,&quot;+&quot;,1);</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :         sdsmapchars(ln-&gt;value,&quot;\r\n&quot;,&quot;  &quot;,2);</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :         proto = sdscatsds(proto,ln-&gt;value);</span>
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :         proto = sdscatlen(proto,&quot;\r\n&quot;,2);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :         listDelNode(ldb.logs,ln);</span>
<span class="lineNum">    1633 </span>            :     }
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :     if (write(ldb.fd,proto,sdslen(proto)) == -1) {</span>
<span class="lineNum">    1635 </span>            :         /* Avoid warning. We don't check the return value of write()
<span class="lineNum">    1636 </span>            :          * since the next read() will catch the I/O error and will
<span class="lineNum">    1637 </span>            :          * close the debugging session. */
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :     sdsfree(proto);</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span>            : /* Start a debugging session before calling EVAL implementation.
<span class="lineNum">    1643 </span>            :  * The techique we use is to capture the client socket file descriptor,
<span class="lineNum">    1644 </span>            :  * in order to perform direct I/O with it from within Lua hooks. This
<span class="lineNum">    1645 </span>            :  * way we don't have to re-enter Redis in order to handle I/O.
<span class="lineNum">    1646 </span>            :  *
<span class="lineNum">    1647 </span>            :  * The function returns 1 if the caller should proceed to call EVAL,
<span class="lineNum">    1648 </span>            :  * and 0 if instead the caller should abort the operation (this happens
<span class="lineNum">    1649 </span>            :  * for the parent in a forked session, since it's up to the children
<span class="lineNum">    1650 </span>            :  * to continue, or when fork returned an error).
<span class="lineNum">    1651 </span>            :  *
<a name="1652"><span class="lineNum">    1652 </span>            :  * The caller should call ldbEndSession() only if ldbStartSession()</a>
<span class="lineNum">    1653 </span>            :  * returned 1. */
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 : int ldbStartSession(client *c) {</span>
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :     ldb.forked = (c-&gt;flags &amp; CLIENT_LUA_DEBUG_SYNC) == 0;</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :     if (ldb.forked) {</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :         pid_t cp = fork();</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :         if (cp == -1) {</span>
<span class="lineNum">    1659 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;Fork() failed: can't run EVAL in debugging mode.&quot;);</span>
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :         } else if (cp == 0) {</span>
<span class="lineNum">    1662 </span>            :             /* Child. Let's ignore important signals handled by the parent. */
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :             struct sigaction act;</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :             sigemptyset(&amp;act.sa_mask);</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :             act.sa_flags = 0;</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :             act.sa_handler = SIG_IGN;</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :             sigaction(SIGTERM, &amp;act, NULL);</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :             sigaction(SIGINT, &amp;act, NULL);</span>
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            :             /* Log the creation of the child and close the listening
<span class="lineNum">    1671 </span>            :              * socket to make sure if the parent crashes a reset is sent
<span class="lineNum">    1672 </span>            :              * to the clients. */
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,&quot;Redis forked for debugging eval&quot;);</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :             closeListeningSockets(0);</span>
<span class="lineNum">    1675 </span>            :         } else {
<span class="lineNum">    1676 </span>            :             /* Parent */
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :             listAddNodeTail(ldb.children,(void*)(unsigned long)cp);</span>
<span class="lineNum">    1678 </span><span class="lineNoCov">          0 :             freeClientAsync(c); /* Close the client in the parent side. */</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1680 </span>            :         }
<span class="lineNum">    1681 </span>            :     } else {
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    1683 </span>            :             &quot;Redis synchronous debugging eval session started&quot;);
<span class="lineNum">    1684 </span>            :     }
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span>            :     /* Setup our debugging session. */
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :     anetBlock(NULL,ldb.fd);</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     anetSendTimeout(NULL,ldb.fd,5000);</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :     ldb.active = 1;</span>
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            :     /* First argument of EVAL is the script itself. We split it into different
<span class="lineNum">    1692 </span>            :      * lines since this is the way the debugger accesses the source code. */
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :     sds srcstring = sdsdup(c-&gt;argv[1]-&gt;ptr);</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     size_t srclen = sdslen(srcstring);</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :     while(srclen &amp;&amp; (srcstring[srclen-1] == '\n' ||</span>
<span class="lineNum">    1696 </span>            :                      srcstring[srclen-1] == '\r'))
<span class="lineNum">    1697 </span>            :     {
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :         srcstring[--srclen] = '\0';</span>
<span class="lineNum">    1699 </span>            :     }
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :     sdssetlen(srcstring,srclen);</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :     ldb.src = sdssplitlen(srcstring,sdslen(srcstring),&quot;\n&quot;,1,&amp;ldb.lines);</span>
<span class="lineNum">    1702 </span><span class="lineNoCov">          0 :     sdsfree(srcstring);</span>
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1704 </span>            : }
<span class="lineNum">    1705 </span>            : 
<a name="1706"><span class="lineNum">    1706 </span>            : /* End a debugging session after the EVAL call with debugging enabled</a>
<span class="lineNum">    1707 </span>            :  * returned. */
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 : void ldbEndSession(client *c) {</span>
<span class="lineNum">    1709 </span>            :     /* Emit the remaining logs and an &lt;endsession&gt; mark. */
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :     ldbLog(sdsnew(&quot;&lt;endsession&gt;&quot;));</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :     ldbSendLogs();</span>
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            :     /* If it's a fork()ed session, we just exit. */
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :     if (ldb.forked) {</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :         writeToClient(c-&gt;fd, c, 0);</span>
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Lua debugging session child exiting&quot;);</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :         exitFromChild(0);</span>
<span class="lineNum">    1718 </span>            :     } else {
<span class="lineNum">    1719 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    1720 </span>            :             &quot;Redis synchronous debugging eval session ended&quot;);
<span class="lineNum">    1721 </span>            :     }
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            :     /* Otherwise let's restore client's state. */
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :     anetNonBlock(NULL,ldb.fd);</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :     anetSendTimeout(NULL,ldb.fd,0);</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span>            :     /* Close the client connectin after sending the final EVAL reply
<span class="lineNum">    1728 </span>            :      * in order to signal the end of the debugging session. */
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :     /* Cleanup. */
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :     sdsfreesplitres(ldb.src,ldb.lines);</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     ldb.lines = 0;</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :     ldb.active = 0;</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            : /* If the specified pid is among the list of children spawned for
<a name="1738"><span class="lineNum">    1738 </span>            :  * forked debugging sessions, it is removed from the children list.</a>
<span class="lineNum">    1739 </span>            :  * If the pid was found non-zero is returned. */
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 : int ldbRemoveChild(pid_t pid) {</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :     listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);</span>
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     if (ln) {</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :         listDelNode(ldb.children,ln);</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1745 </span>            :     }
<span class="lineNum">    1746 </span>            :     return 0;
<span class="lineNum">    1747 </span>            : }
<span class="lineNum">    1748 </span>            : 
<a name="1749"><span class="lineNum">    1749 </span>            : /* Return the number of children we still did not receive termination</a>
<span class="lineNum">    1750 </span>            :  * acknowledge via wait() in the parent process. */
<span class="lineNum">    1751 </span><span class="lineCov">      41006 : int ldbPendingChildren(void) {</span>
<span class="lineNum">    1752 </span><span class="lineCov">      41006 :     return listLength(ldb.children);</span>
<span class="lineNum">    1753 </span>            : }
<a name="1754"><span class="lineNum">    1754 </span>            : </a>
<span class="lineNum">    1755 </span>            : /* Kill all the forked sessions. */
<span class="lineNum">    1756 </span><span class="lineCov">        411 : void ldbKillForkedSessions(void) {</span>
<span class="lineNum">    1757 </span><span class="lineCov">        411 :     listIter li;</span>
<span class="lineNum">    1758 </span><span class="lineCov">        411 :     listNode *ln;</span>
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineCov">        411 :     listRewind(ldb.children,&amp;li);</span>
<span class="lineNum">    1761 </span><span class="lineCov">        411 :     while((ln = listNext(&amp;li))) {</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :         pid_t pid = (unsigned long) ln-&gt;value;</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Killing debugging session %ld&quot;,(long)pid);</span>
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :         kill(pid,SIGKILL);</span>
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span><span class="lineCov">        411 :     listRelease(ldb.children);</span>
<span class="lineNum">    1767 </span><span class="lineCov">        411 :     ldb.children = listCreate();</span>
<span class="lineNum">    1768 </span><span class="lineCov">        411 : }</span>
<span class="lineNum">    1769 </span>            : 
<a name="1770"><span class="lineNum">    1770 </span>            : /* Wrapper for EVAL / EVALSHA that enables debugging, and makes sure</a>
<span class="lineNum">    1771 </span>            :  * that when EVAL returns, whatever happened, the session is ended. */
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 : void evalGenericCommandWithDebugging(client *c, int evalsha) {</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :     if (ldbStartSession(c)) {</span>
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :         evalGenericCommand(c,evalsha);</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :         ldbEndSession(c);</span>
<span class="lineNum">    1776 </span>            :     } else {
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :         ldbDisable(c);</span>
<span class="lineNum">    1778 </span>            :     }
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1780 </span>            : 
<a name="1781"><span class="lineNum">    1781 </span>            : /* Return a pointer to ldb.src source code line, considering line to be</a>
<span class="lineNum">    1782 </span>            :  * one-based, and returning a special string for out of range lines. */
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 : char *ldbGetSourceLine(int line) {</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     int idx = line-1;</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     if (idx &lt; 0 || idx &gt;= ldb.lines) return &quot;&lt;out of range source code line&gt;&quot;;</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :     return ldb.src[idx];</span>
<span class="lineNum">    1787 </span>            : }
<a name="1788"><span class="lineNum">    1788 </span>            : </a>
<span class="lineNum">    1789 </span>            : /* Return true if there is a breakpoint in the specified line. */
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 : int ldbIsBreakpoint(int line) {</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     int j;</span>
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; ldb.bpcount; j++)</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :         if (ldb.bp[j] == line) return 1;</span>
<span class="lineNum">    1795 </span>            :     return 0;
<span class="lineNum">    1796 </span>            : }
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            : /* Add the specified breakpoint. Ignore it if we already reached the max.
<a name="1799"><span class="lineNum">    1799 </span>            :  * Returns 1 if the breakpoint was added (or was already set). 0 if there is</a>
<span class="lineNum">    1800 </span>            :  * no space for the breakpoint or if the line is invalid. */
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 : int ldbAddBreakpoint(int line) {</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :     if (line &lt;= 0 || line &gt; ldb.lines) return 0;</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :     if (!ldbIsBreakpoint(line) &amp;&amp; ldb.bpcount != LDB_BREAKPOINTS_MAX) {</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :         ldb.bp[ldb.bpcount++] = line;</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1806 </span>            :     }
<span class="lineNum">    1807 </span>            :     return 0;
<span class="lineNum">    1808 </span>            : }
<span class="lineNum">    1809 </span>            : 
<a name="1810"><span class="lineNum">    1810 </span>            : /* Remove the specified breakpoint, returning 1 if the operation was</a>
<span class="lineNum">    1811 </span>            :  * performed or 0 if there was no such breakpoint. */
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 : int ldbDelBreakpoint(int line) {</span>
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :     int j;</span>
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; ldb.bpcount; j++) {</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :         if (ldb.bp[j] == line) {</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             ldb.bpcount--;</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :             memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :             return 1;</span>
<span class="lineNum">    1820 </span>            :         }
<span class="lineNum">    1821 </span>            :     }
<span class="lineNum">    1822 </span>            :     return 0;
<span class="lineNum">    1823 </span>            : }
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            : /* Expect a valid multi-bulk command in the debugging client query buffer.
<a name="1826"><span class="lineNum">    1826 </span>            :  * On success the command is parsed and returned as an array of SDS strings,</a>
<span class="lineNum">    1827 </span>            :  * otherwise NULL is returned and there is to read more buffer. */
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 : sds *ldbReplParseCommand(int *argcp) {</span>
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :     sds *argv = NULL;</span>
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :     int argc = 0;</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :     if (sdslen(ldb.cbuf) == 0) return NULL;</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            :     /* Working on a copy is simpler in this case. We can modify it freely
<span class="lineNum">    1834 </span>            :      * for the sake of simpler parsing. */
<span class="lineNum">    1835 </span><span class="lineNoCov">          0 :     sds copy = sdsdup(ldb.cbuf);</span>
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :     char *p = copy;</span>
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span>            :     /* This Redis protocol parser is a joke... just the simplest thing that
<span class="lineNum">    1839 </span>            :      * works in this context. It is also very forgiving regarding broken
<span class="lineNum">    1840 </span>            :      * protocol. */
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span>            :     /* Seek and parse *&lt;count&gt;\r\n. */
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :     p = strchr(p,'*'); if (!p) goto protoerr;</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :     char *plen = p+1; /* Multi bulk len pointer. */</span>
<span class="lineNum">    1845 </span><span class="lineNoCov">          0 :     p = strstr(p,&quot;\r\n&quot;); if (!p) goto protoerr;</span>
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     *p = '\0'; p += 2;</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :     *argcp = atoi(plen);</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :     if (*argcp &lt;= 0 || *argcp &gt; 1024) goto protoerr;</span>
<span class="lineNum">    1849 </span>            : 
<span class="lineNum">    1850 </span>            :     /* Parse each argument. */
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :     argv = zmalloc(sizeof(sds)*(*argcp));</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     argc = 0;</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :     while(argc &lt; *argcp) {</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :         if (*p != '$') goto protoerr;</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :         plen = p+1; /* Bulk string len pointer. */</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :         p = strstr(p,&quot;\r\n&quot;); if (!p) goto protoerr;</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :         *p = '\0'; p += 2;</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :         int slen = atoi(plen); /* Length of this arg. */</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :         if (slen &lt;= 0 || slen &gt; 1024) goto protoerr;</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :         argv[argc++] = sdsnewlen(p,slen);</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         p += slen; /* Skip the already parsed argument. */</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :         if (p[0] != '\r' || p[1] != '\n') goto protoerr;</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :         p += 2; /* Skip \r\n. */</span>
<span class="lineNum">    1864 </span>            :     }
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     sdsfree(copy);</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :     return argv;</span>
<span class="lineNum">    1867 </span>            : 
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 : protoerr:</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :     sdsfreesplitres(argv,argc);</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :     sdsfree(copy);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1872 </span>            : }
<a name="1873"><span class="lineNum">    1873 </span>            : </a>
<span class="lineNum">    1874 </span>            : /* Log the specified line in the Lua debugger output. */
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 : void ldbLogSourceLine(int lnum) {</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :     char *line = ldbGetSourceLine(lnum);</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     char *prefix;</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     int bp = ldbIsBreakpoint(lnum);</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     int current = ldb.currentline == lnum;</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     if (current &amp;&amp; bp)</span>
<span class="lineNum">    1882 </span>            :         prefix = &quot;-&gt;#&quot;;
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     else if (current)</span>
<span class="lineNum">    1884 </span>            :         prefix = &quot;-&gt; &quot;;
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :     else if (bp)</span>
<span class="lineNum">    1886 </span>            :         prefix = &quot;  #&quot;;
<span class="lineNum">    1887 </span>            :     else
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :         prefix = &quot;   &quot;;</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :     sds thisline = sdscatprintf(sdsempty(),&quot;%s%-3d %s&quot;, prefix, lnum, line);</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     ldbLog(thisline);</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span>            : /* Implement the &quot;list&quot; command of the Lua debugger. If around is 0
<span class="lineNum">    1894 </span>            :  * the whole file is listed, otherwise only a small portion of the file
<span class="lineNum">    1895 </span>            :  * around the specified line is shown. When a line number is specified
<a name="1896"><span class="lineNum">    1896 </span>            :  * the amonut of context (lines before/after) is specified via the</a>
<span class="lineNum">    1897 </span>            :  * 'context' argument. */
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 : void ldbList(int around, int context) {</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :     int j;</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     for (j = 1; j &lt;= ldb.lines; j++) {</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :         if (around != 0 &amp;&amp; abs(around-j) &gt; context) continue;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :         ldbLogSourceLine(j);</span>
<span class="lineNum">    1904 </span>            :     }
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span>            : /* Append an human readable representation of the Lua value at position 'idx'
<span class="lineNum">    1908 </span>            :  * on the stack of the 'lua' state, to the SDS string passed as argument.
<span class="lineNum">    1909 </span>            :  * The new SDS string with the represented value attached is returned.
<span class="lineNum">    1910 </span>            :  * Used in order to implement ldbLogStackValue().
<span class="lineNum">    1911 </span>            :  *
<span class="lineNum">    1912 </span>            :  * The element is not automatically removed from the stack, nor it is
<a name="1913"><span class="lineNum">    1913 </span>            :  * converted to a different type. */</a>
<span class="lineNum">    1914 </span>            : #define LDB_MAX_VALUES_DEPTH (LUA_MINSTACK/2)
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 : sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     int t = lua_type(lua,idx);</span>
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :     if (level++ == LDB_MAX_VALUES_DEPTH)</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :         return sdscat(s,&quot;&lt;max recursion level reached! Nested table?&gt;&quot;);</span>
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :     switch(t) {</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     case LUA_TSTRING:</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :         {</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :         size_t strl;</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :         char *strp = (char*)lua_tolstring(lua,idx,&amp;strl);</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :         s = sdscatrepr(s,strp,strl);</span>
<span class="lineNum">    1927 </span>            :         }
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     case LUA_TBOOLEAN:</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :         s = sdscat(s,lua_toboolean(lua,idx) ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     case LUA_TNUMBER:</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :         s = sdscatprintf(s,&quot;%g&quot;,(double)lua_tonumber(lua,idx));</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :     case LUA_TNIL:</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :         s = sdscatlen(s,&quot;nil&quot;,3);</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :     case LUA_TTABLE:</span>
<span class="lineNum">    1939 </span>            :         {
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :         int expected_index = 1; /* First index we expect in an array. */</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :         int is_array = 1; /* Will be set to null if check fails. */</span>
<span class="lineNum">    1942 </span>            :         /* Note: we create two representations at the same time, one
<span class="lineNum">    1943 </span>            :          * assuming the table is an array, one assuming it is not. At the
<span class="lineNum">    1944 </span>            :          * end we know what is true and select the right one. */
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :         sds repr1 = sdsempty();</span>
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :         sds repr2 = sdsempty();</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :         lua_pushnil(lua); /* The first key to start the iteration is nil. */</span>
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 :         while (lua_next(lua,idx-1)) {</span>
<span class="lineNum">    1949 </span>            :             /* Test if so far the table looks like an array. */
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :             if (is_array &amp;&amp;</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :                 (lua_type(lua,-2) != LUA_TNUMBER ||</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :                  lua_tonumber(lua,-2) != expected_index)) is_array = 0;</span>
<span class="lineNum">    1953 </span>            :             /* Stack now: table, key, value */
<span class="lineNum">    1954 </span>            :             /* Array repr. */
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :             repr1 = ldbCatStackValueRec(repr1,lua,-1,level);</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :             repr1 = sdscatlen(repr1,&quot;; &quot;,2);</span>
<span class="lineNum">    1957 </span>            :             /* Full repr. */
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :             repr2 = sdscatlen(repr2,&quot;[&quot;,1);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :             repr2 = ldbCatStackValueRec(repr2,lua,-2,level);</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :             repr2 = sdscatlen(repr2,&quot;]=&quot;,2);</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :             repr2 = ldbCatStackValueRec(repr2,lua,-1,level);</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :             repr2 = sdscatlen(repr2,&quot;; &quot;,2);</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :             lua_pop(lua,1); /* Stack: table, key. Ready for next iteration. */</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :             expected_index++;</span>
<span class="lineNum">    1965 </span>            :         }
<span class="lineNum">    1966 </span>            :         /* Strip the last &quot; ;&quot; from both the representations. */
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :         if (sdslen(repr1)) sdsrange(repr1,0,-3);</span>
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :         if (sdslen(repr2)) sdsrange(repr2,0,-3);</span>
<span class="lineNum">    1969 </span>            :         /* Select the right one and discard the other. */
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :         s = sdscatlen(s,&quot;{&quot;,1);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :         s = sdscatsds(s,is_array ? repr1 : repr2);</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :         s = sdscatlen(s,&quot;}&quot;,1);</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :         sdsfree(repr1);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :         sdsfree(repr2);</span>
<span class="lineNum">    1975 </span>            :         }
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :     case LUA_TFUNCTION:</span>
<span class="lineNum">    1978 </span>            :     case LUA_TUSERDATA:
<span class="lineNum">    1979 </span>            :     case LUA_TTHREAD:
<span class="lineNum">    1980 </span>            :     case LUA_TLIGHTUSERDATA:
<span class="lineNum">    1981 </span>            :         {
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         const void *p = lua_topointer(lua,idx);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :         char *typename = &quot;unknown&quot;;</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :         if (t == LUA_TFUNCTION) typename = &quot;function&quot;;</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :         else if (t == LUA_TUSERDATA) typename = &quot;userdata&quot;;</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :         else if (t == LUA_TTHREAD) typename = &quot;thread&quot;;</span>
<span class="lineNum">    1987 </span><span class="lineNoCov">          0 :         else if (t == LUA_TLIGHTUSERDATA) typename = &quot;light-userdata&quot;;</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :         s = sdscatprintf(s,&quot;\&quot;%s@%p\&quot;&quot;,typename,p);</span>
<span class="lineNum">    1989 </span>            :         }
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :         s = sdscat(s,&quot;\&quot;&lt;unknown-lua-type&gt;\&quot;&quot;);</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1994 </span>            :     }
<span class="lineNum">    1995 </span>            :     return s;
<span class="lineNum">    1996 </span>            : }
<span class="lineNum">    1997 </span>            : 
<a name="1998"><span class="lineNum">    1998 </span>            : /* Higher level wrapper for ldbCatStackValueRec() that just uses an initial</a>
<span class="lineNum">    1999 </span>            :  * recursion level of '0'. */
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 : sds ldbCatStackValue(sds s, lua_State *lua, int idx) {</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :     return ldbCatStackValueRec(s,lua,idx,0);</span>
<span class="lineNum">    2002 </span>            : }
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span>            : /* Produce a debugger log entry representing the value of the Lua object
<a name="2005"><span class="lineNum">    2005 </span>            :  * currently on the top of the stack. The element is ot popped nor modified.</a>
<span class="lineNum">    2006 </span>            :  * Check ldbCatStackValue() for the actual implementation. */
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 : void ldbLogStackValue(lua_State *lua, char *prefix) {</span>
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :     sds s = sdsnew(prefix);</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :     s = ldbCatStackValue(s,lua,-1);</span>
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 :     ldbLogWithMaxLen(s);</span>
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span>            : char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);
<span class="lineNum">    2014 </span>            : char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);
<span class="lineNum">    2015 </span>            : char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);
<span class="lineNum">    2016 </span>            : char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);
<span class="lineNum">    2017 </span>            : 
<span class="lineNum">    2018 </span>            : /* Get Redis protocol from 'reply' and appends it in human readable form to
<span class="lineNum">    2019 </span>            :  * the passed SDS string 'o'.
<span class="lineNum">    2020 </span>            :  *
<a name="2021"><span class="lineNum">    2021 </span>            :  * Note that the SDS string is passed by reference (pointer of pointer to</a>
<span class="lineNum">    2022 </span>            :  * char*) so that we can return a modified pointer, as for SDS semantics. */
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 : char *ldbRedisProtocolToHuman(sds *o, char *reply) {</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :     char *p = reply;</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :     switch(*p) {</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :     case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :     case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :     case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :     case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;</span>
<span class="lineNum">    2031 </span>            :     }
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :     return p;</span>
<span class="lineNum">    2033 </span>            : }
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span>            : /* The following functions are helpers for ldbRedisProtocolToHuman(), each
<a name="2036"><span class="lineNum">    2036 </span>            :  * take care of a given Redis return type. */</a>
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 : char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     *o = sdscatlen(*o,reply+1,p-reply-1);</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :     return p+2;</span>
<a name="2042"><span class="lineNum">    2042 </span>            : }</a>
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 : char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :     long long bulklen;</span>
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :     string2ll(reply+1,p-reply-1,&amp;bulklen);</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :     if (bulklen == -1) {</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :         *o = sdscatlen(*o,&quot;NULL&quot;,4);</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :         return p+2;</span>
<span class="lineNum">    2052 </span>            :     } else {
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         *o = sdscatrepr(*o,p+2,bulklen);</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :         return p+2+bulklen+2;</span>
<span class="lineNum">    2055 </span>            :     }
<a name="2056"><span class="lineNum">    2056 </span>            : }</a>
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 : char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :     *o = sdscatrepr(*o,reply,p-reply);</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :     return p+2;</span>
<a name="2063"><span class="lineNum">    2063 </span>            : }</a>
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 : char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :     char *p = strchr(reply+1,'\r');</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :     long long mbulklen;</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :     int j = 0;</span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :     string2ll(reply+1,p-reply-1,&amp;mbulklen);</span>
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :     p += 2;</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :     if (mbulklen == -1) {</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         *o = sdscatlen(*o,&quot;NULL&quot;,4);</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         return p;</span>
<span class="lineNum">    2075 </span>            :     }
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :     *o = sdscatlen(*o,&quot;[&quot;,1);</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :     for (j = 0; j &lt; mbulklen; j++) {</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :         p = ldbRedisProtocolToHuman(o,p);</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :         if (j != mbulklen-1) *o = sdscatlen(*o,&quot;,&quot;,1);</span>
<span class="lineNum">    2080 </span>            :     }
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :     *o = sdscatlen(*o,&quot;]&quot;,1);</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :     return p;</span>
<span class="lineNum">    2083 </span>            : }
<span class="lineNum">    2084 </span>            : 
<span class="lineNum">    2085 </span>            : /* Log a Redis reply as debugger output, in an human readable format.
<a name="2086"><span class="lineNum">    2086 </span>            :  * If the resulting string is longer than 'len' plus a few more chars</a>
<span class="lineNum">    2087 </span>            :  * used as prefix, it gets truncated. */
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 : void ldbLogRedisReply(char *reply) {</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :     sds log = sdsnew(&quot;&lt;reply&gt; &quot;);</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :     ldbRedisProtocolToHuman(&amp;log,reply);</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :     ldbLogWithMaxLen(log);</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            : /* Implements the &quot;print &lt;var&gt;&quot; command of the Lua debugger. It scans for Lua
<a name="2095"><span class="lineNum">    2095 </span>            :  * var &quot;varname&quot; starting from the current stack frame up to the top stack</a>
<span class="lineNum">    2096 </span>            :  * frame. The first matching variable is printed. */
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 : void ldbPrint(lua_State *lua, char *varname) {</span>
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :     lua_Debug ar;</span>
<span class="lineNum">    2099 </span>            : 
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :     int l = 0; /* Stack level. */</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     while (lua_getstack(lua,l,&amp;ar) != 0) {</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :         l++;</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :         const char *name;</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :         int i = 1; /* Variable index. */</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :         while((name = lua_getlocal(lua,&amp;ar,i)) != NULL) {</span>
<span class="lineNum">    2106 </span><span class="lineNoCov">          0 :             i++;</span>
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :             if (strcmp(varname,name) == 0) {</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :                 ldbLogStackValue(lua,&quot;&lt;value&gt; &quot;);</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :                 lua_pop(lua,1);</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    2111 </span>            :             } else {
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :                 lua_pop(lua,1); /* Discard the var name on the stack. */</span>
<span class="lineNum">    2113 </span>            :             }
<span class="lineNum">    2114 </span>            :         }
<span class="lineNum">    2115 </span>            :     }
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            :     /* Let's try with global vars in two selected cases */
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     if (!strcmp(varname,&quot;ARGV&quot;) || !strcmp(varname,&quot;KEYS&quot;)) {</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :         lua_getglobal(lua, varname);</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         ldbLogStackValue(lua,&quot;&lt;value&gt; &quot;);</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);</span>
<span class="lineNum">    2122 </span>            :     } else {
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :         ldbLog(sdsnew(&quot;No such variable.&quot;));</span>
<span class="lineNum">    2124 </span>            :     }
<span class="lineNum">    2125 </span>            : }
<span class="lineNum">    2126 </span>            : 
<a name="2127"><span class="lineNum">    2127 </span>            : /* Implements the &quot;print&quot; command (without arguments) of the Lua debugger.</a>
<span class="lineNum">    2128 </span>            :  * Prints all the variables in the current stack frame. */
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 : void ldbPrintAll(lua_State *lua) {</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     lua_Debug ar;</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :     int vars = 0;</span>
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :     if (lua_getstack(lua,0,&amp;ar) != 0) {</span>
<span class="lineNum">    2134 </span>            :         const char *name;
<span class="lineNum">    2135 </span>            :         int i = 1; /* Variable index. */
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :         while((name = lua_getlocal(lua,&amp;ar,i)) != NULL) {</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :             i++;</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :             if (!strstr(name,&quot;(*temporary)&quot;)) {</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :                 sds prefix = sdscatprintf(sdsempty(),&quot;&lt;value&gt; %s = &quot;,name);</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :                 ldbLogStackValue(lua,prefix);</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                 sdsfree(prefix);</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :                 vars++;</span>
<span class="lineNum">    2143 </span>            :             }
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :             lua_pop(lua,1);</span>
<span class="lineNum">    2145 </span>            :         }
<span class="lineNum">    2146 </span>            :     }
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     if (vars == 0) {</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         ldbLog(sdsnew(&quot;No local variables in the current context.&quot;));</span>
<span class="lineNum">    2150 </span>            :     }
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 : }</span>
<a name="2152"><span class="lineNum">    2152 </span>            : </a>
<span class="lineNum">    2153 </span>            : /* Implements the break command to list, add and remove breakpoints. */
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 : void ldbBreak(sds *argv, int argc) {</span>
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :     if (argc == 1) {</span>
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :         if (ldb.bpcount == 0) {</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :             ldbLog(sdsnew(&quot;No breakpoints set. Use 'b &lt;line&gt;' to add one.&quot;));</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2159 </span>            :         } else {
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :             ldbLog(sdscatfmt(sdsempty(),&quot;%i breakpoints set:&quot;,ldb.bpcount));</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :             int j;</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :             for (j = 0; j &lt; ldb.bpcount; j++)</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :                 ldbLogSourceLine(ldb.bp[j]);</span>
<span class="lineNum">    2164 </span>            :         }
<span class="lineNum">    2165 </span>            :     } else {
<span class="lineNum">    2166 </span>            :         int j;
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :         for (j = 1; j &lt; argc; j++) {</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :             char *arg = argv[j];</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :             long line;</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :             if (!string2l(arg,sdslen(arg),&amp;line)) {</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                 ldbLog(sdscatfmt(sdsempty(),&quot;Invalid argument:'%s'&quot;,arg));</span>
<span class="lineNum">    2172 </span>            :             } else {
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :                 if (line == 0) {</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :                     ldb.bpcount = 0;</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :                     ldbLog(sdsnew(&quot;All breakpoints removed.&quot;));</span>
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 :                 } else if (line &gt; 0) {</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                     if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :                         ldbLog(sdsnew(&quot;Too many breakpoints set.&quot;));</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :                     } else if (ldbAddBreakpoint(line)) {</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :                         ldbList(line,1);</span>
<span class="lineNum">    2181 </span>            :                     } else {
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :                         ldbLog(sdsnew(&quot;Wrong line number.&quot;));</span>
<span class="lineNum">    2183 </span>            :                     }
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :                 } else if (line &lt; 0) {</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :                     if (ldbDelBreakpoint(-line))</span>
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :                         ldbLog(sdsnew(&quot;Breakpoint removed.&quot;));</span>
<span class="lineNum">    2187 </span>            :                     else
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :                         ldbLog(sdsnew(&quot;No breakpoint in the specified line.&quot;));</span>
<span class="lineNum">    2189 </span>            :                 }
<span class="lineNum">    2190 </span>            :             }
<span class="lineNum">    2191 </span>            :         }
<span class="lineNum">    2192 </span>            :     }
<span class="lineNum">    2193 </span>            : }
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span>            : /* Implements the Lua debugger &quot;eval&quot; command. It just compiles the user
<a name="2196"><span class="lineNum">    2196 </span>            :  * passed fragment of code and executes it, showing the result left on</a>
<span class="lineNum">    2197 </span>            :  * the stack. */
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 : void ldbEval(lua_State *lua, sds *argv, int argc) {</span>
<span class="lineNum">    2199 </span>            :     /* Glue the script together if it is composed of multiple arguments. */
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :     sds code = sdsjoinsds(argv+1,argc-1,&quot; &quot;,1);</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :     sds expr = sdscatsds(sdsnew(&quot;return &quot;),code);</span>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            :     /* Try to compile it as an expression, prepending &quot;return &quot;. */
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :     if (luaL_loadbuffer(lua,expr,sdslen(expr),&quot;@ldb_eval&quot;)) {</span>
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);</span>
<span class="lineNum">    2206 </span>            :         /* Failed? Try as a statement. */
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :         if (luaL_loadbuffer(lua,code,sdslen(code),&quot;@ldb_eval&quot;)) {</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :             ldbLog(sdscatfmt(sdsempty(),&quot;&lt;error&gt; %s&quot;,lua_tostring(lua,-1)));</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :             lua_pop(lua,1);</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :             sdsfree(code);</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    2212 </span>            :         }
<span class="lineNum">    2213 </span>            :     }
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span>            :     /* Call it. */
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :     sdsfree(code);</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     sdsfree(expr);</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :     if (lua_pcall(lua,0,1,0)) {</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :         ldbLog(sdscatfmt(sdsempty(),&quot;&lt;error&gt; %s&quot;,lua_tostring(lua,-1)));</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :         lua_pop(lua,1);</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    2222 </span>            :     }
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     ldbLogStackValue(lua,&quot;&lt;retval&gt; &quot;);</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     lua_pop(lua,1);</span>
<span class="lineNum">    2225 </span>            : }
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span>            : /* Implement the debugger &quot;redis&quot; command. We use a trick in order to make
<span class="lineNum">    2228 </span>            :  * the implementation very simple: we just call the Lua redis.call() command
<a name="2229"><span class="lineNum">    2229 </span>            :  * implementation, with ldb.step enabled, so as a side effect the Redis command</a>
<span class="lineNum">    2230 </span>            :  * and its reply are logged. */
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 : void ldbRedis(lua_State *lua, sds *argv, int argc) {</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :     int j, saved_rc = server.lua_replicate_commands;</span>
<span class="lineNum">    2233 </span>            : 
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :     lua_getglobal(lua,&quot;redis&quot;);</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :     lua_pushstring(lua,&quot;call&quot;);</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :     lua_gettable(lua,-2);       /* Stack: redis, redis.call */</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :     for (j = 1; j &lt; argc; j++)</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :         lua_pushlstring(lua,argv[j],sdslen(argv[j]));</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :     ldb.step = 1;               /* Force redis.call() to log. */</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :     server.lua_replicate_commands = 1;</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :     lua_pcall(lua,argc-1,1,0);  /* Stack: redis, result */</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :     ldb.step = 0;               /* Disable logging. */</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :     server.lua_replicate_commands = saved_rc;</span>
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :     lua_pop(lua,2);             /* Discard the result and clean the stack. */</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2246 </span>            : 
<a name="2247"><span class="lineNum">    2247 </span>            : /* Implements &quot;trace&quot; command of the Lua debugger. It just prints a backtrace</a>
<span class="lineNum">    2248 </span>            :  * querying Lua starting from the current callframe back to the outer one. */
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 : void ldbTrace(lua_State *lua) {</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :     lua_Debug ar;</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :     int level = 0;</span>
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :     while(lua_getstack(lua,level,&amp;ar)) {</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         lua_getinfo(lua,&quot;Snl&quot;,&amp;ar);</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :         if(strstr(ar.short_src,&quot;user_script&quot;) != NULL) {</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :             ldbLog(sdscatprintf(sdsempty(),&quot;%s %s:&quot;,</span>
<span class="lineNum">    2257 </span>            :                 (level == 0) ? &quot;In&quot; : &quot;From&quot;,
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :                 ar.name ? ar.name : &quot;top level&quot;));</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :             ldbLogSourceLine(ar.currentline);</span>
<span class="lineNum">    2260 </span>            :         }
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :         level++;</span>
<span class="lineNum">    2262 </span>            :     }
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     if (level == 0) {</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :         ldbLog(sdsnew(&quot;&lt;error&gt; Can't retrieve Lua stack.&quot;));</span>
<span class="lineNum">    2265 </span>            :     }
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2267 </span>            : 
<a name="2268"><span class="lineNum">    2268 </span>            : /* Impleemnts the debugger &quot;maxlen&quot; command. It just queries or sets the</a>
<span class="lineNum">    2269 </span>            :  * ldb.maxlen variable. */
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 : void ldbMaxlen(sds *argv, int argc) {</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :     if (argc == 2) {</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :         int newval = atoi(argv[1]);</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         ldb.maxlen_hint_sent = 1; /* User knows about this command. */</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         if (newval != 0 &amp;&amp; newval &lt;= 60) newval = 60;</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :         ldb.maxlen = newval;</span>
<span class="lineNum">    2276 </span>            :     }
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :     if (ldb.maxlen) {</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         ldbLog(sdscatprintf(sdsempty(),&quot;&lt;value&gt; replies are truncated at %d bytes.&quot;,(int)ldb.maxlen));</span>
<span class="lineNum">    2279 </span>            :     } else {
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :         ldbLog(sdscatprintf(sdsempty(),&quot;&lt;value&gt; replies are unlimited.&quot;));</span>
<span class="lineNum">    2281 </span>            :     }
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span>            : /* Read debugging commands from client.
<a name="2285"><span class="lineNum">    2285 </span>            :  * Return C_OK if the debugging session is continuing, otherwise</a>
<span class="lineNum">    2286 </span>            :  * C_ERR if the client closed the connection or is timing out. */
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 : int ldbRepl(lua_State *lua) {</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :     sds *argv;</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :     int argc;</span>
<span class="lineNum">    2290 </span>            : 
<span class="lineNum">    2291 </span>            :     /* We continue processing commands until a command that should return
<span class="lineNum">    2292 </span>            :      * to the Lua interpreter is found. */
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :     while(1) {</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :         while((argv = ldbReplParseCommand(&amp;argc)) == NULL) {</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :             char buf[1024];</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :             int nread = read(ldb.fd,buf,sizeof(buf));</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :             if (nread &lt;= 0) {</span>
<span class="lineNum">    2298 </span>            :                 /* Make sure the script runs without user input since the
<span class="lineNum">    2299 </span>            :                  * client is no longer connected. */
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :                 ldb.step = 0;</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :                 ldb.bpcount = 0;</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :                 return C_ERR;</span>
<span class="lineNum">    2303 </span>            :             }
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :             ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);</span>
<span class="lineNum">    2305 </span>            :         }
<span class="lineNum">    2306 </span>            : 
<span class="lineNum">    2307 </span>            :         /* Flush the old buffer. */
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :         sdsfree(ldb.cbuf);</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :         ldb.cbuf = sdsempty();</span>
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span>            :         /* Execute the command. */
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :         if (!strcasecmp(argv[0],&quot;h&quot;) || !strcasecmp(argv[0],&quot;help&quot;)) {</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;Redis Lua debugger help:&quot;));</span>
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[h]elp               Show this help.&quot;));</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[s]tep               Run current line and stop again.&quot;));</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[n]ext               Alias for step.&quot;));</span>
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[c]continue          Run till next breakpoint.&quot;));</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[l]list              List source code around current line.&quot;));</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[l]list [line]       List source code around [line].&quot;));</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     line = 0 means: current position.&quot;));</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[l]list [line] [ctx] In this form [ctx] specifies how many lines&quot;));</span>
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     to show before/after [line].&quot;));</span>
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[w]hole              List all source code. Alias for 'list 1 1000000'.&quot;));</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[p]rint              Show all the local variables.&quot;));</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[p]rint &lt;var&gt;        Show the value of the specified variable.&quot;));</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     Can also show global vars KEYS and ARGV.&quot;));</span>
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[b]reak              Show all breakpoints.&quot;));</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[b]reak &lt;line&gt;       Add a breakpoint to the specified line.&quot;));</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[b]reak -&lt;line&gt;      Remove breakpoint from the specified line.&quot;));</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[b]reak 0            Remove all breakpoints.&quot;));</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[t]race              Show a backtrace.&quot;));</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[e]eval &lt;code&gt;       Execute some Lua code (in a different callframe).&quot;));</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[r]edis &lt;cmd&gt;        Execute a Redis command.&quot;));</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.&quot;));</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     Specifying zero as &lt;len&gt; means unlimited.&quot;));</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;[a]bort              Stop the execution of the script. In sync&quot;));</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     mode dataset changes will be retained.&quot;));</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;&quot;));</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;Debugger functions you can call from Lua scripts:&quot;));</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;redis.debug()        Produce logs in the debugger console.&quot;));</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;redis.breakpoint()   Stop execution like if there was a breakpoing.&quot;));</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 : ldbLog(sdsnew(&quot;                     in the next line of code.&quot;));</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;s&quot;) || !strcasecmp(argv[0],&quot;step&quot;) ||</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :                    !strcasecmp(argv[0],&quot;n&quot;) || !strcasecmp(argv[0],&quot;next&quot;)) {</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :             ldb.step = 1;</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;c&quot;) || !strcasecmp(argv[0],&quot;continue&quot;)){</span>
<span class="lineNum">    2349 </span>            :             break;
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;t&quot;) || !strcasecmp(argv[0],&quot;trace&quot;)) {</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :             ldbTrace(lua);</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;m&quot;) || !strcasecmp(argv[0],&quot;maxlen&quot;)) {</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :             ldbMaxlen(argv,argc);</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;b&quot;) || !strcasecmp(argv[0],&quot;break&quot;)) {</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :             ldbBreak(argv,argc);</span>
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;e&quot;) || !strcasecmp(argv[0],&quot;eval&quot;)) {</span>
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :             ldbEval(lua,argv,argc);</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;a&quot;) || !strcasecmp(argv[0],&quot;abort&quot;)) {</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :             lua_pushstring(lua, &quot;script aborted for user request&quot;);</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :             lua_error(lua);</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :         } else if (argc &gt; 1 &amp;&amp;</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :                    (!strcasecmp(argv[0],&quot;r&quot;) || !strcasecmp(argv[0],&quot;redis&quot;))) {</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :             ldbRedis(lua,argv,argc);</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :         } else if ((!strcasecmp(argv[0],&quot;p&quot;) || !strcasecmp(argv[0],&quot;print&quot;))) {</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :             if (argc == 2)</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :                 ldbPrint(lua,argv[1]);</span>
<span class="lineNum">    2372 </span>            :             else
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :                 ldbPrintAll(lua);</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;l&quot;) || !strcasecmp(argv[0],&quot;list&quot;)){</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :             int around = ldb.currentline, ctx = 5;</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :             if (argc &gt; 1) {</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :                 int num = atoi(argv[1]);</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :                 if (num &gt; 0) around = num;</span>
<span class="lineNum">    2380 </span>            :             }
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :             if (argc &gt; 2) ctx = atoi(argv[2]);</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :             ldbList(around,ctx);</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :         } else if (!strcasecmp(argv[0],&quot;w&quot;) || !strcasecmp(argv[0],&quot;whole&quot;)){</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :             ldbList(1,1000000);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2387 </span>            :         } else {
<span class="lineNum">    2388 </span><span class="lineNoCov">          0 :             ldbLog(sdsnew(&quot;&lt;error&gt; Unknown Redis Lua debugger command or &quot;</span>
<span class="lineNum">    2389 </span>            :                           &quot;wrong number of arguments.&quot;));
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :             ldbSendLogs();</span>
<span class="lineNum">    2391 </span>            :         }
<span class="lineNum">    2392 </span>            : 
<span class="lineNum">    2393 </span>            :         /* Free the command vector. */
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :         sdsfreesplitres(argv,argc);</span>
<span class="lineNum">    2395 </span>            :     }
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span>            :     /* Free the current command argv if we break inside the while loop. */
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :     sdsfreesplitres(argv,argc);</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :     return C_OK;</span>
<span class="lineNum">    2400 </span>            : }
<span class="lineNum">    2401 </span>            : 
<a name="2402"><span class="lineNum">    2402 </span>            : /* This is the core of our Lua debugger, called each time Lua is about</a>
<span class="lineNum">    2403 </span>            :  * to start executing a new line. */
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 : void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :     lua_getstack(lua,0,ar);</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :     lua_getinfo(lua,&quot;Sl&quot;,ar);</span>
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     ldb.currentline = ar-&gt;currentline;</span>
<span class="lineNum">    2408 </span>            : 
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :     int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :     int timeout = 0;</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            :     /* Events outside our script are not interesting. */
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :     if(strstr(ar-&gt;short_src,&quot;user_script&quot;) == NULL) return;</span>
<span class="lineNum">    2414 </span>            : 
<span class="lineNum">    2415 </span>            :     /* Check if a timeout occurred. */
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :     if (ar-&gt;event == LUA_HOOKCOUNT &amp;&amp; ldb.step == 0 &amp;&amp; bp == 0) {</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :         mstime_t elapsed = mstime() - server.lua_time_start;</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :         mstime_t timelimit = server.lua_time_limit ?</span>
<span class="lineNum">    2419 </span><span class="lineNoCov">          0 :                              server.lua_time_limit : 5000;</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :         if (elapsed &gt;= timelimit) {</span>
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :             timeout = 1;</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :             ldb.step = 1;</span>
<span class="lineNum">    2423 </span>            :         } else {
<span class="lineNum">    2424 </span>            :             return; /* No timeout, ignore the COUNT event. */
<span class="lineNum">    2425 </span>            :         }
<span class="lineNum">    2426 </span>            :     }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :     if (ldb.step || bp) {</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :         char *reason = &quot;step over&quot;;</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :         if (bp) reason = ldb.luabp ? &quot;redis.breakpoint() called&quot; :</span>
<span class="lineNum">    2431 </span>            :                                      &quot;break point&quot;;
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :         else if (timeout) reason = &quot;timeout reached, infinite loop?&quot;;</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :         ldb.step = 0;</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :         ldb.luabp = 0;</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :         ldbLog(sdscatprintf(sdsempty(),</span>
<span class="lineNum">    2436 </span>            :             &quot;* Stopped at %d, stop reason = %s&quot;,
<span class="lineNum">    2437 </span>            :             ldb.currentline, reason));
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :         ldbLogSourceLine(ldb.currentline);</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :         ldbSendLogs();</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :         if (ldbRepl(lua) == C_ERR &amp;&amp; timeout) {</span>
<span class="lineNum">    2441 </span>            :             /* If the client closed the connection and we have a timeout
<span class="lineNum">    2442 </span>            :              * connection, let's kill the script otherwise the process
<span class="lineNum">    2443 </span>            :              * will remain blocked indefinitely. */
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :             lua_pushstring(lua, &quot;timeout during Lua debugging with client closing connection&quot;);</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :             lua_error(lua);</span>
<span class="lineNum">    2446 </span>            :         }
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :         server.lua_time_start = mstime();</span>
<span class="lineNum">    2448 </span>            :     }
<span class="lineNum">    2449 </span>            : }
<span class="lineNum">    2450 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
