<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - redis.info - src/rax.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - rax.c<span style="font-size: 80%;"> (source / <a href="rax.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">redis.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">595</td>
            <td class="headerCovTableEntry">826</td>
            <td class="headerCovTableEntryLo">72.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-11-29 23:16:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntry">40</td>
            <td class="headerCovTableEntryLo">70.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Rax -- A radix tree implementation.</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * Copyright (c) 2017-2018, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
<span class="lineNum">       4 </span>            :  * All rights reserved.
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       7 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  *   * Redistributions of source code must retain the above copyright notice,
<span class="lineNum">      10 </span>            :  *     this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>            :  *   * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      12 </span>            :  *     notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      13 </span>            :  *     documentation and/or other materials provided with the distribution.
<span class="lineNum">      14 </span>            :  *   * Neither the name of Redis nor the names of its contributors may be used
<span class="lineNum">      15 </span>            :  *     to endorse or promote products derived from this software without
<span class="lineNum">      16 </span>            :  *     specific prior written permission.
<span class="lineNum">      17 </span>            :  *
<span class="lineNum">      18 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      19 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      20 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      21 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      22 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      23 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      24 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      25 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      26 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      27 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      28 </span>            :  * POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      29 </span>            :  */
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      32 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      33 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      34 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      36 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      37 </span>            : #include &quot;rax.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #ifndef RAX_MALLOC_INCLUDE
<span class="lineNum">      40 </span>            : #define RAX_MALLOC_INCLUDE &quot;rax_malloc.h&quot;
<span class="lineNum">      41 </span>            : #endif
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #include RAX_MALLOC_INCLUDE
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /* This is a special pointer that is guaranteed to never have the same value
<span class="lineNum">      46 </span>            :  * of a radix tree node. It's used in order to report &quot;not found&quot; error without
<span class="lineNum">      47 </span>            :  * requiring the function to have multiple return values. */
<span class="lineNum">      48 </span>            : void *raxNotFound = (void*)&quot;rax-not-found-pointer&quot;;
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : /* -------------------------------- Debugging ------------------------------ */
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : void raxDebugShowNode(const char *msg, raxNode *n);
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /* Turn debugging messages on/off by compiling with RAX_DEBUG_MSG macro on.
<span class="lineNum">      55 </span>            :  * When RAX_DEBUG_MSG is defined by default Rax operations will emit a lot
<span class="lineNum">      56 </span>            :  * of debugging info to the standard output, however you can still turn
<span class="lineNum">      57 </span>            :  * debugging on/off in order to enable it only when you suspect there is an
<span class="lineNum">      58 </span>            :  * operation causing a bug using the function raxSetDebugMsg(). */
<span class="lineNum">      59 </span>            : #ifdef RAX_DEBUG_MSG
<span class="lineNum">      60 </span>            : #define debugf(...)                                                            \
<span class="lineNum">      61 </span>            :     if (raxDebugMsg) {                                                         \
<span class="lineNum">      62 </span>            :         printf(&quot;%s:%s:%d:\t&quot;, __FILE__, __FUNCTION__, __LINE__);               \
<span class="lineNum">      63 </span>            :         printf(__VA_ARGS__);                                                   \
<span class="lineNum">      64 </span>            :         fflush(stdout);                                                        \
<span class="lineNum">      65 </span>            :     }
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #define debugnode(msg,n) raxDebugShowNode(msg,n)
<span class="lineNum">      68 </span>            : #else
<span class="lineNum">      69 </span>            : #define debugf(...)
<span class="lineNum">      70 </span>            : #define debugnode(msg,n)
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /* By default log debug info if RAX_DEBUG_MSG is defined. */
<span class="lineNum">      74 </span>            : static int raxDebugMsg = 1;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* When debug messages are enabled, turn them on/off dynamically. By
<a name="77"><span class="lineNum">      77 </span>            :  * default they are enabled. Set the state to 0 to disable, and 1 to</a>
<span class="lineNum">      78 </span>            :  * re-enable. */
<span class="lineNum">      79 </span><span class="lineNoCov">          0 : void raxSetDebugMsg(int onoff) {</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     raxDebugMsg = onoff;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : /* ------------------------- raxStack functions --------------------------
<span class="lineNum">      84 </span>            :  * The raxStack is a simple stack of pointers that is capable of switching
<span class="lineNum">      85 </span>            :  * from using a stack-allocated array to dynamic heap once a given number of
<span class="lineNum">      86 </span>            :  * items are reached. It is used in order to retain the list of parent nodes
<span class="lineNum">      87 </span>            :  * while walking the radix tree in order to implement certain operations that
<span class="lineNum">      88 </span>            :  * need to navigate the tree upward.
<span class="lineNum">      89 </span>            :  * ------------------------------------------------------------------------- */
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : /* Initialize the stack. */
<span class="lineNum">      92 </span>            : static inline void raxStackInit(raxStack *ts) {
<span class="lineNum">      93 </span><span class="lineCov">      94736 :     ts-&gt;stack = ts-&gt;static_items;</span>
<span class="lineNum">      94 </span><span class="lineCov">      94736 :     ts-&gt;items = 0;</span>
<span class="lineNum">      95 </span><span class="lineCov">      94736 :     ts-&gt;maxitems = RAX_STACK_STATIC_ITEMS;</span>
<span class="lineNum">      96 </span><span class="lineCov">      94736 :     ts-&gt;oom = 0;</span>
<span class="lineNum">      97 </span>            : }
<a name="98"><span class="lineNum">      98 </span>            : </a>
<span class="lineNum">      99 </span>            : /* Push an item into the stack, returns 1 on success, 0 on out of memory. */
<span class="lineNum">     100 </span><span class="lineCov">     426947 : static inline int raxStackPush(raxStack *ts, void *ptr) {</span>
<span class="lineNum">     101 </span><span class="lineCov">     426947 :     if (ts-&gt;items == ts-&gt;maxitems) {</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :         if (ts-&gt;stack == ts-&gt;static_items) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :             ts-&gt;stack = rax_malloc(sizeof(void*)*ts-&gt;maxitems*2);</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :             if (ts-&gt;stack == NULL) {</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :                 ts-&gt;stack = ts-&gt;static_items;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :                 ts-&gt;oom = 1;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :                 errno = ENOMEM;</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     109 </span>            :             }
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :             memcpy(ts-&gt;stack,ts-&gt;static_items,sizeof(void*)*ts-&gt;maxitems);</span>
<span class="lineNum">     111 </span>            :         } else {
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :             void **newalloc = rax_realloc(ts-&gt;stack,sizeof(void*)*ts-&gt;maxitems*2);</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :             if (newalloc == NULL) {</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                 ts-&gt;oom = 1;</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :                 errno = ENOMEM;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">     117 </span>            :             }
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :             ts-&gt;stack = newalloc;</span>
<span class="lineNum">     119 </span>            :         }
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :         ts-&gt;maxitems *= 2;</span>
<span class="lineNum">     121 </span>            :     }
<span class="lineNum">     122 </span><span class="lineCov">     426947 :     ts-&gt;stack[ts-&gt;items] = ptr;</span>
<span class="lineNum">     123 </span><span class="lineCov">     426947 :     ts-&gt;items++;</span>
<span class="lineNum">     124 </span><span class="lineCov">     426947 :     return 1;</span>
<span class="lineNum">     125 </span>            : }
<span class="lineNum">     126 </span>            : 
<a name="127"><span class="lineNum">     127 </span>            : /* Pop an item from the stack, the function returns NULL if there are no</a>
<span class="lineNum">     128 </span>            :  * items to pop. */
<span class="lineNum">     129 </span><span class="lineNoCov">          0 : static inline void *raxStackPop(raxStack *ts) {</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     if (ts-&gt;items == 0) return NULL;</span>
<span class="lineNum">     131 </span><span class="lineCov">      80023 :     ts-&gt;items--;</span>
<span class="lineNum">     132 </span><span class="lineCov">      79575 :     return ts-&gt;stack[ts-&gt;items];</span>
<span class="lineNum">     133 </span>            : }
<span class="lineNum">     134 </span>            : 
<a name="135"><span class="lineNum">     135 </span>            : /* Return the stack item at the top of the stack without actually consuming</a>
<span class="lineNum">     136 </span>            :  * it. */
<span class="lineNum">     137 </span><span class="lineNoCov">          0 : static inline void *raxStackPeek(raxStack *ts) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     if (ts-&gt;items == 0) return NULL;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :     return ts-&gt;stack[ts-&gt;items-1];</span>
<span class="lineNum">     140 </span>            : }
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : /* Free the stack in case we used heap allocation. */
<span class="lineNum">     143 </span>            : static inline void raxStackFree(raxStack *ts) {
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :     if (ts-&gt;stack != ts-&gt;static_items) rax_free(ts-&gt;stack);</span>
<span class="lineNum">     145 </span>            : }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : /* ----------------------------------------------------------------------------
<span class="lineNum">     148 </span>            :  * Radix tree implementation
<span class="lineNum">     149 </span>            :  * --------------------------------------------------------------------------*/
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* Return the padding needed in the characters section of a node having size
<span class="lineNum">     152 </span>            :  * 'nodesize'. The padding is needed to store the child pointers to aligned
<span class="lineNum">     153 </span>            :  * addresses. Note that we add 4 to the node size because the node has a four
<span class="lineNum">     154 </span>            :  * bytes header. */
<span class="lineNum">     155 </span>            : #define raxPadding(nodesize) ((sizeof(void*)-((nodesize+4) % sizeof(void*))) &amp; (sizeof(void*)-1))
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /* Return the pointer to the last child pointer in a node. For the compressed
<span class="lineNum">     158 </span>            :  * nodes this is the only child pointer. */
<span class="lineNum">     159 </span>            : #define raxNodeLastChildPtr(n) ((raxNode**) ( \
<span class="lineNum">     160 </span>            :     ((char*)(n)) + \
<span class="lineNum">     161 </span>            :     raxNodeCurrentLength(n) - \
<span class="lineNum">     162 </span>            :     sizeof(raxNode*) - \
<span class="lineNum">     163 </span>            :     (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull) ? sizeof(void*) : 0) \
<span class="lineNum">     164 </span>            : ))
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : /* Return the pointer to the first child pointer. */
<span class="lineNum">     167 </span>            : #define raxNodeFirstChildPtr(n) ((raxNode**) ( \
<span class="lineNum">     168 </span>            :     (n)-&gt;data + \
<span class="lineNum">     169 </span>            :     (n)-&gt;size + \
<span class="lineNum">     170 </span>            :     raxPadding((n)-&gt;size)))
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /* Return the current total size of the node. Note that the second line
<span class="lineNum">     173 </span>            :  * computes the padding after the string of characters, needed in order to
<span class="lineNum">     174 </span>            :  * save pointers to aligned addresses. */
<span class="lineNum">     175 </span>            : #define raxNodeCurrentLength(n) ( \
<span class="lineNum">     176 </span>            :     sizeof(raxNode)+(n)-&gt;size+ \
<span class="lineNum">     177 </span>            :     raxPadding((n)-&gt;size)+ \
<span class="lineNum">     178 </span>            :     ((n)-&gt;iscompr ? sizeof(raxNode*) : sizeof(raxNode*)*(n)-&gt;size)+ \
<span class="lineNum">     179 </span>            :     (((n)-&gt;iskey &amp;&amp; !(n)-&gt;isnull)*sizeof(void*)) \
<span class="lineNum">     180 </span>            : )
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /* Allocate a new non compressed node with the specified number of children.
<span class="lineNum">     183 </span>            :  * If datafiled is true, the allocation is made large enough to hold the
<a name="184"><span class="lineNum">     184 </span>            :  * associated data pointer.</a>
<span class="lineNum">     185 </span>            :  * Returns the new node pointer. On out of memory NULL is returned. */
<span class="lineNum">     186 </span><span class="lineNoCov">          0 : raxNode *raxNewNode(size_t children, int datafield) {</span>
<span class="lineNum">     187 </span><span class="lineCov">      14016 :     size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :                       sizeof(raxNode*)*children;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :     if (datafield) nodesize += sizeof(void*);</span>
<span class="lineNum">     190 </span><span class="lineCov">       2089 :     raxNode *node = rax_malloc(nodesize);</span>
<span class="lineNum">     191 </span><span class="lineCov">      14016 :     if (node == NULL) return NULL;</span>
<span class="lineNum">     192 </span><span class="lineCov">      14016 :     node-&gt;iskey = 0;</span>
<span class="lineNum">     193 </span><span class="lineCov">      14016 :     node-&gt;isnull = 0;</span>
<span class="lineNum">     194 </span><span class="lineCov">      14016 :     node-&gt;iscompr = 0;</span>
<span class="lineNum">     195 </span><span class="lineCov">      14016 :     node-&gt;size = children;</span>
<span class="lineNum">     196 </span><span class="lineCov">      14016 :     return node;</span>
<span class="lineNum">     197 </span>            : }
<span class="lineNum">     198 </span>            : 
<a name="199"><span class="lineNum">     199 </span>            : /* Allocate a new rax and return its pointer. On out of memory the function</a>
<span class="lineNum">     200 </span>            :  * returns NULL. */
<span class="lineNum">     201 </span><span class="lineCov">       1879 : rax *raxNew(void) {</span>
<span class="lineNum">     202 </span><span class="lineCov">       1879 :     rax *rax = rax_malloc(sizeof(*rax));</span>
<span class="lineNum">     203 </span><span class="lineCov">       1879 :     if (rax == NULL) return NULL;</span>
<span class="lineNum">     204 </span><span class="lineCov">       1879 :     rax-&gt;numele = 0;</span>
<span class="lineNum">     205 </span><span class="lineCov">       1879 :     rax-&gt;numnodes = 1;</span>
<span class="lineNum">     206 </span><span class="lineCov">       1879 :     rax-&gt;head = raxNewNode(0,0);</span>
<span class="lineNum">     207 </span><span class="lineCov">       1879 :     if (rax-&gt;head == NULL) {</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         rax_free(rax);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     210 </span>            :     } else {
<span class="lineNum">     211 </span>            :         return rax;
<span class="lineNum">     212 </span>            :     }
<span class="lineNum">     213 </span>            : }
<span class="lineNum">     214 </span>            : 
<a name="215"><span class="lineNum">     215 </span>            : /* realloc the node to make room for auxiliary data in order</a>
<span class="lineNum">     216 </span>            :  * to store an item in that node. On out of memory NULL is returned. */
<span class="lineNum">     217 </span><span class="lineCov">       7977 : raxNode *raxReallocForData(raxNode *n, void *data) {</span>
<span class="lineNum">     218 </span><span class="lineCov">       7977 :     if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */</span>
<span class="lineNum">     219 </span><span class="lineCov">       7977 :     size_t curlen = raxNodeCurrentLength(n);</span>
<span class="lineNum">     220 </span><span class="lineCov">       7977 :     return rax_realloc(n,curlen+sizeof(void*));</span>
<span class="lineNum">     221 </span>            : }
<a name="222"><span class="lineNum">     222 </span>            : </a>
<span class="lineNum">     223 </span>            : /* Set the node auxiliary data to the specified pointer. */
<span class="lineNum">     224 </span><span class="lineCov">      37058 : void raxSetData(raxNode *n, void *data) {</span>
<span class="lineNum">     225 </span><span class="lineCov">      37058 :     n-&gt;iskey = 1;</span>
<span class="lineNum">     226 </span><span class="lineCov">      37058 :     if (data != NULL) {</span>
<span class="lineNum">     227 </span><span class="lineCov">      37058 :         n-&gt;isnull = 0;</span>
<span class="lineNum">     228 </span><span class="lineCov">      74116 :         void **ndata = (void**)</span>
<span class="lineNum">     229 </span><span class="lineCov">      37058 :             ((char*)n+raxNodeCurrentLength(n)-sizeof(void*));</span>
<span class="lineNum">     230 </span><span class="lineCov">      37058 :         memcpy(ndata,&amp;data,sizeof(data));</span>
<span class="lineNum">     231 </span>            :     } else {
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         n-&gt;isnull = 1;</span>
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span><span class="lineCov">      37058 : }</span>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<span class="lineNum">     236 </span>            : /* Get the node auxiliary data. */
<span class="lineNum">     237 </span><span class="lineCov">     119651 : void *raxGetData(raxNode *n) {</span>
<span class="lineNum">     238 </span><span class="lineCov">     119651 :     if (n-&gt;isnull) return NULL;</span>
<span class="lineNum">     239 </span><span class="lineCov">     119651 :     void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));</span>
<span class="lineNum">     240 </span><span class="lineCov">     119651 :     void *data;</span>
<span class="lineNum">     241 </span><span class="lineCov">     119651 :     memcpy(&amp;data,ndata,sizeof(data));</span>
<span class="lineNum">     242 </span><span class="lineCov">     119651 :     return data;</span>
<span class="lineNum">     243 </span>            : }
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : /* Add a new child to the node 'n' representing the character 'c' and return
<span class="lineNum">     246 </span>            :  * its new pointer, as well as the child pointer by reference. Additionally
<span class="lineNum">     247 </span>            :  * '***parentlink' is populated with the raxNode pointer-to-pointer of where
<span class="lineNum">     248 </span>            :  * the new child was stored, which is useful for the caller to replace the
<span class="lineNum">     249 </span>            :  * child pointer if it gets reallocated.
<span class="lineNum">     250 </span>            :  *
<span class="lineNum">     251 </span>            :  * On success the new parent node pointer is returned (it may change because
<a name="252"><span class="lineNum">     252 </span>            :  * of the realloc, so the caller should discard 'n' and use the new value).</a>
<span class="lineNum">     253 </span>            :  * On out of memory NULL is returned, and the old node is still valid. */
<span class="lineNum">     254 </span><span class="lineCov">       6244 : raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {</span>
<span class="lineNum">     255 </span><span class="lineCov">       6244 :     assert(n-&gt;iscompr == 0);</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineCov">       6244 :     size_t curlen = raxNodeCurrentLength(n);</span>
<span class="lineNum">     258 </span><span class="lineCov">       6244 :     n-&gt;size++;</span>
<span class="lineNum">     259 </span><span class="lineCov">       6244 :     size_t newlen = raxNodeCurrentLength(n);</span>
<span class="lineNum">     260 </span><span class="lineCov">       6244 :     n-&gt;size--; /* For now restore the orignal size. We'll update it only on</span>
<span class="lineNum">     261 </span>            :                   success at the end. */
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :     /* Alloc the new child we will link to 'n'. */
<span class="lineNum">     264 </span><span class="lineCov">       6244 :     raxNode *child = raxNewNode(0,0);</span>
<span class="lineNum">     265 </span><span class="lineCov">       6244 :     if (child == NULL) return NULL;</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :     /* Make space in the original node. */
<span class="lineNum">     268 </span><span class="lineCov">       6244 :     raxNode *newn = rax_realloc(n,newlen);</span>
<span class="lineNum">     269 </span><span class="lineCov">       6244 :     if (newn == NULL) {</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         rax_free(child);</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     272 </span>            :     }
<span class="lineNum">     273 </span>            :     n = newn;
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :     /* After the reallocation, we have up to 8/16 (depending on the system
<span class="lineNum">     276 </span>            :      * pointer size, and the required node padding) bytes at the end, that is,
<span class="lineNum">     277 </span>            :      * the additional char in the 'data' section, plus one pointer to the new
<span class="lineNum">     278 </span>            :      * child, plus the padding needed in order to store addresses into aligned
<span class="lineNum">     279 </span>            :      * locations.
<span class="lineNum">     280 </span>            :      *
<span class="lineNum">     281 </span>            :      * So if we start with the following node, having &quot;abde&quot; edges.
<span class="lineNum">     282 </span>            :      *
<span class="lineNum">     283 </span>            :      * Note:
<span class="lineNum">     284 </span>            :      * - We assume 4 bytes pointer for simplicity.
<span class="lineNum">     285 </span>            :      * - Each space below corresponds to one byte
<span class="lineNum">     286 </span>            :      *
<span class="lineNum">     287 </span>            :      * [HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|
<span class="lineNum">     288 </span>            :      *
<span class="lineNum">     289 </span>            :      * After the reallocation we need: 1 byte for the new edge character
<span class="lineNum">     290 </span>            :      * plus 4 bytes for a new child pointer (assuming 32 bit machine).
<span class="lineNum">     291 </span>            :      * However after adding 1 byte to the edge char, the header + the edge
<span class="lineNum">     292 </span>            :      * characters are no longer aligned, so we also need 3 bytes of padding.
<span class="lineNum">     293 </span>            :      * In total the reallocation will add 1+4+3 bytes = 8 bytes:
<span class="lineNum">     294 </span>            :      *
<span class="lineNum">     295 </span>            :      * (Blank bytes are represented by &quot;.&quot;)
<span class="lineNum">     296 </span>            :      *
<span class="lineNum">     297 </span>            :      * [HDR*][abde][Aptr][Bptr][Dptr][Eptr]|AUXP|[....][....]
<span class="lineNum">     298 </span>            :      *
<span class="lineNum">     299 </span>            :      * Let's find where to insert the new child in order to make sure
<span class="lineNum">     300 </span>            :      * it is inserted in-place lexicographically. Assuming we are adding
<span class="lineNum">     301 </span>            :      * a child &quot;c&quot; in our case pos will be = 2 after the end of the following
<span class="lineNum">     302 </span>            :      * loop. */
<span class="lineNum">     303 </span>            :     int pos;
<span class="lineNum">     304 </span><span class="lineCov">     205975 :     for (pos = 0; pos &lt; n-&gt;size; pos++) {</span>
<span class="lineNum">     305 </span><span class="lineCov">     199776 :         if (n-&gt;data[pos] &gt; c) break;</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            :     /* Now, if present, move auxiliary data pointer at the end
<span class="lineNum">     309 </span>            :      * so that we can mess with the other data without overwriting it.
<span class="lineNum">     310 </span>            :      * We will obtain something like that:
<span class="lineNum">     311 </span>            :      *
<span class="lineNum">     312 </span>            :      * [HDR*][abde][Aptr][Bptr][Dptr][Eptr][....][....]|AUXP|
<span class="lineNum">     313 </span>            :      */
<span class="lineNum">     314 </span><span class="lineCov">       6244 :     unsigned char *src, *dst;</span>
<span class="lineNum">     315 </span><span class="lineCov">       6244 :     if (n-&gt;iskey &amp;&amp; !n-&gt;isnull) {</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :         src = ((unsigned char*)n+curlen-sizeof(void*));</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         dst = ((unsigned char*)n+newlen-sizeof(void*));</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         memmove(dst,src,sizeof(void*));</span>
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     /* Compute the &quot;shift&quot;, that is, how many bytes we need to move the
<span class="lineNum">     322 </span>            :      * pointers section forward because of the addition of the new child
<span class="lineNum">     323 </span>            :      * byte in the string section. Note that if we had no padding, that
<span class="lineNum">     324 </span>            :      * would be always &quot;1&quot;, since we are adding a single byte in the string
<span class="lineNum">     325 </span>            :      * section of the node (where now there is &quot;abde&quot; basically).
<span class="lineNum">     326 </span>            :      *
<span class="lineNum">     327 </span>            :      * However we have padding, so it could be zero, or up to 8.
<span class="lineNum">     328 </span>            :      *
<span class="lineNum">     329 </span>            :      * Another way to think at the shift is, how many bytes we need to
<span class="lineNum">     330 </span>            :      * move child pointers forward *other than* the obvious sizeof(void*)
<span class="lineNum">     331 </span>            :      * needed for the additional pointer itself. */
<span class="lineNum">     332 </span><span class="lineCov">       6244 :     size_t shift = newlen - curlen - sizeof(void*);</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     /* We said we are adding a node with edge 'c'. The insertion
<span class="lineNum">     335 </span>            :      * point is between 'b' and 'd', so the 'pos' variable value is
<span class="lineNum">     336 </span>            :      * the index of the first child pointer that we need to move forward
<span class="lineNum">     337 </span>            :      * to make space for our new pointer.
<span class="lineNum">     338 </span>            :      *
<span class="lineNum">     339 </span>            :      * To start, move all the child pointers after the insertion point
<span class="lineNum">     340 </span>            :      * of shift+sizeof(pointer) bytes on the right, to obtain:
<span class="lineNum">     341 </span>            :      *
<span class="lineNum">     342 </span>            :      * [HDR*][abde][Aptr][Bptr][....][....][Dptr][Eptr]|AUXP|
<span class="lineNum">     343 </span>            :      */
<span class="lineNum">     344 </span><span class="lineCov">      18732 :     src = n-&gt;data+n-&gt;size+</span>
<span class="lineNum">     345 </span><span class="lineCov">      12488 :           raxPadding(n-&gt;size)+</span>
<span class="lineNum">     346 </span><span class="lineCov">       6244 :           sizeof(raxNode*)*pos;</span>
<span class="lineNum">     347 </span><span class="lineCov">       6244 :     memmove(src+shift+sizeof(raxNode*),src,sizeof(raxNode*)*(n-&gt;size-pos));</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     /* Move the pointers to the left of the insertion position as well. Often
<span class="lineNum">     350 </span>            :      * we don't need to do anything if there was already some padding to use. In
<span class="lineNum">     351 </span>            :      * that case the final destination of the pointers will be the same, however
<span class="lineNum">     352 </span>            :      * in our example there was no pre-existing padding, so we added one byte
<span class="lineNum">     353 </span>            :      * plus thre bytes of padding. After the next memmove() things will look
<span class="lineNum">     354 </span>            :      * like thata:
<span class="lineNum">     355 </span>            :      *
<span class="lineNum">     356 </span>            :      * [HDR*][abde][....][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
<span class="lineNum">     357 </span>            :      */
<span class="lineNum">     358 </span><span class="lineCov">       6244 :     if (shift) {</span>
<span class="lineNum">     359 </span><span class="lineCov">        704 :         src = (unsigned char*) raxNodeFirstChildPtr(n);</span>
<span class="lineNum">     360 </span><span class="lineCov">        704 :         memmove(src+shift,src,sizeof(raxNode*)*pos);</span>
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :     /* Now make the space for the additional char in the data section,
<span class="lineNum">     364 </span>            :      * but also move the pointers before the insertion point to the right
<span class="lineNum">     365 </span>            :      * by shift bytes, in order to obtain the following:
<span class="lineNum">     366 </span>            :      *
<span class="lineNum">     367 </span>            :      * [HDR*][ab.d][e...][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
<span class="lineNum">     368 </span>            :      */
<span class="lineNum">     369 </span><span class="lineCov">       6244 :     src = n-&gt;data+pos;</span>
<span class="lineNum">     370 </span><span class="lineCov">       6244 :     memmove(src+1,src,n-&gt;size-pos);</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :     /* We can now set the character and its child node pointer to get:
<span class="lineNum">     373 </span>            :      *
<span class="lineNum">     374 </span>            :      * [HDR*][abcd][e...][Aptr][Bptr][....][Dptr][Eptr]|AUXP|
<span class="lineNum">     375 </span>            :      * [HDR*][abcd][e...][Aptr][Bptr][Cptr][Dptr][Eptr]|AUXP|
<span class="lineNum">     376 </span>            :      */
<span class="lineNum">     377 </span><span class="lineCov">       6244 :     n-&gt;data[pos] = c;</span>
<span class="lineNum">     378 </span><span class="lineCov">       6244 :     n-&gt;size++;</span>
<span class="lineNum">     379 </span><span class="lineCov">       6244 :     src = (unsigned char*) raxNodeFirstChildPtr(n);</span>
<span class="lineNum">     380 </span><span class="lineCov">       6244 :     raxNode **childfield = (raxNode**)(src+sizeof(raxNode*)*pos);</span>
<span class="lineNum">     381 </span><span class="lineCov">       6244 :     memcpy(childfield,&amp;child,sizeof(child));</span>
<span class="lineNum">     382 </span><span class="lineCov">       6244 :     *childptr = child;</span>
<span class="lineNum">     383 </span><span class="lineCov">       6244 :     *parentlink = childfield;</span>
<span class="lineNum">     384 </span><span class="lineCov">       6244 :     return n;</span>
<span class="lineNum">     385 </span>            : }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            : /* Turn the node 'n', that must be a node without any children, into a
<span class="lineNum">     388 </span>            :  * compressed node representing a set of nodes linked one after the other
<span class="lineNum">     389 </span>            :  * and having exactly one child each. The node can be a key or not: this
<span class="lineNum">     390 </span>            :  * property and the associated value if any will be preserved.
<span class="lineNum">     391 </span>            :  *
<span class="lineNum">     392 </span>            :  * The function also returns a child node, since the last node of the
<a name="393"><span class="lineNum">     393 </span>            :  * compressed chain cannot be part of the chain: it has zero children while</a>
<span class="lineNum">     394 </span>            :  * we can only compress inner nodes with exactly one child each. */
<span class="lineNum">     395 </span><span class="lineCov">       3804 : raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {</span>
<span class="lineNum">     396 </span><span class="lineCov">       3804 :     assert(n-&gt;size == 0 &amp;&amp; n-&gt;iscompr == 0);</span>
<span class="lineNum">     397 </span><span class="lineCov">       3804 :     void *data = NULL; /* Initialized only to avoid warnings. */</span>
<span class="lineNum">     398 </span><span class="lineCov">       3804 :     size_t newsize;</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">       3804 :     debugf(&quot;Compress node: %.*s\n&quot;, (int)len,s);</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :     /* Allocate the child to link to this node. */
<span class="lineNum">     403 </span><span class="lineCov">       3804 :     *child = raxNewNode(0,0);</span>
<span class="lineNum">     404 </span><span class="lineCov">       3804 :     if (*child == NULL) return NULL;</span>
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :     /* Make space in the parent node. */
<span class="lineNum">     407 </span><span class="lineCov">       3804 :     newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);</span>
<span class="lineNum">     408 </span><span class="lineCov">       3804 :     if (n-&gt;iskey) {</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         data = raxGetData(n); /* To restore it later. */</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :         if (!n-&gt;isnull) newsize += sizeof(void*);</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span><span class="lineCov">       3804 :     raxNode *newn = rax_realloc(n,newsize);</span>
<span class="lineNum">     413 </span><span class="lineCov">       3804 :     if (newn == NULL) {</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         rax_free(*child);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     416 </span>            :     }
<span class="lineNum">     417 </span><span class="lineCov">       3804 :     n = newn;</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineCov">       3804 :     n-&gt;iscompr = 1;</span>
<span class="lineNum">     420 </span><span class="lineCov">       3804 :     n-&gt;size = len;</span>
<span class="lineNum">     421 </span><span class="lineCov">       3804 :     memcpy(n-&gt;data,s,len);</span>
<span class="lineNum">     422 </span><span class="lineCov">       3804 :     if (n-&gt;iskey) raxSetData(n,data);</span>
<span class="lineNum">     423 </span><span class="lineCov">       3804 :     raxNode **childfield = raxNodeLastChildPtr(n);</span>
<span class="lineNum">     424 </span><span class="lineCov">       3804 :     memcpy(childfield,child,sizeof(*child));</span>
<span class="lineNum">     425 </span><span class="lineCov">       3804 :     return n;</span>
<span class="lineNum">     426 </span>            : }
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : /* Low level function that walks the tree looking for the string
<span class="lineNum">     429 </span>            :  * 's' of 'len' bytes. The function returns the number of characters
<span class="lineNum">     430 </span>            :  * of the key that was possible to process: if the returned integer
<span class="lineNum">     431 </span>            :  * is the same as 'len', then it means that the node corresponding to the
<span class="lineNum">     432 </span>            :  * string was found (however it may not be a key in case the node-&gt;iskey is
<span class="lineNum">     433 </span>            :  * zero or if simply we stopped in the middle of a compressed node, so that
<span class="lineNum">     434 </span>            :  * 'splitpos' is non zero).
<span class="lineNum">     435 </span>            :  *
<span class="lineNum">     436 </span>            :  * Otherwise if the returned integer is not the same as 'len', there was an
<span class="lineNum">     437 </span>            :  * early stop during the tree walk because of a character mismatch.
<span class="lineNum">     438 </span>            :  *
<span class="lineNum">     439 </span>            :  * The node where the search ended (because the full string was processed
<span class="lineNum">     440 </span>            :  * or because there was an early stop) is returned by reference as
<span class="lineNum">     441 </span>            :  * '*stopnode' if the passed pointer is not NULL. This node link in the
<span class="lineNum">     442 </span>            :  * parent's node is returned as '*plink' if not NULL. Finally, if the
<span class="lineNum">     443 </span>            :  * search stopped in a compressed node, '*splitpos' returns the index
<span class="lineNum">     444 </span>            :  * inside the compressed node where the search ended. This is useful to
<span class="lineNum">     445 </span>            :  * know where to split the node for insertion.
<span class="lineNum">     446 </span>            :  *
<span class="lineNum">     447 </span>            :  * Note that when we stop in the middle of a compressed node with
<span class="lineNum">     448 </span>            :  * a perfect match, this function will return a length equal to the
<span class="lineNum">     449 </span>            :  * 'len' argument (all the key matched), and will return a *splitpos which is
<span class="lineNum">     450 </span>            :  * always positive (that will represent the index of the character immediately
<span class="lineNum">     451 </span>            :  * *after* the last match in the current compressed node).
<span class="lineNum">     452 </span>            :  *
<span class="lineNum">     453 </span>            :  * When instead we stop at a compressed node and *splitpos is zero, it
<span class="lineNum">     454 </span>            :  * means that the current node represents the key (that is, none of the
<a name="455"><span class="lineNum">     455 </span>            :  * compressed node characters are needed to represent the key, just all</a>
<span class="lineNum">     456 </span>            :  * its parents nodes). */
<span class="lineNum">     457 </span><span class="lineCov">      68366 : static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {</span>
<span class="lineNum">     458 </span><span class="lineCov">      68366 :     raxNode *h = rax-&gt;head;</span>
<span class="lineNum">     459 </span><span class="lineCov">      68366 :     raxNode **parentlink = &amp;rax-&gt;head;</span>
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineCov">      68366 :     size_t i = 0; /* Position in the string. */</span>
<span class="lineNum">     462 </span><span class="lineCov">      68366 :     size_t j = 0; /* Position in the node children (or bytes if compressed).*/</span>
<span class="lineNum">     463 </span><span class="lineCov">     221248 :     while(h-&gt;size &amp;&amp; i &lt; len) {</span>
<span class="lineNum">     464 </span><span class="lineCov">     178140 :         debugnode(&quot;Lookup current node&quot;,h);</span>
<span class="lineNum">     465 </span><span class="lineCov">     178140 :         unsigned char *v = h-&gt;data;</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineCov">     178140 :         if (h-&gt;iscompr) {</span>
<span class="lineNum">     468 </span><span class="lineCov">     664293 :             for (j = 0; j &lt; h-&gt;size &amp;&amp; i &lt; len; j++, i++) {</span>
<span class="lineNum">     469 </span><span class="lineCov">     588338 :                 if (v[j] != s[i]) break;</span>
<span class="lineNum">     470 </span>            :             }
<span class="lineNum">     471 </span><span class="lineCov">      85612 :             if (j != h-&gt;size) break;</span>
<span class="lineNum">     472 </span>            :         } else {
<span class="lineNum">     473 </span>            :             /* Even when h-&gt;size is large, linear scan provides good
<span class="lineNum">     474 </span>            :              * performances compared to other approaches that are in theory
<span class="lineNum">     475 </span>            :              * more sounding, like performing a binary search. */
<span class="lineNum">     476 </span><span class="lineCov">    2441993 :             for (j = 0; j &lt; h-&gt;size; j++) {</span>
<span class="lineNum">     477 </span><span class="lineCov">    2426392 :                 if (v[j] == s[i]) break;</span>
<span class="lineNum">     478 </span>            :             }
<span class="lineNum">     479 </span><span class="lineCov">      92528 :             if (j == h-&gt;size) break;</span>
<span class="lineNum">     480 </span><span class="lineCov">      76927 :             i++;</span>
<span class="lineNum">     481 </span>            :         }
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">     152882 :         if (ts) raxStackPush(ts,h); /* Save stack of parent nodes. */</span>
<span class="lineNum">     484 </span><span class="lineCov">     152882 :         raxNode **children = raxNodeFirstChildPtr(h);</span>
<span class="lineNum">     485 </span><span class="lineCov">     152882 :         if (h-&gt;iscompr) j = 0; /* Compressed node only child is at index 0. */</span>
<span class="lineNum">     486 </span><span class="lineCov">     152882 :         memcpy(&amp;h,children+j,sizeof(h));</span>
<span class="lineNum">     487 </span><span class="lineCov">     152882 :         parentlink = children+j;</span>
<span class="lineNum">     488 </span><span class="lineCov">     152882 :         j = 0; /* If the new node is compressed and we do not</span>
<span class="lineNum">     489 </span>            :                   iterate again (since i == l) set the split
<span class="lineNum">     490 </span>            :                   position to 0 to signal this node represents
<span class="lineNum">     491 </span>            :                   the searched key. */
<span class="lineNum">     492 </span>            :     }
<span class="lineNum">     493 </span><span class="lineCov">      68366 :     debugnode(&quot;Lookup stop node is&quot;,h);</span>
<span class="lineNum">     494 </span><span class="lineCov">      68366 :     if (stopnode) *stopnode = h;</span>
<span class="lineNum">     495 </span><span class="lineCov">      68366 :     if (plink) *plink = parentlink;</span>
<span class="lineNum">     496 </span><span class="lineCov">      68366 :     if (splitpos &amp;&amp; h-&gt;iscompr) *splitpos = j;</span>
<span class="lineNum">     497 </span><span class="lineCov">      68366 :     return i;</span>
<span class="lineNum">     498 </span>            : }
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            : /* Insert the element 's' of size 'len', setting as auxiliary data
<span class="lineNum">     501 </span>            :  * the pointer 'data'. If the element is already present, the associated
<span class="lineNum">     502 </span>            :  * data is updated (only if 'overwrite' is set to 1), and 0 is returned,
<span class="lineNum">     503 </span>            :  * otherwise the element is inserted and 1 is returned. On out of memory the
<span class="lineNum">     504 </span>            :  * function returns 0 as well but sets errno to ENOMEM, otherwise errno will
<a name="505"><span class="lineNum">     505 </span>            :  * be set to 0.</a>
<span class="lineNum">     506 </span>            :  */
<span class="lineNum">     507 </span><span class="lineCov">      37066 : int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {</span>
<span class="lineNum">     508 </span><span class="lineCov">      37066 :     size_t i;</span>
<span class="lineNum">     509 </span><span class="lineCov">      37066 :     int j = 0; /* Split position. If raxLowWalk() stops in a compressed</span>
<span class="lineNum">     510 </span>            :                   node, the index 'j' represents the char we stopped within the
<span class="lineNum">     511 </span>            :                   compressed node, that is, the position where to split the
<span class="lineNum">     512 </span>            :                   node for insertion. */
<span class="lineNum">     513 </span><span class="lineCov">      37066 :     raxNode *h, **parentlink;</span>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineCov">      37066 :     debugf(&quot;### Insert %.*s with value %p\n&quot;, (int)len, s, data);</span>
<span class="lineNum">     516 </span><span class="lineCov">      37066 :     i = raxLowWalk(rax,s,len,&amp;h,&amp;parentlink,&amp;j,NULL);</span>
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            :     /* If i == len we walked following the whole string. If we are not
<span class="lineNum">     519 </span>            :      * in the middle of a compressed node, the string is either already
<span class="lineNum">     520 </span>            :      * inserted or this middle node is currently not a key, but can represent
<span class="lineNum">     521 </span>            :      * our key. We have just to reallocate the node and make space for the
<span class="lineNum">     522 </span>            :      * data pointer. */
<span class="lineNum">     523 </span><span class="lineCov">      37066 :     if (i == len &amp;&amp; (!h-&gt;iscompr || j == 0 /* not in the middle if j is 0 */)) {</span>
<span class="lineNum">     524 </span><span class="lineCov">      29089 :         debugf(&quot;### Insert: node representing key exists\n&quot;);</span>
<span class="lineNum">     525 </span>            :         /* Make space for the value pointer if needed. */
<span class="lineNum">     526 </span><span class="lineCov">      29089 :         if (!h-&gt;iskey || (h-&gt;isnull &amp;&amp; overwrite)) {</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :             h = raxReallocForData(h,data);</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :             if (h) memcpy(parentlink,&amp;h,sizeof(h));</span>
<span class="lineNum">     529 </span>            :         }
<span class="lineNum">     530 </span><span class="lineCov">      29089 :         if (h == NULL) {</span>
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :             errno = ENOMEM;</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :         /* Update the existing key if there is already one. */
<span class="lineNum">     536 </span><span class="lineCov">      29089 :         if (h-&gt;iskey) {</span>
<span class="lineNum">     537 </span><span class="lineCov">      29089 :             if (old) *old = raxGetData(h);</span>
<span class="lineNum">     538 </span><span class="lineCov">      29089 :             if (overwrite) raxSetData(h,data);</span>
<span class="lineNum">     539 </span><span class="lineCov">      29089 :             errno = 0;</span>
<span class="lineNum">     540 </span><span class="lineCov">      29089 :             return 0; /* Element already exists. */</span>
<span class="lineNum">     541 </span>            :         }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :         /* Otherwise set the node as a key. Note that raxSetData()
<span class="lineNum">     544 </span>            :          * will set h-&gt;iskey. */
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         raxSetData(h,data);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         rax-&gt;numele++;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         return 1; /* Element inserted. */</span>
<span class="lineNum">     548 </span>            :     }
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :     /* If the node we stopped at is a compressed node, we need to
<span class="lineNum">     551 </span>            :      * split it before to continue.
<span class="lineNum">     552 </span>            :      *
<span class="lineNum">     553 </span>            :      * Splitting a compressed node have a few possible cases.
<span class="lineNum">     554 </span>            :      * Imagine that the node 'h' we are currently at is a compressed
<span class="lineNum">     555 </span>            :      * node contaning the string &quot;ANNIBALE&quot; (it means that it represents
<span class="lineNum">     556 </span>            :      * nodes A -&gt; N -&gt; N -&gt; I -&gt; B -&gt; A -&gt; L -&gt; E with the only child
<span class="lineNum">     557 </span>            :      * pointer of this node pointing at the 'E' node, because remember that
<span class="lineNum">     558 </span>            :      * we have characters at the edges of the graph, not inside the nodes
<span class="lineNum">     559 </span>            :      * themselves.
<span class="lineNum">     560 </span>            :      *
<span class="lineNum">     561 </span>            :      * In order to show a real case imagine our node to also point to
<span class="lineNum">     562 </span>            :      * another compressed node, that finally points at the node without
<span class="lineNum">     563 </span>            :      * children, representing 'O':
<span class="lineNum">     564 </span>            :      *
<span class="lineNum">     565 </span>            :      *     &quot;ANNIBALE&quot; -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     566 </span>            :      *
<span class="lineNum">     567 </span>            :      * When inserting we may face the following cases. Note that all the cases
<span class="lineNum">     568 </span>            :      * require the insertion of a non compressed node with exactly two
<span class="lineNum">     569 </span>            :      * children, except for the last case which just requires splitting a
<span class="lineNum">     570 </span>            :      * compressed node.
<span class="lineNum">     571 </span>            :      *
<span class="lineNum">     572 </span>            :      * 1) Inserting &quot;ANNIENTARE&quot;
<span class="lineNum">     573 </span>            :      *
<span class="lineNum">     574 </span>            :      *               |B| -&gt; &quot;ALE&quot; -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     575 </span>            :      *     &quot;ANNI&quot; -&gt; |-|
<span class="lineNum">     576 </span>            :      *               |E| -&gt; (... continue algo ...) &quot;NTARE&quot; -&gt; []
<span class="lineNum">     577 </span>            :      *
<span class="lineNum">     578 </span>            :      * 2) Inserting &quot;ANNIBALI&quot;
<span class="lineNum">     579 </span>            :      *
<span class="lineNum">     580 </span>            :      *                  |E| -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     581 </span>            :      *     &quot;ANNIBAL&quot; -&gt; |-|
<span class="lineNum">     582 </span>            :      *                  |I| -&gt; (... continue algo ...) []
<span class="lineNum">     583 </span>            :      *
<span class="lineNum">     584 </span>            :      * 3) Inserting &quot;AGO&quot; (Like case 1, but set iscompr = 0 into original node)
<span class="lineNum">     585 </span>            :      *
<span class="lineNum">     586 </span>            :      *            |N| -&gt; &quot;NIBALE&quot; -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     587 </span>            :      *     |A| -&gt; |-|
<span class="lineNum">     588 </span>            :      *            |G| -&gt; (... continue algo ...) |O| -&gt; []
<span class="lineNum">     589 </span>            :      *
<span class="lineNum">     590 </span>            :      * 4) Inserting &quot;CIAO&quot;
<span class="lineNum">     591 </span>            :      *
<span class="lineNum">     592 </span>            :      *     |A| -&gt; &quot;NNIBALE&quot; -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     593 </span>            :      *     |-|
<span class="lineNum">     594 </span>            :      *     |C| -&gt; (... continue algo ...) &quot;IAO&quot; -&gt; []
<span class="lineNum">     595 </span>            :      *
<span class="lineNum">     596 </span>            :      * 5) Inserting &quot;ANNI&quot;
<span class="lineNum">     597 </span>            :      *
<span class="lineNum">     598 </span>            :      *     &quot;ANNI&quot; -&gt; &quot;BALE&quot; -&gt; &quot;SCO&quot; -&gt; []
<span class="lineNum">     599 </span>            :      *
<span class="lineNum">     600 </span>            :      * The final algorithm for insertion covering all the above cases is as
<span class="lineNum">     601 </span>            :      * follows.
<span class="lineNum">     602 </span>            :      *
<span class="lineNum">     603 </span>            :      * ============================= ALGO 1 =============================
<span class="lineNum">     604 </span>            :      *
<span class="lineNum">     605 </span>            :      * For the above cases 1 to 4, that is, all cases where we stopped in
<span class="lineNum">     606 </span>            :      * the middle of a compressed node for a character mismatch, do:
<span class="lineNum">     607 </span>            :      *
<span class="lineNum">     608 </span>            :      * Let $SPLITPOS be the zero-based index at which, in the
<span class="lineNum">     609 </span>            :      * compressed node array of characters, we found the mismatching
<span class="lineNum">     610 </span>            :      * character. For example if the node contains &quot;ANNIBALE&quot; and we add
<span class="lineNum">     611 </span>            :      * &quot;ANNIENTARE&quot; the $SPLITPOS is 4, that is, the index at which the
<span class="lineNum">     612 </span>            :      * mismatching character is found.
<span class="lineNum">     613 </span>            :      *
<span class="lineNum">     614 </span>            :      * 1. Save the current compressed node $NEXT pointer (the pointer to the
<span class="lineNum">     615 </span>            :      *    child element, that is always present in compressed nodes).
<span class="lineNum">     616 </span>            :      *
<span class="lineNum">     617 </span>            :      * 2. Create &quot;split node&quot; having as child the non common letter
<span class="lineNum">     618 </span>            :      *    at the compressed node. The other non common letter (at the key)
<span class="lineNum">     619 </span>            :      *    will be added later as we continue the normal insertion algorithm
<span class="lineNum">     620 </span>            :      *    at step &quot;6&quot;.
<span class="lineNum">     621 </span>            :      *
<span class="lineNum">     622 </span>            :      * 3a. IF $SPLITPOS == 0:
<span class="lineNum">     623 </span>            :      *     Replace the old node with the split node, by copying the auxiliary
<span class="lineNum">     624 </span>            :      *     data if any. Fix parent's reference. Free old node eventually
<span class="lineNum">     625 </span>            :      *     (we still need its data for the next steps of the algorithm).
<span class="lineNum">     626 </span>            :      *
<span class="lineNum">     627 </span>            :      * 3b. IF $SPLITPOS != 0:
<span class="lineNum">     628 </span>            :      *     Trim the compressed node (reallocating it as well) in order to
<span class="lineNum">     629 </span>            :      *     contain $splitpos characters. Change chilid pointer in order to link
<span class="lineNum">     630 </span>            :      *     to the split node. If new compressed node len is just 1, set
<span class="lineNum">     631 </span>            :      *     iscompr to 0 (layout is the same). Fix parent's reference.
<span class="lineNum">     632 </span>            :      *
<span class="lineNum">     633 </span>            :      * 4a. IF the postfix len (the length of the remaining string of the
<span class="lineNum">     634 </span>            :      *     original compressed node after the split character) is non zero,
<span class="lineNum">     635 </span>            :      *     create a &quot;postfix node&quot;. If the postfix node has just one character
<span class="lineNum">     636 </span>            :      *     set iscompr to 0, otherwise iscompr to 1. Set the postfix node
<span class="lineNum">     637 </span>            :      *     child pointer to $NEXT.
<span class="lineNum">     638 </span>            :      *
<span class="lineNum">     639 </span>            :      * 4b. IF the postfix len is zero, just use $NEXT as postfix pointer.
<span class="lineNum">     640 </span>            :      *
<span class="lineNum">     641 </span>            :      * 5. Set child[0] of split node to postfix node.
<span class="lineNum">     642 </span>            :      *
<span class="lineNum">     643 </span>            :      * 6. Set the split node as the current node, set current index at child[1]
<span class="lineNum">     644 </span>            :      *    and continue insertion algorithm as usually.
<span class="lineNum">     645 </span>            :      *
<span class="lineNum">     646 </span>            :      * ============================= ALGO 2 =============================
<span class="lineNum">     647 </span>            :      *
<span class="lineNum">     648 </span>            :      * For case 5, that is, if we stopped in the middle of a compressed
<span class="lineNum">     649 </span>            :      * node but no mismatch was found, do:
<span class="lineNum">     650 </span>            :      *
<span class="lineNum">     651 </span>            :      * Let $SPLITPOS be the zero-based index at which, in the
<span class="lineNum">     652 </span>            :      * compressed node array of characters, we stopped iterating because
<span class="lineNum">     653 </span>            :      * there were no more keys character to match. So in the example of
<span class="lineNum">     654 </span>            :      * the node &quot;ANNIBALE&quot;, addig the string &quot;ANNI&quot;, the $SPLITPOS is 4.
<span class="lineNum">     655 </span>            :      *
<span class="lineNum">     656 </span>            :      * 1. Save the current compressed node $NEXT pointer (the pointer to the
<span class="lineNum">     657 </span>            :      *    child element, that is always present in compressed nodes).
<span class="lineNum">     658 </span>            :      *
<span class="lineNum">     659 </span>            :      * 2. Create a &quot;postfix node&quot; containing all the characters from $SPLITPOS
<span class="lineNum">     660 </span>            :      *    to the end. Use $NEXT as the postfix node child pointer.
<span class="lineNum">     661 </span>            :      *    If the postfix node length is 1, set iscompr to 0.
<span class="lineNum">     662 </span>            :      *    Set the node as a key with the associated value of the new
<span class="lineNum">     663 </span>            :      *    inserted key.
<span class="lineNum">     664 </span>            :      *
<span class="lineNum">     665 </span>            :      * 3. Trim the current node to contain the first $SPLITPOS characters.
<span class="lineNum">     666 </span>            :      *    As usually if the new node length is just 1, set iscompr to 0.
<span class="lineNum">     667 </span>            :      *    Take the iskey / associated value as it was in the orignal node.
<span class="lineNum">     668 </span>            :      *    Fix the parent's reference.
<span class="lineNum">     669 </span>            :      *
<span class="lineNum">     670 </span>            :      * 4. Set the postfix node as the only child pointer of the trimmed
<span class="lineNum">     671 </span>            :      *    node created at step 1.
<span class="lineNum">     672 </span>            :      */
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :     /* ------------------------- ALGORITHM 1 --------------------------- */
<span class="lineNum">     675 </span><span class="lineCov">       7977 :     if (h-&gt;iscompr &amp;&amp; i != len) {</span>
<span class="lineNum">     676 </span>            :         debugf(&quot;ALGO 1: Stopped at compressed node %.*s (%p)\n&quot;,
<span class="lineNum">     677 </span><span class="lineCov">       2089 :             h-&gt;size, h-&gt;data, (void*)h);</span>
<span class="lineNum">     678 </span><span class="lineCov">       2089 :         debugf(&quot;Still to insert: %.*s\n&quot;, (int)(len-i), s+i);</span>
<span class="lineNum">     679 </span><span class="lineCov">       2089 :         debugf(&quot;Splitting at %d: '%c'\n&quot;, j, ((char*)h-&gt;data)[j]);</span>
<span class="lineNum">     680 </span><span class="lineCov">       2089 :         debugf(&quot;Other (key) letter is '%c'\n&quot;, s[i]);</span>
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            :         /* 1: Save next pointer. */
<span class="lineNum">     683 </span><span class="lineCov">       2089 :         raxNode **childfield = raxNodeLastChildPtr(h);</span>
<span class="lineNum">     684 </span><span class="lineCov">       2089 :         raxNode *next;</span>
<span class="lineNum">     685 </span><span class="lineCov">       2089 :         memcpy(&amp;next,childfield,sizeof(next));</span>
<span class="lineNum">     686 </span><span class="lineCov">       2089 :         debugf(&quot;Next is %p\n&quot;, (void*)next);</span>
<span class="lineNum">     687 </span><span class="lineCov">       2089 :         debugf(&quot;iskey %d\n&quot;, h-&gt;iskey);</span>
<span class="lineNum">     688 </span><span class="lineCov">       2089 :         if (h-&gt;iskey) {</span>
<span class="lineNum">     689 </span><span class="lineCov">       2089 :             debugf(&quot;key value is %p\n&quot;, raxGetData(h));</span>
<span class="lineNum">     690 </span>            :         }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :         /* Set the length of the additional nodes we will need. */
<span class="lineNum">     693 </span><span class="lineCov">       2089 :         size_t trimmedlen = j;</span>
<span class="lineNum">     694 </span><span class="lineCov">       2089 :         size_t postfixlen = h-&gt;size - j - 1;</span>
<span class="lineNum">     695 </span><span class="lineCov">       2089 :         int split_node_is_key = !trimmedlen &amp;&amp; h-&gt;iskey &amp;&amp; !h-&gt;isnull;</span>
<span class="lineNum">     696 </span><span class="lineCov">       2089 :         size_t nodesize;</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :         /* 2: Create the split node. Also allocate the other nodes we'll need
<span class="lineNum">     699 </span>            :          *    ASAP, so that it will be simpler to handle OOM. */
<span class="lineNum">     700 </span><span class="lineCov">       2089 :         raxNode *splitnode = raxNewNode(1, split_node_is_key);</span>
<span class="lineNum">     701 </span><span class="lineCov">       2089 :         raxNode *trimmed = NULL;</span>
<span class="lineNum">     702 </span><span class="lineCov">       2089 :         raxNode *postfix = NULL;</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineCov">       2089 :         if (trimmedlen) {</span>
<span class="lineNum">     705 </span><span class="lineCov">       2078 :             nodesize = sizeof(raxNode)+trimmedlen+raxPadding(trimmedlen)+</span>
<span class="lineNum">     706 </span>            :                        sizeof(raxNode*);
<span class="lineNum">     707 </span><span class="lineCov">       2078 :             if (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += sizeof(void*);</span>
<span class="lineNum">     708 </span><span class="lineCov">       2078 :             trimmed = rax_malloc(nodesize);</span>
<span class="lineNum">     709 </span>            :         }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">       2089 :         if (postfixlen) {</span>
<span class="lineNum">     712 </span><span class="lineCov">         67 :             nodesize = sizeof(raxNode)+postfixlen+raxPadding(postfixlen)+</span>
<span class="lineNum">     713 </span>            :                        sizeof(raxNode*);
<span class="lineNum">     714 </span><span class="lineCov">         67 :             postfix = rax_malloc(nodesize);</span>
<span class="lineNum">     715 </span>            :         }
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :         /* OOM? Abort now that the tree is untouched. */
<span class="lineNum">     718 </span><span class="lineCov">       2089 :         if (splitnode == NULL ||</span>
<span class="lineNum">     719 </span><span class="lineCov">       2089 :             (trimmedlen &amp;&amp; trimmed == NULL) ||</span>
<span class="lineNum">     720 </span><span class="lineCov">       2089 :             (postfixlen &amp;&amp; postfix == NULL))</span>
<span class="lineNum">     721 </span>            :         {
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :             rax_free(splitnode);</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :             rax_free(trimmed);</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :             rax_free(postfix);</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :             errno = ENOMEM;</span>
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     727 </span>            :         }
<span class="lineNum">     728 </span><span class="lineCov">       2089 :         splitnode-&gt;data[0] = h-&gt;data[j];</span>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">       2089 :         if (j == 0) {</span>
<span class="lineNum">     731 </span>            :             /* 3a: Replace the old node with the split node. */
<span class="lineNum">     732 </span><span class="lineCov">         11 :             if (h-&gt;iskey) {</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :                 void *ndata = raxGetData(h);</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                 raxSetData(splitnode,ndata);</span>
<span class="lineNum">     735 </span>            :             }
<span class="lineNum">     736 </span><span class="lineCov">         11 :             memcpy(parentlink,&amp;splitnode,sizeof(splitnode));</span>
<span class="lineNum">     737 </span>            :         } else {
<span class="lineNum">     738 </span>            :             /* 3b: Trim the compressed node. */
<span class="lineNum">     739 </span><span class="lineCov">       2078 :             trimmed-&gt;size = j;</span>
<span class="lineNum">     740 </span><span class="lineCov">       2078 :             memcpy(trimmed-&gt;data,h-&gt;data,j);</span>
<span class="lineNum">     741 </span><span class="lineCov">       2078 :             trimmed-&gt;iscompr = j &gt; 1 ? 1 : 0;</span>
<span class="lineNum">     742 </span><span class="lineCov">       2078 :             trimmed-&gt;iskey = h-&gt;iskey;</span>
<span class="lineNum">     743 </span><span class="lineCov">       2078 :             trimmed-&gt;isnull = h-&gt;isnull;</span>
<span class="lineNum">     744 </span><span class="lineCov">       2078 :             if (h-&gt;iskey &amp;&amp; !h-&gt;isnull) {</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                 void *ndata = raxGetData(h);</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :                 raxSetData(trimmed,ndata);</span>
<span class="lineNum">     747 </span>            :             }
<span class="lineNum">     748 </span><span class="lineCov">       2078 :             raxNode **cp = raxNodeLastChildPtr(trimmed);</span>
<span class="lineNum">     749 </span><span class="lineCov">       2078 :             memcpy(cp,&amp;splitnode,sizeof(splitnode));</span>
<span class="lineNum">     750 </span><span class="lineCov">       2078 :             memcpy(parentlink,&amp;trimmed,sizeof(trimmed));</span>
<span class="lineNum">     751 </span><span class="lineCov">       2078 :             parentlink = cp; /* Set parentlink to splitnode parent. */</span>
<span class="lineNum">     752 </span><span class="lineCov">       2078 :             rax-&gt;numnodes++;</span>
<span class="lineNum">     753 </span>            :         }
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            :         /* 4: Create the postfix node: what remains of the original
<span class="lineNum">     756 </span>            :          * compressed node after the split. */
<span class="lineNum">     757 </span><span class="lineCov">       2089 :         if (postfixlen) {</span>
<span class="lineNum">     758 </span>            :             /* 4a: create a postfix node. */
<span class="lineNum">     759 </span><span class="lineCov">         67 :             postfix-&gt;iskey = 0;</span>
<span class="lineNum">     760 </span><span class="lineCov">         67 :             postfix-&gt;isnull = 0;</span>
<span class="lineNum">     761 </span><span class="lineCov">         67 :             postfix-&gt;size = postfixlen;</span>
<span class="lineNum">     762 </span><span class="lineCov">         67 :             postfix-&gt;iscompr = postfixlen &gt; 1;</span>
<span class="lineNum">     763 </span><span class="lineCov">         67 :             memcpy(postfix-&gt;data,h-&gt;data+j+1,postfixlen);</span>
<span class="lineNum">     764 </span><span class="lineCov">         67 :             raxNode **cp = raxNodeLastChildPtr(postfix);</span>
<span class="lineNum">     765 </span><span class="lineCov">         67 :             memcpy(cp,&amp;next,sizeof(next));</span>
<span class="lineNum">     766 </span><span class="lineCov">         67 :             rax-&gt;numnodes++;</span>
<span class="lineNum">     767 </span>            :         } else {
<span class="lineNum">     768 </span>            :             /* 4b: just use next as postfix node. */
<span class="lineNum">     769 </span><span class="lineCov">       2022 :             postfix = next;</span>
<span class="lineNum">     770 </span>            :         }
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            :         /* 5: Set splitnode first child as the postfix node. */
<span class="lineNum">     773 </span><span class="lineCov">       2089 :         raxNode **splitchild = raxNodeLastChildPtr(splitnode);</span>
<span class="lineNum">     774 </span><span class="lineCov">       2089 :         memcpy(splitchild,&amp;postfix,sizeof(postfix));</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :         /* 6. Continue insertion: this will cause the splitnode to
<span class="lineNum">     777 </span>            :          * get a new child (the non common character at the currently
<span class="lineNum">     778 </span>            :          * inserted key). */
<span class="lineNum">     779 </span><span class="lineCov">       2089 :         rax_free(h);</span>
<span class="lineNum">     780 </span><span class="lineCov">       2089 :         h = splitnode;</span>
<span class="lineNum">     781 </span><span class="lineCov">       5888 :     } else if (h-&gt;iscompr &amp;&amp; i == len) {</span>
<span class="lineNum">     782 </span>            :     /* ------------------------- ALGORITHM 2 --------------------------- */
<span class="lineNum">     783 </span>            :         debugf(&quot;ALGO 2: Stopped at compressed node %.*s (%p) j = %d\n&quot;,
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :             h-&gt;size, h-&gt;data, (void*)h, j);</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :         /* Allocate postfix &amp; trimmed nodes ASAP to fail for OOM gracefully. */
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :         size_t postfixlen = h-&gt;size - j;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :         size_t nodesize = sizeof(raxNode)+postfixlen+raxPadding(postfixlen)+</span>
<span class="lineNum">     789 </span>            :                           sizeof(raxNode*);
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         if (data != NULL) nodesize += sizeof(void*);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         raxNode *postfix = rax_malloc(nodesize);</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         nodesize = sizeof(raxNode)+j+raxPadding(j)+sizeof(raxNode*);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         if (h-&gt;iskey &amp;&amp; !h-&gt;isnull) nodesize += sizeof(void*);</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :         raxNode *trimmed = rax_malloc(nodesize);</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :         if (postfix == NULL || trimmed == NULL) {</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             rax_free(postfix);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :             rax_free(trimmed);</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :             errno = ENOMEM;</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :         /* 1: Save next pointer. */
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         raxNode **childfield = raxNodeLastChildPtr(h);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         raxNode *next;</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :         memcpy(&amp;next,childfield,sizeof(next));</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :         /* 2: Create the postfix node. */
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         postfix-&gt;size = postfixlen;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :         postfix-&gt;iscompr = postfixlen &gt; 1;</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         postfix-&gt;iskey = 1;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         postfix-&gt;isnull = 0;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         memcpy(postfix-&gt;data,h-&gt;data+j,postfixlen);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :         raxSetData(postfix,data);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :         raxNode **cp = raxNodeLastChildPtr(postfix);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :         memcpy(cp,&amp;next,sizeof(next));</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :         rax-&gt;numnodes++;</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :         /* 3: Trim the compressed node. */
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         trimmed-&gt;size = j;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         trimmed-&gt;iscompr = j &gt; 1;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         trimmed-&gt;iskey = 0;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         trimmed-&gt;isnull = 0;</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         memcpy(trimmed-&gt;data,h-&gt;data,j);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         memcpy(parentlink,&amp;trimmed,sizeof(trimmed));</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         if (h-&gt;iskey) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :             void *aux = raxGetData(h);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :             raxSetData(trimmed,aux);</span>
<span class="lineNum">     830 </span>            :         }
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :         /* Fix the trimmed node child pointer to point to
<span class="lineNum">     833 </span>            :          * the postfix node. */
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         cp = raxNodeLastChildPtr(trimmed);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :         memcpy(cp,&amp;postfix,sizeof(postfix));</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :         /* Finish! We don't need to continue with the insertion
<span class="lineNum">     838 </span>            :          * algorithm for ALGO 2. The key is already inserted. */
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :         rax-&gt;numele++;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :         rax_free(h);</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :         return 1; /* Key inserted. */</span>
<span class="lineNum">     842 </span>            :     }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :     /* We walked the radix tree as far as we could, but still there are left
<span class="lineNum">     845 </span>            :      * chars in our string. We need to insert the missing nodes. */
<span class="lineNum">     846 </span><span class="lineCov">      18025 :     while(i &lt; len) {</span>
<span class="lineNum">     847 </span><span class="lineCov">      10048 :         raxNode *child;</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            :         /* If this node is going to have a single child, and there
<span class="lineNum">     850 </span>            :          * are other characters, so that that would result in a chain
<span class="lineNum">     851 </span>            :          * of single-childed nodes, turn it into a compressed node. */
<span class="lineNum">     852 </span><span class="lineCov">      10048 :         if (h-&gt;size == 0 &amp;&amp; len-i &gt; 1) {</span>
<span class="lineNum">     853 </span><span class="lineCov">       3804 :             debugf(&quot;Inserting compressed node\n&quot;);</span>
<span class="lineNum">     854 </span><span class="lineCov">       3804 :             size_t comprsize = len-i;</span>
<span class="lineNum">     855 </span><span class="lineCov">       3804 :             if (comprsize &gt; RAX_NODE_MAX_SIZE)</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                 comprsize = RAX_NODE_MAX_SIZE;</span>
<span class="lineNum">     857 </span><span class="lineCov">       3804 :             raxNode *newh = raxCompressNode(h,s+i,comprsize,&amp;child);</span>
<span class="lineNum">     858 </span><span class="lineCov">       3804 :             if (newh == NULL) goto oom;</span>
<span class="lineNum">     859 </span><span class="lineCov">       3804 :             h = newh;</span>
<span class="lineNum">     860 </span><span class="lineCov">       3804 :             memcpy(parentlink,&amp;h,sizeof(h));</span>
<span class="lineNum">     861 </span><span class="lineCov">       3804 :             parentlink = raxNodeLastChildPtr(h);</span>
<span class="lineNum">     862 </span><span class="lineCov">       3804 :             i += comprsize;</span>
<span class="lineNum">     863 </span>            :         } else {
<span class="lineNum">     864 </span><span class="lineCov">       6244 :             debugf(&quot;Inserting normal node\n&quot;);</span>
<span class="lineNum">     865 </span><span class="lineCov">       6244 :             raxNode **new_parentlink;</span>
<span class="lineNum">     866 </span><span class="lineCov">       6244 :             raxNode *newh = raxAddChild(h,s[i],&amp;child,&amp;new_parentlink);</span>
<span class="lineNum">     867 </span><span class="lineCov">       6244 :             if (newh == NULL) goto oom;</span>
<span class="lineNum">     868 </span><span class="lineCov">       6244 :             h = newh;</span>
<span class="lineNum">     869 </span><span class="lineCov">       6244 :             memcpy(parentlink,&amp;h,sizeof(h));</span>
<span class="lineNum">     870 </span><span class="lineCov">       6244 :             parentlink = new_parentlink;</span>
<span class="lineNum">     871 </span><span class="lineCov">       6244 :             i++;</span>
<span class="lineNum">     872 </span>            :         }
<span class="lineNum">     873 </span><span class="lineCov">      10048 :         rax-&gt;numnodes++;</span>
<span class="lineNum">     874 </span><span class="lineCov">      10048 :         h = child;</span>
<span class="lineNum">     875 </span>            :     }
<span class="lineNum">     876 </span><span class="lineCov">       7977 :     raxNode *newh = raxReallocForData(h,data);</span>
<span class="lineNum">     877 </span><span class="lineCov">       7977 :     if (newh == NULL) goto oom;</span>
<span class="lineNum">     878 </span><span class="lineCov">       7977 :     h = newh;</span>
<span class="lineNum">     879 </span><span class="lineCov">       7977 :     if (!h-&gt;iskey) rax-&gt;numele++;</span>
<span class="lineNum">     880 </span><span class="lineCov">       7977 :     raxSetData(h,data);</span>
<span class="lineNum">     881 </span><span class="lineCov">       7977 :     memcpy(parentlink,&amp;h,sizeof(h));</span>
<span class="lineNum">     882 </span><span class="lineCov">       7977 :     return 1; /* Element inserted. */</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 : oom:</span>
<span class="lineNum">     885 </span>            :     /* This code path handles out of memory after part of the sub-tree was
<span class="lineNum">     886 </span>            :      * already modified. Set the node as a key, and then remove it. However we
<span class="lineNum">     887 </span>            :      * do that only if the node is a terminal node, otherwise if the OOM
<span class="lineNum">     888 </span>            :      * happened reallocating a node in the middle, we don't need to free
<span class="lineNum">     889 </span>            :      * anything. */
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     if (h-&gt;size == 0) {</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         h-&gt;isnull = 1;</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         h-&gt;iskey = 1;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         rax-&gt;numele++; /* Compensate the next remove. */</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         assert(raxRemove(rax,s,i,NULL) != 0);</span>
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     errno = ENOMEM;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">     898 </span>            : }
<span class="lineNum">     899 </span>            : 
<a name="900"><span class="lineNum">     900 </span>            : /* Overwriting insert. Just a wrapper for raxGenericInsert() that will</a>
<span class="lineNum">     901 </span>            :  * update the element if there is already one for the same key. */
<span class="lineNum">     902 </span><span class="lineCov">      36696 : int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {</span>
<span class="lineNum">     903 </span><span class="lineCov">      36696 :     return raxGenericInsert(rax,s,len,data,old,1);</span>
<span class="lineNum">     904 </span>            : }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : /* Non overwriting insert function: this if an element with the same key
<a name="907"><span class="lineNum">     907 </span>            :  * exists, the value is not updated and the function returns 0.</a>
<span class="lineNum">     908 </span>            :  * This is a just a wrapper for raxGenericInsert(). */
<span class="lineNum">     909 </span><span class="lineCov">        370 : int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {</span>
<span class="lineNum">     910 </span><span class="lineCov">        370 :     return raxGenericInsert(rax,s,len,data,old,0);</span>
<span class="lineNum">     911 </span>            : }
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : /* Find a key in the rax, returns raxNotFound special void pointer value
<a name="914"><span class="lineNum">     914 </span>            :  * if the item was not found, otherwise the value associated with the</a>
<span class="lineNum">     915 </span>            :  * item is returned. */
<span class="lineNum">     916 </span><span class="lineCov">        786 : void *raxFind(rax *rax, unsigned char *s, size_t len) {</span>
<span class="lineNum">     917 </span><span class="lineCov">        786 :     raxNode *h;</span>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineCov">        786 :     debugf(&quot;### Lookup: %.*s\n&quot;, (int)len, s);</span>
<span class="lineNum">     920 </span><span class="lineCov">        786 :     int splitpos = 0;</span>
<span class="lineNum">     921 </span><span class="lineCov">        786 :     size_t i = raxLowWalk(rax,s,len,&amp;h,NULL,&amp;splitpos,NULL);</span>
<span class="lineNum">     922 </span><span class="lineCov">        786 :     if (i != len || (h-&gt;iscompr &amp;&amp; splitpos != 0) || !h-&gt;iskey)</span>
<span class="lineNum">     923 </span><span class="lineCov">        232 :         return raxNotFound;</span>
<span class="lineNum">     924 </span><span class="lineCov">        554 :     return raxGetData(h);</span>
<span class="lineNum">     925 </span>            : }
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : /* Return the memory address where the 'parent' node stores the specified
<span class="lineNum">     928 </span>            :  * 'child' pointer, so that the caller can update the pointer with another
<span class="lineNum">     929 </span>            :  * one if needed. The function assumes it will find a match, otherwise the
<a name="930"><span class="lineNum">     930 </span>            :  * operation is an undefined behavior (it will continue scanning the</a>
<span class="lineNum">     931 </span>            :  * memory without any bound checking). */
<span class="lineNum">     932 </span><span class="lineNoCov">          0 : raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :     raxNode **cp = raxNodeFirstChildPtr(parent);</span>
<span class="lineNum">     934 </span><span class="lineCov">        968 :     raxNode *c;</span>
<span class="lineNum">     935 </span><span class="lineCov">        968 :     while(1) {</span>
<span class="lineNum">     936 </span><span class="lineCov">        968 :         memcpy(&amp;c,cp,sizeof(c));</span>
<span class="lineNum">     937 </span><span class="lineCov">        968 :         if (c == child) break;</span>
<span class="lineNum">     938 </span><span class="lineCov">         20 :         cp++;</span>
<span class="lineNum">     939 </span>            :     }
<span class="lineNum">     940 </span><span class="lineCov">         13 :     return cp;</span>
<span class="lineNum">     941 </span>            : }
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            : /* Low level child removal from node. The new node pointer (after the child
<span class="lineNum">     944 </span>            :  * removal) is returned. Note that this function does not fix the pointer
<a name="945"><span class="lineNum">     945 </span>            :  * of the parent node in its parent, so this task is up to the caller.</a>
<span class="lineNum">     946 </span>            :  * The function never fails for out of memory. */
<span class="lineNum">     947 </span><span class="lineCov">       1786 : raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {</span>
<span class="lineNum">     948 </span><span class="lineCov">       1786 :     debugnode(&quot;raxRemoveChild before&quot;, parent);</span>
<span class="lineNum">     949 </span>            :     /* If parent is a compressed node (having a single child, as for definition
<span class="lineNum">     950 </span>            :      * of the data structure), the removal of the child consists into turning
<span class="lineNum">     951 </span>            :      * it into a normal node without children. */
<span class="lineNum">     952 </span><span class="lineCov">       1786 :     if (parent-&gt;iscompr) {</span>
<span class="lineNum">     953 </span><span class="lineCov">        714 :         void *data = NULL;</span>
<span class="lineNum">     954 </span><span class="lineCov">        714 :         if (parent-&gt;iskey) data = raxGetData(parent);</span>
<span class="lineNum">     955 </span><span class="lineCov">        714 :         parent-&gt;isnull = 0;</span>
<span class="lineNum">     956 </span><span class="lineCov">        714 :         parent-&gt;iscompr = 0;</span>
<span class="lineNum">     957 </span><span class="lineCov">        714 :         parent-&gt;size = 0;</span>
<span class="lineNum">     958 </span><span class="lineCov">        714 :         if (parent-&gt;iskey) raxSetData(parent,data);</span>
<span class="lineNum">     959 </span><span class="lineCov">        714 :         debugnode(&quot;raxRemoveChild after&quot;, parent);</span>
<span class="lineNum">     960 </span><span class="lineCov">        714 :         return parent;</span>
<span class="lineNum">     961 </span>            :     }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :     /* Otherwise we need to scan for the child pointer and memmove()
<span class="lineNum">     964 </span>            :      * accordingly.
<span class="lineNum">     965 </span>            :      *
<span class="lineNum">     966 </span>            :      * 1. To start we seek the first element in both the children
<span class="lineNum">     967 </span>            :      *    pointers and edge bytes in the node. */
<span class="lineNum">     968 </span><span class="lineCov">       1072 :     raxNode **cp = raxNodeFirstChildPtr(parent);</span>
<span class="lineNum">     969 </span><span class="lineCov">       1072 :     raxNode **c = cp;</span>
<span class="lineNum">     970 </span><span class="lineCov">       1072 :     unsigned char *e = parent-&gt;data;</span>
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :     /* 2. Search the child pointer to remove inside the array of children
<span class="lineNum">     973 </span>            :      *    pointers. */
<span class="lineNum">     974 </span><span class="lineCov">      13194 :     while(1) {</span>
<span class="lineNum">     975 </span><span class="lineCov">       7133 :         raxNode *aux;</span>
<span class="lineNum">     976 </span><span class="lineCov">       7133 :         memcpy(&amp;aux,c,sizeof(aux));</span>
<span class="lineNum">     977 </span><span class="lineCov">       7133 :         if (aux == child) break;</span>
<span class="lineNum">     978 </span><span class="lineCov">       6061 :         c++;</span>
<span class="lineNum">     979 </span><span class="lineCov">       6061 :         e++;</span>
<span class="lineNum">     980 </span>            :     }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :     /* 3. Remove the edge and the pointer by memmoving the remaining children
<span class="lineNum">     983 </span>            :      *    pointer and edge bytes one position before. */
<span class="lineNum">     984 </span><span class="lineCov">       1072 :     int taillen = parent-&gt;size - (e - parent-&gt;data) - 1;</span>
<span class="lineNum">     985 </span><span class="lineCov">       1072 :     debugf(&quot;raxRemoveChild tail len: %d\n&quot;, taillen);</span>
<span class="lineNum">     986 </span><span class="lineCov">       1072 :     memmove(e,e+1,taillen);</span>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            :     /* Compute the shift, that is the amount of bytes we should move our
<span class="lineNum">     989 </span>            :      * child pointers to the left, since the removal of one edge character
<span class="lineNum">     990 </span>            :      * and the corresponding padding change, may change the layout.
<span class="lineNum">     991 </span>            :      * We just check if in the old version of the node there was at the
<span class="lineNum">     992 </span>            :      * end just a single byte and all padding: in that case removing one char
<span class="lineNum">     993 </span>            :      * will remove a whole sizeof(void*) word. */
<span class="lineNum">     994 </span><span class="lineCov">       1072 :     size_t shift = ((parent-&gt;size+4) % sizeof(void*)) == 1 ? sizeof(void*) : 0;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :     /* Move the children pointers before the deletion point. */
<span class="lineNum">     997 </span><span class="lineCov">        221 :     if (shift)</span>
<span class="lineNum">     998 </span><span class="lineCov">        221 :         memmove(((char*)cp)-shift,cp,(parent-&gt;size-taillen-1)*sizeof(raxNode**));</span>
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :     /* Move the remaining &quot;tail&quot; pointers at the right position as well. */
<span class="lineNum">    1001 </span><span class="lineCov">       1072 :     size_t valuelen = (parent-&gt;iskey &amp;&amp; !parent-&gt;isnull) ? sizeof(void*) : 0;</span>
<span class="lineNum">    1002 </span><span class="lineCov">       1072 :     memmove(((char*)c)-shift,c+1,taillen*sizeof(raxNode**)+valuelen);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span>            :     /* 4. Update size. */
<span class="lineNum">    1005 </span><span class="lineCov">       1072 :     parent-&gt;size--;</span>
<span class="lineNum">    1006 </span>            : 
<span class="lineNum">    1007 </span>            :     /* realloc the node according to the theoretical memory usage, to free
<span class="lineNum">    1008 </span>            :      * data if we are over-allocating right now. */
<span class="lineNum">    1009 </span><span class="lineCov">       1072 :     raxNode *newnode = rax_realloc(parent,raxNodeCurrentLength(parent));</span>
<span class="lineNum">    1010 </span><span class="lineCov">       1072 :     if (newnode) {</span>
<span class="lineNum">    1011 </span><span class="lineCov">       1072 :         debugnode(&quot;raxRemoveChild after&quot;, newnode);</span>
<span class="lineNum">    1012 </span>            :     }
<span class="lineNum">    1013 </span>            :     /* Note: if rax_realloc() fails we just return the old address, which
<span class="lineNum">    1014 </span>            :      * is valid. */
<span class="lineNum">    1015 </span><span class="lineCov">       1072 :     return newnode ? newnode : parent;</span>
<span class="lineNum">    1016 </span>            : }
<span class="lineNum">    1017 </span>            : 
<a name="1018"><span class="lineNum">    1018 </span>            : /* Remove the specified item. Returns 1 if the item was found and</a>
<span class="lineNum">    1019 </span>            :  * deleted, 0 otherwise. */
<span class="lineNum">    1020 </span><span class="lineCov">       1786 : int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {</span>
<span class="lineNum">    1021 </span><span class="lineCov">       1786 :     raxNode *h;</span>
<span class="lineNum">    1022 </span><span class="lineCov">       1786 :     raxStack ts;</span>
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span><span class="lineCov">       1786 :     debugf(&quot;### Delete: %.*s\n&quot;, (int)len, s);</span>
<span class="lineNum">    1025 </span><span class="lineCov">       3572 :     raxStackInit(&amp;ts);</span>
<span class="lineNum">    1026 </span><span class="lineCov">       1786 :     int splitpos = 0;</span>
<span class="lineNum">    1027 </span><span class="lineCov">       1786 :     size_t i = raxLowWalk(rax,s,len,&amp;h,NULL,&amp;splitpos,&amp;ts);</span>
<span class="lineNum">    1028 </span><span class="lineCov">       1786 :     if (i != len || (h-&gt;iscompr &amp;&amp; splitpos != 0) || !h-&gt;iskey) {</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         raxStackFree(&amp;ts);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1031 </span>            :     }
<span class="lineNum">    1032 </span><span class="lineCov">       1786 :     if (old) *old = raxGetData(h);</span>
<span class="lineNum">    1033 </span><span class="lineCov">       1786 :     h-&gt;iskey = 0;</span>
<span class="lineNum">    1034 </span><span class="lineCov">       1786 :     rax-&gt;numele--;</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :     /* If this node has no children, the deletion needs to reclaim the
<span class="lineNum">    1037 </span>            :      * no longer used nodes. This is an iterative process that needs to
<span class="lineNum">    1038 </span>            :      * walk the three upward, deleting all the nodes with just one child
<span class="lineNum">    1039 </span>            :      * that are not keys, until the head of the rax is reached or the first
<span class="lineNum">    1040 </span>            :      * node with more than one child is found. */
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineCov">       1786 :     int trycompress = 0; /* Will be set to 1 if we should try to optimize the</span>
<span class="lineNum">    1043 </span>            :                             tree resulting from the deletion. */
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span><span class="lineCov">       1786 :     if (h-&gt;size == 0) {</span>
<span class="lineNum">    1046 </span>            :         debugf(&quot;Key deleted in node without children. Cleanup needed.\n&quot;);
<span class="lineNum">    1047 </span>            :         raxNode *child = NULL;
<span class="lineNum">    1048 </span><span class="lineCov">       2574 :         while(h != rax-&gt;head) {</span>
<span class="lineNum">    1049 </span><span class="lineCov">       1860 :             child = h;</span>
<span class="lineNum">    1050 </span>            :             debugf(&quot;Freeing child %p [%.*s] key:%d\n&quot;, (void*)child,
<span class="lineNum">    1051 </span><span class="lineCov">       1860 :                 (int)child-&gt;size, (char*)child-&gt;data, child-&gt;iskey);</span>
<span class="lineNum">    1052 </span><span class="lineCov">       1860 :             rax_free(child);</span>
<span class="lineNum">    1053 </span><span class="lineCov">       1860 :             rax-&gt;numnodes--;</span>
<span class="lineNum">    1054 </span><span class="lineCov">       1860 :             h = raxStackPop(&amp;ts);</span>
<span class="lineNum">    1055 </span>            :              /* If this node has more then one child, or actually holds
<span class="lineNum">    1056 </span>            :               * a key, stop here. */
<span class="lineNum">    1057 </span><span class="lineCov">       1860 :             if (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != 1)) break;</span>
<span class="lineNum">    1058 </span>            :         }
<span class="lineNum">    1059 </span><span class="lineCov">       1786 :         if (child) {</span>
<span class="lineNum">    1060 </span>            :             debugf(&quot;Unlinking child %p from parent %p\n&quot;,
<span class="lineNum">    1061 </span><span class="lineCov">       1786 :                 (void*)child, (void*)h);</span>
<span class="lineNum">    1062 </span><span class="lineCov">       1786 :             raxNode *new = raxRemoveChild(h,child);</span>
<span class="lineNum">    1063 </span><span class="lineCov">       1786 :             if (new != h) {</span>
<span class="lineNum">    1064 </span><span class="lineCov">        935 :                 raxNode *parent = raxStackPeek(&amp;ts);</span>
<span class="lineNum">    1065 </span><span class="lineCov">        935 :                 raxNode **parentlink;</span>
<span class="lineNum">    1066 </span><span class="lineCov">        935 :                 if (parent == NULL) {</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                     parentlink = &amp;rax-&gt;head;</span>
<span class="lineNum">    1068 </span>            :                 } else {
<span class="lineNum">    1069 </span><span class="lineCov">        935 :                     parentlink = raxFindParentLink(parent,h);</span>
<span class="lineNum">    1070 </span>            :                 }
<span class="lineNum">    1071 </span><span class="lineCov">        935 :                 memcpy(parentlink,&amp;new,sizeof(new));</span>
<span class="lineNum">    1072 </span>            :             }
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span>            :             /* If after the removal the node has just a single child
<span class="lineNum">    1075 </span>            :              * and is not a key, we need to try to compress it. */
<span class="lineNum">    1076 </span><span class="lineCov">       1786 :             if (new-&gt;size == 1 &amp;&amp; new-&gt;iskey == 0) {</span>
<span class="lineNum">    1077 </span><span class="lineCov">        439 :                 trycompress = 1;</span>
<span class="lineNum">    1078 </span><span class="lineCov">        439 :                 h = new;</span>
<span class="lineNum">    1079 </span>            :             }
<span class="lineNum">    1080 </span>            :         }
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :     } else if (h-&gt;size == 1) {</span>
<span class="lineNum">    1082 </span>            :         /* If the node had just one child, after the removal of the key
<span class="lineNum">    1083 </span>            :          * further compression with adjacent nodes is pontentially possible. */
<span class="lineNum">    1084 </span>            :         trycompress = 1;
<span class="lineNum">    1085 </span>            :     }
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :     /* Don't try node compression if our nodes pointers stack is not
<span class="lineNum">    1088 </span>            :      * complete because of OOM while executing raxLowWalk() */
<span class="lineNum">    1089 </span><span class="lineCov">       1786 :     if (trycompress &amp;&amp; ts.oom) trycompress = 0;</span>
<span class="lineNum">    1090 </span>            : 
<span class="lineNum">    1091 </span>            :     /* Recompression: if trycompress is true, 'h' points to a radix tree node
<span class="lineNum">    1092 </span>            :      * that changed in a way that could allow to compress nodes in this
<span class="lineNum">    1093 </span>            :      * sub-branch. Compressed nodes represent chains of nodes that are not
<span class="lineNum">    1094 </span>            :      * keys and have a single child, so there are two deletion events that
<span class="lineNum">    1095 </span>            :      * may alter the tree so that further compression is needed:
<span class="lineNum">    1096 </span>            :      *
<span class="lineNum">    1097 </span>            :      * 1) A node with a single child was a key and now no longer is a key.
<span class="lineNum">    1098 </span>            :      * 2) A node with two children now has just one child.
<span class="lineNum">    1099 </span>            :      *
<span class="lineNum">    1100 </span>            :      * We try to navigate upward till there are other nodes that can be
<span class="lineNum">    1101 </span>            :      * compressed, when we reach the upper node which is not a key and has
<span class="lineNum">    1102 </span>            :      * a single child, we scan the chain of children to collect the
<span class="lineNum">    1103 </span>            :      * compressable part of the tree, and replace the current node with the
<span class="lineNum">    1104 </span>            :      * new one, fixing the child pointer to reference the first non
<span class="lineNum">    1105 </span>            :      * compressable node.
<span class="lineNum">    1106 </span>            :      *
<span class="lineNum">    1107 </span>            :      * Example of case &quot;1&quot;. A tree stores the keys &quot;FOO&quot; = 1 and
<span class="lineNum">    1108 </span>            :      * &quot;FOOBAR&quot; = 2:
<span class="lineNum">    1109 </span>            :      *
<span class="lineNum">    1110 </span>            :      *
<span class="lineNum">    1111 </span>            :      * &quot;FOO&quot; -&gt; &quot;BAR&quot; -&gt; [] (2)
<span class="lineNum">    1112 </span>            :      *           (1)
<span class="lineNum">    1113 </span>            :      *
<span class="lineNum">    1114 </span>            :      * After the removal of &quot;FOO&quot; the tree can be compressed as:
<span class="lineNum">    1115 </span>            :      *
<span class="lineNum">    1116 </span>            :      * &quot;FOOBAR&quot; -&gt; [] (2)
<span class="lineNum">    1117 </span>            :      *
<span class="lineNum">    1118 </span>            :      *
<span class="lineNum">    1119 </span>            :      * Example of case &quot;2&quot;. A tree stores the keys &quot;FOOBAR&quot; = 1 and
<span class="lineNum">    1120 </span>            :      * &quot;FOOTER&quot; = 2:
<span class="lineNum">    1121 </span>            :      *
<span class="lineNum">    1122 </span>            :      *          |B| -&gt; &quot;AR&quot; -&gt; [] (1)
<span class="lineNum">    1123 </span>            :      * &quot;FOO&quot; -&gt; |-|
<span class="lineNum">    1124 </span>            :      *          |T| -&gt; &quot;ER&quot; -&gt; [] (2)
<span class="lineNum">    1125 </span>            :      *
<span class="lineNum">    1126 </span>            :      * After the removal of &quot;FOOTER&quot; the resulting tree is:
<span class="lineNum">    1127 </span>            :      *
<span class="lineNum">    1128 </span>            :      * &quot;FOO&quot; -&gt; |B| -&gt; &quot;AR&quot; -&gt; [] (1)
<span class="lineNum">    1129 </span>            :      *
<span class="lineNum">    1130 </span>            :      * That can be compressed into:
<span class="lineNum">    1131 </span>            :      *
<span class="lineNum">    1132 </span>            :      * &quot;FOOBAR&quot; -&gt; [] (1)
<span class="lineNum">    1133 </span>            :      */
<span class="lineNum">    1134 </span><span class="lineCov">       1786 :     if (trycompress) {</span>
<span class="lineNum">    1135 </span><span class="lineCov">        874 :         debugf(&quot;After removing %.*s:\n&quot;, (int)len, s);</span>
<span class="lineNum">    1136 </span><span class="lineCov">        874 :         debugnode(&quot;Compression may be needed&quot;,h);</span>
<span class="lineNum">    1137 </span><span class="lineCov">        874 :         debugf(&quot;Seek start node\n&quot;);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :         /* Try to reach the upper node that is compressible.
<span class="lineNum">    1140 </span>            :          * At the end of the loop 'h' will point to the first node we
<span class="lineNum">    1141 </span>            :          * can try to compress and 'parent' to its parent. */
<span class="lineNum">    1142 </span><span class="lineCov">        874 :         raxNode *parent;</span>
<span class="lineNum">    1143 </span><span class="lineCov">        874 :         while(1) {</span>
<span class="lineNum">    1144 </span><span class="lineCov">        874 :             parent = raxStackPop(&amp;ts);</span>
<span class="lineNum">    1145 </span><span class="lineCov">        448 :             if (!parent || parent-&gt;iskey ||</span>
<span class="lineNum">    1146 </span><span class="lineCov">        448 :                 (!parent-&gt;iscompr &amp;&amp; parent-&gt;size != 1)) break;</span>
<span class="lineNum">    1147 </span><span class="lineCov">        435 :             h = parent;</span>
<span class="lineNum">    1148 </span><span class="lineCov">        435 :             debugnode(&quot;Going up to&quot;,h);</span>
<span class="lineNum">    1149 </span>            :         }
<span class="lineNum">    1150 </span><span class="lineCov">        439 :         raxNode *start = h; /* Compression starting node. */</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :         /* Scan chain of nodes we can compress. */
<span class="lineNum">    1153 </span><span class="lineCov">        439 :         size_t comprsize = h-&gt;size;</span>
<span class="lineNum">    1154 </span><span class="lineCov">        439 :         int nodes = 1;</span>
<span class="lineNum">    1155 </span><span class="lineCov">        893 :         while(h-&gt;size != 0) {</span>
<span class="lineNum">    1156 </span><span class="lineCov">        893 :             raxNode **cp = raxNodeLastChildPtr(h);</span>
<span class="lineNum">    1157 </span><span class="lineCov">        893 :             memcpy(&amp;h,cp,sizeof(h));</span>
<span class="lineNum">    1158 </span><span class="lineCov">        893 :             if (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != 1)) break;</span>
<span class="lineNum">    1159 </span>            :             /* Stop here if going to the next node would result into
<span class="lineNum">    1160 </span>            :              * a compressed node larger than h-&gt;size can hold. */
<span class="lineNum">    1161 </span><span class="lineCov">        454 :             if (comprsize + h-&gt;size &gt; RAX_NODE_MAX_SIZE) break;</span>
<span class="lineNum">    1162 </span><span class="lineCov">        454 :             nodes++;</span>
<span class="lineNum">    1163 </span><span class="lineCov">        454 :             comprsize += h-&gt;size;</span>
<span class="lineNum">    1164 </span>            :         }
<span class="lineNum">    1165 </span><span class="lineCov">        439 :         if (nodes &gt; 1) {</span>
<span class="lineNum">    1166 </span>            :             /* If we can compress, create the new node and populate it. */
<span class="lineNum">    1167 </span><span class="lineCov">        878 :             size_t nodesize =</span>
<span class="lineNum">    1168 </span><span class="lineCov">        439 :                 sizeof(raxNode)+comprsize+raxPadding(comprsize)+sizeof(raxNode*);</span>
<span class="lineNum">    1169 </span><span class="lineCov">        439 :             raxNode *new = rax_malloc(nodesize);</span>
<span class="lineNum">    1170 </span>            :             /* An out of memory here just means we cannot optimize this
<span class="lineNum">    1171 </span>            :              * node, but the tree is left in a consistent state. */
<span class="lineNum">    1172 </span><span class="lineCov">        439 :             if (new == NULL) {</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :                 raxStackFree(&amp;ts);</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    1175 </span>            :             }
<span class="lineNum">    1176 </span><span class="lineCov">        439 :             new-&gt;iskey = 0;</span>
<span class="lineNum">    1177 </span><span class="lineCov">        439 :             new-&gt;isnull = 0;</span>
<span class="lineNum">    1178 </span><span class="lineCov">        439 :             new-&gt;iscompr = 1;</span>
<span class="lineNum">    1179 </span><span class="lineCov">        439 :             new-&gt;size = comprsize;</span>
<span class="lineNum">    1180 </span><span class="lineCov">        439 :             rax-&gt;numnodes++;</span>
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span>            :             /* Scan again, this time to populate the new node content and
<span class="lineNum">    1183 </span>            :              * to fix the new node child pointer. At the same time we free
<span class="lineNum">    1184 </span>            :              * all the nodes that we'll no longer use. */
<span class="lineNum">    1185 </span><span class="lineCov">        439 :             comprsize = 0;</span>
<span class="lineNum">    1186 </span><span class="lineCov">        439 :             h = start;</span>
<span class="lineNum">    1187 </span><span class="lineCov">        893 :             while(h-&gt;size != 0) {</span>
<span class="lineNum">    1188 </span><span class="lineCov">        893 :                 memcpy(new-&gt;data+comprsize,h-&gt;data,h-&gt;size);</span>
<span class="lineNum">    1189 </span><span class="lineCov">        893 :                 comprsize += h-&gt;size;</span>
<span class="lineNum">    1190 </span><span class="lineCov">        893 :                 raxNode **cp = raxNodeLastChildPtr(h);</span>
<span class="lineNum">    1191 </span><span class="lineCov">        893 :                 raxNode *tofree = h;</span>
<span class="lineNum">    1192 </span><span class="lineCov">        893 :                 memcpy(&amp;h,cp,sizeof(h));</span>
<span class="lineNum">    1193 </span><span class="lineCov">        893 :                 rax_free(tofree); rax-&gt;numnodes--;</span>
<span class="lineNum">    1194 </span><span class="lineCov">        893 :                 if (h-&gt;iskey || (!h-&gt;iscompr &amp;&amp; h-&gt;size != 1)) break;</span>
<span class="lineNum">    1195 </span>            :             }
<span class="lineNum">    1196 </span><span class="lineCov">        439 :             debugnode(&quot;New node&quot;,new);</span>
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :             /* Now 'h' points to the first node that we still need to use,
<span class="lineNum">    1199 </span>            :              * so our new node child pointer will point to it. */
<span class="lineNum">    1200 </span><span class="lineCov">        439 :             raxNode **cp = raxNodeLastChildPtr(new);</span>
<span class="lineNum">    1201 </span><span class="lineCov">        439 :             memcpy(cp,&amp;h,sizeof(h));</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :             /* Fix parent link. */
<span class="lineNum">    1204 </span><span class="lineCov">        439 :             if (parent) {</span>
<span class="lineNum">    1205 </span><span class="lineCov">         13 :                 raxNode **parentlink = raxFindParentLink(parent,start);</span>
<span class="lineNum">    1206 </span><span class="lineCov">         13 :                 memcpy(parentlink,&amp;new,sizeof(new));</span>
<span class="lineNum">    1207 </span>            :             } else {
<span class="lineNum">    1208 </span><span class="lineCov">        426 :                 rax-&gt;head = new;</span>
<span class="lineNum">    1209 </span>            :             }
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :             debugf(&quot;Compressed %d nodes, %d total bytes\n&quot;,
<span class="lineNum">    1212 </span><span class="lineCov">        439 :                 nodes, (int)comprsize);</span>
<span class="lineNum">    1213 </span>            :         }
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span><span class="lineCov">       1786 :     raxStackFree(&amp;ts);</span>
<span class="lineNum">    1216 </span>            :     return 1;
<span class="lineNum">    1217 </span>            : }
<span class="lineNum">    1218 </span>            : 
<a name="1219"><span class="lineNum">    1219 </span>            : /* This is the core of raxFree(): performs a depth-first scan of the</a>
<span class="lineNum">    1220 </span>            :  * tree and releases all the nodes found. */
<span class="lineNum">    1221 </span><span class="lineCov">       1056 : void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {</span>
<span class="lineNum">    1222 </span><span class="lineCov">       1056 :     debugnode(&quot;free traversing&quot;,n);</span>
<span class="lineNum">    1223 </span><span class="lineCov">       1056 :     int numchildren = n-&gt;iscompr ? 1 : n-&gt;size;</span>
<span class="lineNum">    1224 </span><span class="lineCov">       1056 :     raxNode **cp = raxNodeLastChildPtr(n);</span>
<span class="lineNum">    1225 </span><span class="lineCov">       1779 :     while(numchildren--) {</span>
<span class="lineNum">    1226 </span><span class="lineCov">        723 :         raxNode *child;</span>
<span class="lineNum">    1227 </span><span class="lineCov">        723 :         memcpy(&amp;child,cp,sizeof(child));</span>
<span class="lineNum">    1228 </span><span class="lineCov">        723 :         raxRecursiveFree(rax,child,free_callback);</span>
<span class="lineNum">    1229 </span><span class="lineCov">        723 :         cp--;</span>
<span class="lineNum">    1230 </span>            :     }
<span class="lineNum">    1231 </span><span class="lineCov">       1056 :     debugnode(&quot;free depth-first&quot;,n);</span>
<span class="lineNum">    1232 </span><span class="lineCov">       1056 :     if (free_callback &amp;&amp; n-&gt;iskey &amp;&amp; !n-&gt;isnull)</span>
<span class="lineNum">    1233 </span><span class="lineCov">        399 :         free_callback(raxGetData(n));</span>
<span class="lineNum">    1234 </span><span class="lineCov">       1056 :     rax_free(n);</span>
<span class="lineNum">    1235 </span><span class="lineCov">       1056 :     rax-&gt;numnodes--;</span>
<span class="lineNum">    1236 </span><span class="lineCov">       1056 : }</span>
<span class="lineNum">    1237 </span>            : 
<a name="1238"><span class="lineNum">    1238 </span>            : /* Free a whole radix tree, calling the specified callback in order to</a>
<span class="lineNum">    1239 </span>            :  * free the auxiliary data. */
<span class="lineNum">    1240 </span><span class="lineCov">        333 : void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {</span>
<span class="lineNum">    1241 </span><span class="lineCov">        333 :     raxRecursiveFree(rax,rax-&gt;head,free_callback);</span>
<span class="lineNum">    1242 </span><span class="lineCov">        333 :     assert(rax-&gt;numnodes == 0);</span>
<span class="lineNum">    1243 </span><span class="lineCov">        333 :     rax_free(rax);</span>
<span class="lineNum">    1244 </span><span class="lineCov">        333 : }</span>
<a name="1245"><span class="lineNum">    1245 </span>            : </a>
<span class="lineNum">    1246 </span>            : /* Free a whole radix tree. */
<span class="lineNum">    1247 </span><span class="lineCov">         69 : void raxFree(rax *rax) {</span>
<span class="lineNum">    1248 </span><span class="lineCov">         69 :     raxFreeWithCallback(rax,NULL);</span>
<span class="lineNum">    1249 </span><span class="lineCov">         69 : }</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            : /* ------------------------------- Iterator --------------------------------- */
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span>            : /* Initialize a Rax iterator. This call should be performed a single time
<a name="1254"><span class="lineNum">    1254 </span>            :  * to initialize the iterator, and must be followed by a raxSeek() call,</a>
<span class="lineNum">    1255 </span>            :  * otherwise the raxPrev()/raxNext() functions will just return EOF. */
<span class="lineNum">    1256 </span><span class="lineCov">      92950 : void raxStart(raxIterator *it, rax *rt) {</span>
<span class="lineNum">    1257 </span><span class="lineCov">      92950 :     it-&gt;flags = RAX_ITER_EOF; /* No crash if the iterator is not seeked. */</span>
<span class="lineNum">    1258 </span><span class="lineCov">      92950 :     it-&gt;rt = rt;</span>
<span class="lineNum">    1259 </span><span class="lineCov">      92950 :     it-&gt;key_len = 0;</span>
<span class="lineNum">    1260 </span><span class="lineCov">      92950 :     it-&gt;key = it-&gt;key_static_string;</span>
<span class="lineNum">    1261 </span><span class="lineCov">      92950 :     it-&gt;key_max = RAX_ITER_STATIC_LEN;</span>
<span class="lineNum">    1262 </span><span class="lineCov">      92950 :     it-&gt;data = NULL;</span>
<span class="lineNum">    1263 </span><span class="lineCov">      92950 :     it-&gt;node_cb = NULL;</span>
<span class="lineNum">    1264 </span><span class="lineCov">     185900 :     raxStackInit(&amp;it-&gt;stack);</span>
<span class="lineNum">    1265 </span><span class="lineCov">      92950 : }</span>
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            : /* Append characters at the current key string of the iterator 'it'. This
<a name="1268"><span class="lineNum">    1268 </span>            :  * is a low level function used to implement the iterator, not callable by</a>
<span class="lineNum">    1269 </span>            :  * the user. Returns 0 on out of memory, otherwise 1 is returned. */
<span class="lineNum">    1270 </span><span class="lineCov">     407092 : int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {</span>
<span class="lineNum">    1271 </span><span class="lineCov">     407092 :     if (it-&gt;key_max &lt; it-&gt;key_len+len) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         unsigned char *old = (it-&gt;key == it-&gt;key_static_string) ? NULL :</span>
<span class="lineNum">    1273 </span>            :                                                                   it-&gt;key;
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :         size_t new_max = (it-&gt;key_len+len)*2;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         it-&gt;key = rax_realloc(old,new_max);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         if (it-&gt;key == NULL) {</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :             it-&gt;key = (!old) ? it-&gt;key_static_string : old;</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :             errno = ENOMEM;</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">    1280 </span>            :         }
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :         if (old == NULL) memcpy(it-&gt;key,it-&gt;key_static_string,it-&gt;key_len);</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :         it-&gt;key_max = new_max;</span>
<span class="lineNum">    1283 </span>            :     }
<span class="lineNum">    1284 </span>            :     /* Use memmove since there could be an overlap between 's' and
<span class="lineNum">    1285 </span>            :      * it-&gt;key when we use the current key in order to re-seek. */
<span class="lineNum">    1286 </span><span class="lineCov">     407092 :     memmove(it-&gt;key+it-&gt;key_len,s,len);</span>
<span class="lineNum">    1287 </span><span class="lineCov">     407092 :     it-&gt;key_len += len;</span>
<span class="lineNum">    1288 </span><span class="lineCov">     407092 :     return 1;</span>
<span class="lineNum">    1289 </span>            : }
<span class="lineNum">    1290 </span>            : 
<a name="1291"><span class="lineNum">    1291 </span>            : /* Remove the specified number of chars from the right of the current</a>
<span class="lineNum">    1292 </span>            :  * iterator key. */
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 : void raxIteratorDelChars(raxIterator *it, size_t count) {</span>
<span class="lineNum">    1294 </span><span class="lineCov">      61270 :     it-&gt;key_len -= count;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : /* Do an iteration step towards the next element. At the end of the step the
<span class="lineNum">    1298 </span>            :  * iterator key will represent the (new) current key. If it is not possible
<span class="lineNum">    1299 </span>            :  * to step in the specified direction since there are no longer elements, the
<span class="lineNum">    1300 </span>            :  * iterator is flagged with RAX_ITER_EOF.
<span class="lineNum">    1301 </span>            :  *
<span class="lineNum">    1302 </span>            :  * If 'noup' is true the function starts directly scanning for the next
<span class="lineNum">    1303 </span>            :  * lexicographically smaller children, and the current node is already assumed
<span class="lineNum">    1304 </span>            :  * to be the parent of the last key node, so the first operation to go back to
<span class="lineNum">    1305 </span>            :  * the parent will be skipped. This option is used by raxSeek() when
<span class="lineNum">    1306 </span>            :  * implementing seeking a non existing element with the &quot;&gt;&quot; or &quot;&lt;&quot; options:
<span class="lineNum">    1307 </span>            :  * the starting node is not a key in that particular case, so we start the scan
<span class="lineNum">    1308 </span>            :  * from a node that does not represent the key set.
<a name="1309"><span class="lineNum">    1309 </span>            :  *</a>
<span class="lineNum">    1310 </span>            :  * The function returns 1 on success or 0 on out of memory. */
<span class="lineNum">    1311 </span><span class="lineCov">     116573 : int raxIteratorNextStep(raxIterator *it, int noup) {</span>
<span class="lineNum">    1312 </span><span class="lineCov">     116573 :     if (it-&gt;flags &amp; RAX_ITER_EOF) {</span>
<span class="lineNum">    1313 </span>            :         return 1;
<span class="lineNum">    1314 </span><span class="lineCov">     116341 :     } else if (it-&gt;flags &amp; RAX_ITER_JUST_SEEKED) {</span>
<span class="lineNum">    1315 </span><span class="lineCov">      80529 :         it-&gt;flags &amp;= ~RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1316 </span><span class="lineCov">      80529 :         return 1;</span>
<span class="lineNum">    1317 </span>            :     }
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            :     /* Save key len, stack items and the node where we are currently
<span class="lineNum">    1320 </span>            :      * so that on iterator EOF we can restore the current key and state. */
<span class="lineNum">    1321 </span><span class="lineCov">      35812 :     size_t orig_key_len = it-&gt;key_len;</span>
<span class="lineNum">    1322 </span><span class="lineCov">      35812 :     size_t orig_stack_items = it-&gt;stack.items;</span>
<span class="lineNum">    1323 </span><span class="lineCov">      35812 :     raxNode *orig_node = it-&gt;node;</span>
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span><span class="lineCov">      71691 :     while(1) {</span>
<span class="lineNum">    1326 </span><span class="lineCov">      71691 :         int children = it-&gt;node-&gt;iscompr ? 1 : it-&gt;node-&gt;size;</span>
<span class="lineNum">    1327 </span><span class="lineCov">      71691 :         if (!noup &amp;&amp; children) {</span>
<span class="lineNum">    1328 </span><span class="lineCov">      45471 :             debugf(&quot;GO DEEPER\n&quot;);</span>
<span class="lineNum">    1329 </span>            :             /* Seek the lexicographically smaller key in this subtree, which
<span class="lineNum">    1330 </span>            :              * is the first one found always going torwards the first child
<span class="lineNum">    1331 </span>            :              * of every successive node. */
<span class="lineNum">    1332 </span><span class="lineCov">      45471 :             if (!raxStackPush(&amp;it-&gt;stack,it-&gt;node)) return 0;</span>
<span class="lineNum">    1333 </span><span class="lineCov">      45471 :             raxNode **cp = raxNodeFirstChildPtr(it-&gt;node);</span>
<span class="lineNum">    1334 </span><span class="lineCov">      45471 :             if (!raxIteratorAddChars(it,it-&gt;node-&gt;data,</span>
<span class="lineNum">    1335 </span><span class="lineCov">      45471 :                 it-&gt;node-&gt;iscompr ? it-&gt;node-&gt;size : 1)) return 0;</span>
<span class="lineNum">    1336 </span><span class="lineCov">      45471 :             memcpy(&amp;it-&gt;node,cp,sizeof(it-&gt;node));</span>
<span class="lineNum">    1337 </span>            :             /* Call the node callback if any, and replace the node pointer
<span class="lineNum">    1338 </span>            :              * if the callback returns true. */
<span class="lineNum">    1339 </span><span class="lineCov">      45471 :             if (it-&gt;node_cb &amp;&amp; it-&gt;node_cb(&amp;it-&gt;node))</span>
<span class="lineNum">    1340 </span><span class="lineCov">         25 :                 memcpy(cp,&amp;it-&gt;node,sizeof(it-&gt;node));</span>
<span class="lineNum">    1341 </span>            :             /* For &quot;next&quot; step, stop every time we find a key along the
<span class="lineNum">    1342 </span>            :              * way, since the key is lexicograhically smaller compared to
<span class="lineNum">    1343 </span>            :              * what follows in the sub-children. */
<span class="lineNum">    1344 </span><span class="lineCov">      45471 :             if (it-&gt;node-&gt;iskey) {</span>
<span class="lineNum">    1345 </span><span class="lineCov">      23027 :                 it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1346 </span><span class="lineCov">      23027 :                 return 1;</span>
<span class="lineNum">    1347 </span>            :             }
<span class="lineNum">    1348 </span>            :         } else {
<span class="lineNum">    1349 </span>            :             /* If we finished exporing the previous sub-tree, switch to the
<span class="lineNum">    1350 </span>            :              * new one: go upper until a node is found where there are
<span class="lineNum">    1351 </span>            :              * children representing keys lexicographically greater than the
<span class="lineNum">    1352 </span>            :              * current key. */
<span class="lineNum">    1353 </span><span class="lineCov">      48249 :             while(1) {</span>
<span class="lineNum">    1354 </span><span class="lineCov">      48249 :                 int old_noup = noup;</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span>            :                 /* Already on head? Can't go up, iteration finished. */
<span class="lineNum">    1357 </span><span class="lineCov">      48249 :                 if (!noup &amp;&amp; it-&gt;node == it-&gt;rt-&gt;head) {</span>
<span class="lineNum">    1358 </span><span class="lineCov">        513 :                     it-&gt;flags |= RAX_ITER_EOF;</span>
<span class="lineNum">    1359 </span><span class="lineCov">        513 :                     it-&gt;stack.items = orig_stack_items;</span>
<span class="lineNum">    1360 </span><span class="lineCov">        513 :                     it-&gt;key_len = orig_key_len;</span>
<span class="lineNum">    1361 </span><span class="lineCov">        513 :                     it-&gt;node = orig_node;</span>
<span class="lineNum">    1362 </span><span class="lineCov">        513 :                     return 1;</span>
<span class="lineNum">    1363 </span>            :                 }
<span class="lineNum">    1364 </span>            :                 /* If there are no children at the current node, try parent's
<span class="lineNum">    1365 </span>            :                  * next child. */
<span class="lineNum">    1366 </span><span class="lineCov">      47736 :                 unsigned char prevchild = it-&gt;key[it-&gt;key_len-1];</span>
<span class="lineNum">    1367 </span><span class="lineCov">      47736 :                 if (!noup) {</span>
<span class="lineNum">    1368 </span><span class="lineCov">      95424 :                     it-&gt;node = raxStackPop(&amp;it-&gt;stack);</span>
<span class="lineNum">    1369 </span>            :                 } else {
<span class="lineNum">    1370 </span>            :                     noup = 0;
<span class="lineNum">    1371 </span>            :                 }
<span class="lineNum">    1372 </span>            :                 /* Adjust the current key to represent the node we are
<span class="lineNum">    1373 </span>            :                  * at. */
<span class="lineNum">    1374 </span><span class="lineCov">      47736 :                 int todel = it-&gt;node-&gt;iscompr ? it-&gt;node-&gt;size : 1;</span>
<span class="lineNum">    1375 </span><span class="lineCov">      95472 :                 raxIteratorDelChars(it,todel);</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            :                 /* Try visiting the next child if there was at least one
<span class="lineNum">    1378 </span>            :                  * additional child. */
<span class="lineNum">    1379 </span><span class="lineCov">      47736 :                 if (!it-&gt;node-&gt;iscompr &amp;&amp; it-&gt;node-&gt;size &gt; (old_noup ? 0 : 1)) {</span>
<span class="lineNum">    1380 </span><span class="lineCov">      34902 :                     raxNode **cp = raxNodeFirstChildPtr(it-&gt;node);</span>
<span class="lineNum">    1381 </span><span class="lineCov">      34902 :                     int i = 0;</span>
<span class="lineNum">    1382 </span><span class="lineCov">    1020279 :                     while (i &lt; it-&gt;node-&gt;size) {</span>
<span class="lineNum">    1383 </span><span class="lineCov">    1011084 :                         debugf(&quot;SCAN NEXT %c\n&quot;, it-&gt;node-&gt;data[i]);</span>
<span class="lineNum">    1384 </span><span class="lineCov">    1011084 :                         if (it-&gt;node-&gt;data[i] &gt; prevchild) break;</span>
<span class="lineNum">    1385 </span><span class="lineCov">     985377 :                         i++;</span>
<span class="lineNum">    1386 </span><span class="lineCov">     985377 :                         cp++;</span>
<span class="lineNum">    1387 </span>            :                     }
<span class="lineNum">    1388 </span><span class="lineCov">      34902 :                     if (i != it-&gt;node-&gt;size) {</span>
<span class="lineNum">    1389 </span><span class="lineCov">      25707 :                         debugf(&quot;SCAN found a new node\n&quot;);</span>
<span class="lineNum">    1390 </span><span class="lineCov">      25707 :                         raxIteratorAddChars(it,it-&gt;node-&gt;data+i,1);</span>
<span class="lineNum">    1391 </span><span class="lineCov">      25707 :                         if (!raxStackPush(&amp;it-&gt;stack,it-&gt;node)) return 0;</span>
<span class="lineNum">    1392 </span><span class="lineCov">      25707 :                         memcpy(&amp;it-&gt;node,cp,sizeof(it-&gt;node));</span>
<span class="lineNum">    1393 </span>            :                         /* Call the node callback if any, and replace the node
<span class="lineNum">    1394 </span>            :                          * pointer if the callback returns true. */
<span class="lineNum">    1395 </span><span class="lineCov">      25707 :                         if (it-&gt;node_cb &amp;&amp; it-&gt;node_cb(&amp;it-&gt;node))</span>
<span class="lineNum">    1396 </span><span class="lineCov">         53 :                             memcpy(cp,&amp;it-&gt;node,sizeof(it-&gt;node));</span>
<span class="lineNum">    1397 </span><span class="lineCov">      25707 :                         if (it-&gt;node-&gt;iskey) {</span>
<span class="lineNum">    1398 </span><span class="lineCov">      12272 :                             it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1399 </span><span class="lineCov">      12272 :                             return 1;</span>
<span class="lineNum">    1400 </span>            :                         }
<span class="lineNum">    1401 </span>            :                         break;
<span class="lineNum">    1402 </span>            :                     }
<span class="lineNum">    1403 </span>            :                 }
<span class="lineNum">    1404 </span>            :             }
<span class="lineNum">    1405 </span>            :         }
<span class="lineNum">    1406 </span>            :     }
<span class="lineNum">    1407 </span>            : }
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            : /* Seek the greatest key in the subtree at the current node. Return 0 on
<a name="1410"><span class="lineNum">    1410 </span>            :  * out of memory, otherwise 1. This is an helper function for different</a>
<span class="lineNum">    1411 </span>            :  * iteration functions below. */
<span class="lineNum">    1412 </span><span class="lineCov">      83234 : int raxSeekGreatest(raxIterator *it) {</span>
<span class="lineNum">    1413 </span><span class="lineCov">     367274 :     while(it-&gt;node-&gt;size) {</span>
<span class="lineNum">    1414 </span><span class="lineCov">     284040 :         if (it-&gt;node-&gt;iscompr) {</span>
<span class="lineNum">    1415 </span><span class="lineCov">     145969 :             if (!raxIteratorAddChars(it,it-&gt;node-&gt;data,</span>
<span class="lineNum">    1416 </span><span class="lineCov">     145969 :                 it-&gt;node-&gt;size)) return 0;</span>
<span class="lineNum">    1417 </span>            :         } else {
<span class="lineNum">    1418 </span><span class="lineCov">     138071 :             if (!raxIteratorAddChars(it,it-&gt;node-&gt;data+it-&gt;node-&gt;size-1,1))</span>
<span class="lineNum">    1419 </span>            :                 return 0;
<span class="lineNum">    1420 </span>            :         }
<span class="lineNum">    1421 </span><span class="lineCov">     284040 :         raxNode **cp = raxNodeLastChildPtr(it-&gt;node);</span>
<span class="lineNum">    1422 </span><span class="lineCov">     284040 :         if (!raxStackPush(&amp;it-&gt;stack,it-&gt;node)) return 0;</span>
<span class="lineNum">    1423 </span><span class="lineCov">     284040 :         memcpy(&amp;it-&gt;node,cp,sizeof(it-&gt;node));</span>
<span class="lineNum">    1424 </span>            :     }
<span class="lineNum">    1425 </span>            :     return 1;
<span class="lineNum">    1426 </span>            : }
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            : /* Like raxIteratorNextStep() but implements an iteration step moving
<a name="1429"><span class="lineNum">    1429 </span>            :  * to the lexicographically previous element. The 'noup' option has a similar</a>
<span class="lineNum">    1430 </span>            :  * effect to the one of raxIteratorNextStep(). */
<span class="lineNum">    1431 </span><span class="lineCov">      18517 : int raxIteratorPrevStep(raxIterator *it, int noup) {</span>
<span class="lineNum">    1432 </span><span class="lineCov">      18517 :     if (it-&gt;flags &amp; RAX_ITER_EOF) {</span>
<span class="lineNum">    1433 </span>            :         return 1;
<span class="lineNum">    1434 </span><span class="lineCov">      18496 :     } else if (it-&gt;flags &amp; RAX_ITER_JUST_SEEKED) {</span>
<span class="lineNum">    1435 </span><span class="lineCov">       6093 :         it-&gt;flags &amp;= ~RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1436 </span><span class="lineCov">       6093 :         return 1;</span>
<span class="lineNum">    1437 </span>            :     }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            :     /* Save key len, stack items and the node where we are currently
<span class="lineNum">    1440 </span>            :      * so that on iterator EOF we can restore the current key and state. */
<span class="lineNum">    1441 </span><span class="lineCov">      12403 :     size_t orig_key_len = it-&gt;key_len;</span>
<span class="lineNum">    1442 </span><span class="lineCov">      12403 :     size_t orig_stack_items = it-&gt;stack.items;</span>
<span class="lineNum">    1443 </span><span class="lineCov">      12403 :     raxNode *orig_node = it-&gt;node;</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineCov">      13626 :     while(1) {</span>
<span class="lineNum">    1446 </span><span class="lineCov">      13626 :         int old_noup = noup;</span>
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            :         /* Already on head? Can't go up, iteration finished. */
<span class="lineNum">    1449 </span><span class="lineCov">      13626 :         if (!noup &amp;&amp; it-&gt;node == it-&gt;rt-&gt;head) {</span>
<span class="lineNum">    1450 </span><span class="lineCov">         92 :             it-&gt;flags |= RAX_ITER_EOF;</span>
<span class="lineNum">    1451 </span><span class="lineCov">         92 :             it-&gt;stack.items = orig_stack_items;</span>
<span class="lineNum">    1452 </span><span class="lineCov">         92 :             it-&gt;key_len = orig_key_len;</span>
<span class="lineNum">    1453 </span><span class="lineCov">         92 :             it-&gt;node = orig_node;</span>
<span class="lineNum">    1454 </span><span class="lineCov">         92 :             return 1;</span>
<span class="lineNum">    1455 </span>            :         }
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineCov">      13534 :         unsigned char prevchild = it-&gt;key[it-&gt;key_len-1];</span>
<span class="lineNum">    1458 </span><span class="lineCov">      13534 :         if (!noup) {</span>
<span class="lineNum">    1459 </span><span class="lineCov">       2880 :             it-&gt;node = raxStackPop(&amp;it-&gt;stack);</span>
<span class="lineNum">    1460 </span>            :         } else {
<span class="lineNum">    1461 </span>            :             noup = 0;
<span class="lineNum">    1462 </span>            :         }
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span>            :         /* Adjust the current key to represent the node we are
<span class="lineNum">    1465 </span>            :          * at. */
<span class="lineNum">    1466 </span><span class="lineCov">      13534 :         int todel = it-&gt;node-&gt;iscompr ? it-&gt;node-&gt;size : 1;</span>
<span class="lineNum">    1467 </span><span class="lineCov">      27068 :         raxIteratorDelChars(it,todel);</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :         /* Try visiting the prev child if there is at least one
<span class="lineNum">    1470 </span>            :          * child. */
<span class="lineNum">    1471 </span><span class="lineCov">      13534 :         if (!it-&gt;node-&gt;iscompr &amp;&amp; it-&gt;node-&gt;size &gt; (old_noup ? 0 : 1)) {</span>
<span class="lineNum">    1472 </span><span class="lineCov">      12798 :             raxNode **cp = raxNodeLastChildPtr(it-&gt;node);</span>
<span class="lineNum">    1473 </span><span class="lineCov">      12798 :             int i = it-&gt;node-&gt;size-1;</span>
<span class="lineNum">    1474 </span><span class="lineCov">      94429 :             while (i &gt;= 0) {</span>
<span class="lineNum">    1475 </span><span class="lineCov">      93942 :                 debugf(&quot;SCAN PREV %c\n&quot;, it-&gt;node-&gt;data[i]);</span>
<span class="lineNum">    1476 </span><span class="lineCov">      93942 :                 if (it-&gt;node-&gt;data[i] &lt; prevchild) break;</span>
<span class="lineNum">    1477 </span><span class="lineCov">      81631 :                 i--;</span>
<span class="lineNum">    1478 </span><span class="lineCov">      81631 :                 cp--;</span>
<span class="lineNum">    1479 </span>            :             }
<span class="lineNum">    1480 </span>            :             /* If we found a new subtree to explore in this node,
<span class="lineNum">    1481 </span>            :              * go deeper following all the last children in order to
<span class="lineNum">    1482 </span>            :              * find the key lexicographically greater. */
<span class="lineNum">    1483 </span><span class="lineCov">      12798 :             if (i != -1) {</span>
<span class="lineNum">    1484 </span><span class="lineCov">      12311 :                 debugf(&quot;SCAN found a new node\n&quot;);</span>
<span class="lineNum">    1485 </span>            :                 /* Enter the node we just found. */
<span class="lineNum">    1486 </span><span class="lineCov">      12311 :                 if (!raxIteratorAddChars(it,it-&gt;node-&gt;data+i,1)) return 0;</span>
<span class="lineNum">    1487 </span><span class="lineCov">      12311 :                 if (!raxStackPush(&amp;it-&gt;stack,it-&gt;node)) return 0;</span>
<span class="lineNum">    1488 </span><span class="lineCov">      12311 :                 memcpy(&amp;it-&gt;node,cp,sizeof(it-&gt;node));</span>
<span class="lineNum">    1489 </span>            :                 /* Seek sub-tree max. */
<span class="lineNum">    1490 </span><span class="lineCov">      12311 :                 if (!raxSeekGreatest(it)) return 0;</span>
<span class="lineNum">    1491 </span>            :             }
<span class="lineNum">    1492 </span>            :         }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span>            :         /* Return the key: this could be the key we found scanning a new
<span class="lineNum">    1495 </span>            :          * subtree, or if we did not find a new subtree to explore here,
<span class="lineNum">    1496 </span>            :          * before giving up with this node, check if it's a key itself. */
<span class="lineNum">    1497 </span><span class="lineCov">      13534 :         if (it-&gt;node-&gt;iskey) {</span>
<span class="lineNum">    1498 </span><span class="lineCov">      12311 :             it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1499 </span><span class="lineCov">      12311 :             return 1;</span>
<span class="lineNum">    1500 </span>            :         }
<span class="lineNum">    1501 </span>            :     }
<span class="lineNum">    1502 </span>            : }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span>            : /* Seek an iterator at the specified element.
<span class="lineNum">    1505 </span>            :  * Return 0 if the seek failed for syntax error or out of memory. Otherwise
<a name="1506"><span class="lineNum">    1506 </span>            :  * 1 is returned. When 0 is returned for out of memory, errno is set to</a>
<span class="lineNum">    1507 </span>            :  * the ENOMEM value. */
<span class="lineNum">    1508 </span><span class="lineCov">     102613 : int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {</span>
<span class="lineNum">    1509 </span><span class="lineCov">     102613 :     int eq = 0, lt = 0, gt = 0, first = 0, last = 0;</span>
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineCov">     102613 :     it-&gt;stack.items = 0; /* Just resetting. Intialized by raxStart(). */</span>
<span class="lineNum">    1512 </span><span class="lineCov">     102613 :     it-&gt;flags |= RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1513 </span><span class="lineCov">     102613 :     it-&gt;flags &amp;= ~RAX_ITER_EOF;</span>
<span class="lineNum">    1514 </span><span class="lineCov">     102613 :     it-&gt;key_len = 0;</span>
<span class="lineNum">    1515 </span><span class="lineCov">     102613 :     it-&gt;node = NULL;</span>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            :     /* Set flags according to the operator used to perform the seek. */
<span class="lineNum">    1518 </span><span class="lineCov">     102613 :     if (op[0] == '&gt;') {</span>
<span class="lineNum">    1519 </span><span class="lineCov">       9655 :         gt = 1;</span>
<span class="lineNum">    1520 </span><span class="lineCov">       9655 :         if (op[1] == '=') eq = 1;</span>
<span class="lineNum">    1521 </span><span class="lineCov">      92958 :     } else if (op[0] == '&lt;') {</span>
<span class="lineNum">    1522 </span><span class="lineCov">      19136 :         lt = 1;</span>
<span class="lineNum">    1523 </span><span class="lineCov">      19136 :         if (op[1] == '=') eq = 1;</span>
<span class="lineNum">    1524 </span><span class="lineCov">      73822 :     } else if (op[0] == '=') {</span>
<span class="lineNum">    1525 </span>            :         eq = 1;
<span class="lineNum">    1526 </span><span class="lineCov">      73822 :     } else if (op[0] == '^') {</span>
<span class="lineNum">    1527 </span>            :         first = 1;
<span class="lineNum">    1528 </span><span class="lineCov">      64251 :     } else if (op[0] == '$') {</span>
<span class="lineNum">    1529 </span>            :         last = 1;
<span class="lineNum">    1530 </span>            :     } else {
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :         errno = 0;</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :         return 0; /* Error. */</span>
<span class="lineNum">    1533 </span>            :     }
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            :     /* If there are no elements, set the EOF condition immediately and
<span class="lineNum">    1536 </span>            :      * return. */
<span class="lineNum">    1537 </span><span class="lineCov">     102613 :     if (it-&gt;rt-&gt;numele == 0) {</span>
<span class="lineNum">    1538 </span><span class="lineCov">        304 :         it-&gt;flags |= RAX_ITER_EOF;</span>
<span class="lineNum">    1539 </span><span class="lineCov">        304 :         return 1;</span>
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineCov">     102309 :     if (first) {</span>
<span class="lineNum">    1543 </span>            :         /* Seeking the first key greater or equal to the empty string
<span class="lineNum">    1544 </span>            :          * is equivalent to seeking the smaller key available. */
<span class="lineNum">    1545 </span><span class="lineCov">       9511 :         return raxSeek(it,&quot;&gt;=&quot;,NULL,0);</span>
<span class="lineNum">    1546 </span>            :     }
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineCov">      92798 :     if (last) {</span>
<span class="lineNum">    1549 </span>            :         /* Find the greatest key taking always the last child till a
<span class="lineNum">    1550 </span>            :          * final node is found. */
<span class="lineNum">    1551 </span><span class="lineCov">      64070 :         it-&gt;node = it-&gt;rt-&gt;head;</span>
<span class="lineNum">    1552 </span><span class="lineCov">      64070 :         if (!raxSeekGreatest(it)) return 0;</span>
<span class="lineNum">    1553 </span><span class="lineCov">      64070 :         assert(it-&gt;node-&gt;iskey);</span>
<span class="lineNum">    1554 </span><span class="lineCov">      64070 :         it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1555 </span><span class="lineCov">      64070 :         return 1;</span>
<span class="lineNum">    1556 </span>            :     }
<span class="lineNum">    1557 </span>            : 
<span class="lineNum">    1558 </span>            :     /* We need to seek the specified key. What we do here is to actually
<span class="lineNum">    1559 </span>            :      * perform a lookup, and later invoke the prev/next key code that
<span class="lineNum">    1560 </span>            :      * we already use for iteration. */
<span class="lineNum">    1561 </span><span class="lineCov">      28728 :     int splitpos = 0;</span>
<span class="lineNum">    1562 </span><span class="lineCov">      28728 :     size_t i = raxLowWalk(it-&gt;rt,ele,len,&amp;it-&gt;node,NULL,&amp;splitpos,&amp;it-&gt;stack);</span>
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span>            :     /* Return OOM on incomplete stack info. */
<span class="lineNum">    1565 </span><span class="lineCov">      28728 :     if (it-&gt;stack.oom) return 0;</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineCov">      28728 :     if (eq &amp;&amp; i == len &amp;&amp; (!it-&gt;node-&gt;iscompr || splitpos == 0) &amp;&amp;</span>
<span class="lineNum">    1568 </span>            :         it-&gt;node-&gt;iskey)
<span class="lineNum">    1569 </span>            :     {
<span class="lineNum">    1570 </span>            :         /* We found our node, since the key matches and we have an
<span class="lineNum">    1571 </span>            :          * &quot;equal&quot; condition. */
<span class="lineNum">    1572 </span><span class="lineCov">        165 :         if (!raxIteratorAddChars(it,ele,len)) return 0; /* OOM. */</span>
<span class="lineNum">    1573 </span><span class="lineCov">        165 :         it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1574 </span><span class="lineCov">      28563 :     } else if (lt || gt) {</span>
<span class="lineNum">    1575 </span>            :         /* Exact key not found or eq flag not set. We have to set as current
<span class="lineNum">    1576 </span>            :          * key the one represented by the node we stopped at, and perform
<span class="lineNum">    1577 </span>            :          * a next/prev operation to seek. To reconstruct the key at this node
<span class="lineNum">    1578 </span>            :          * we start from the parent and go to the current node, accumulating
<span class="lineNum">    1579 </span>            :          * the characters found along the way. */
<span class="lineNum">    1580 </span><span class="lineCov">      28563 :         if (!raxStackPush(&amp;it-&gt;stack,it-&gt;node)) return 0;</span>
<span class="lineNum">    1581 </span><span class="lineCov">      55843 :         for (size_t j = 1; j &lt; it-&gt;stack.items; j++) {</span>
<span class="lineNum">    1582 </span><span class="lineCov">      27280 :             raxNode *parent = it-&gt;stack.stack[j-1];</span>
<span class="lineNum">    1583 </span><span class="lineCov">      27280 :             raxNode *child = it-&gt;stack.stack[j];</span>
<span class="lineNum">    1584 </span><span class="lineCov">      27280 :             if (parent-&gt;iscompr) {</span>
<span class="lineNum">    1585 </span><span class="lineCov">      13186 :                 if (!raxIteratorAddChars(it,parent-&gt;data,parent-&gt;size))</span>
<span class="lineNum">    1586 </span>            :                     return 0;
<span class="lineNum">    1587 </span>            :             } else {
<span class="lineNum">    1588 </span><span class="lineCov">      14094 :                 raxNode **cp = raxNodeFirstChildPtr(parent);</span>
<span class="lineNum">    1589 </span><span class="lineCov">      14094 :                 unsigned char *p = parent-&gt;data;</span>
<span class="lineNum">    1590 </span><span class="lineCov">      49800 :                 while(1) {</span>
<span class="lineNum">    1591 </span><span class="lineCov">      31947 :                     raxNode *aux;</span>
<span class="lineNum">    1592 </span><span class="lineCov">      31947 :                     memcpy(&amp;aux,cp,sizeof(aux));</span>
<span class="lineNum">    1593 </span><span class="lineCov">      31947 :                     if (aux == child) break;</span>
<span class="lineNum">    1594 </span><span class="lineCov">      17853 :                     cp++;</span>
<span class="lineNum">    1595 </span><span class="lineCov">      17853 :                     p++;</span>
<span class="lineNum">    1596 </span>            :                 }
<span class="lineNum">    1597 </span><span class="lineCov">      14094 :                 if (!raxIteratorAddChars(it,p,1)) return 0;</span>
<span class="lineNum">    1598 </span>            :             }
<span class="lineNum">    1599 </span>            :         }
<span class="lineNum">    1600 </span><span class="lineCov">      28563 :         raxStackPop(&amp;it-&gt;stack);</span>
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span>            :         /* We need to set the iterator in the correct state to call next/prev
<span class="lineNum">    1603 </span>            :          * step in order to seek the desired element. */
<span class="lineNum">    1604 </span>            :         debugf(&quot;After initial seek: i=%d len=%d key=%.*s\n&quot;,
<span class="lineNum">    1605 </span><span class="lineCov">      28563 :             (int)i, (int)len, (int)it-&gt;key_len, it-&gt;key);</span>
<span class="lineNum">    1606 </span><span class="lineCov">      28563 :         if (i != len &amp;&amp; !it-&gt;node-&gt;iscompr) {</span>
<span class="lineNum">    1607 </span>            :             /* If we stopped in the middle of a normal node because of a
<span class="lineNum">    1608 </span>            :              * mismatch, add the mismatching character to the current key
<span class="lineNum">    1609 </span>            :              * and call the iterator with the 'noup' flag so that it will try
<span class="lineNum">    1610 </span>            :              * to seek the next/prev child in the current node directly based
<span class="lineNum">    1611 </span>            :              * on the mismatching character. */
<span class="lineNum">    1612 </span><span class="lineCov">      11529 :             if (!raxIteratorAddChars(it,ele+i,1)) return 0;</span>
<span class="lineNum">    1613 </span>            :             debugf(&quot;Seek normal node on mismatch: %.*s\n&quot;,
<span class="lineNum">    1614 </span><span class="lineCov">      11529 :                 (int)it-&gt;key_len, (char*)it-&gt;key);</span>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineCov">      11529 :             it-&gt;flags &amp;= ~RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1617 </span><span class="lineCov">      11529 :             if (lt &amp;&amp; !raxIteratorPrevStep(it,1)) return 0;</span>
<span class="lineNum">    1618 </span><span class="lineCov">      11529 :             if (gt &amp;&amp; !raxIteratorNextStep(it,1)) return 0;</span>
<span class="lineNum">    1619 </span><span class="lineCov">      11529 :             it-&gt;flags |= RAX_ITER_JUST_SEEKED; /* Ignore next call. */</span>
<span class="lineNum">    1620 </span><span class="lineCov">      17034 :         } else if (i != len &amp;&amp; it-&gt;node-&gt;iscompr) {</span>
<span class="lineNum">    1621 </span>            :             debugf(&quot;Compressed mismatch: %.*s\n&quot;,
<span class="lineNum">    1622 </span><span class="lineCov">       7523 :                 (int)it-&gt;key_len, (char*)it-&gt;key);</span>
<span class="lineNum">    1623 </span>            :             /* In case of a mismatch within a compressed node. */
<span class="lineNum">    1624 </span><span class="lineCov">       7523 :             int nodechar = it-&gt;node-&gt;data[splitpos];</span>
<span class="lineNum">    1625 </span><span class="lineCov">       7523 :             int keychar = ele[i];</span>
<span class="lineNum">    1626 </span><span class="lineCov">       7523 :             it-&gt;flags &amp;= ~RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1627 </span><span class="lineCov">       7523 :             if (gt) {</span>
<span class="lineNum">    1628 </span>            :                 /* If the key the compressed node represents is greater
<span class="lineNum">    1629 </span>            :                  * than our seek element, continue forward, otherwise set the
<span class="lineNum">    1630 </span>            :                  * state in order to go back to the next sub-tree. */
<span class="lineNum">    1631 </span><span class="lineCov">         81 :                 if (nodechar &gt; keychar) {</span>
<span class="lineNum">    1632 </span><span class="lineCov">         81 :                     if (!raxIteratorNextStep(it,0)) return 0;</span>
<span class="lineNum">    1633 </span>            :                 } else {
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 :                     if (!raxIteratorAddChars(it,it-&gt;node-&gt;data,it-&gt;node-&gt;size))</span>
<span class="lineNum">    1635 </span>            :                         return 0;
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :                     if (!raxIteratorNextStep(it,1)) return 0;</span>
<span class="lineNum">    1637 </span>            :                 }
<span class="lineNum">    1638 </span>            :             }
<span class="lineNum">    1639 </span><span class="lineCov">       7523 :             if (lt) {</span>
<span class="lineNum">    1640 </span>            :                 /* If the key the compressed node represents is smaller
<span class="lineNum">    1641 </span>            :                  * than our seek element, seek the greater key in this
<span class="lineNum">    1642 </span>            :                  * subtree, otherwise set the state in order to go back to
<span class="lineNum">    1643 </span>            :                  * the previous sub-tree. */
<span class="lineNum">    1644 </span><span class="lineCov">       7442 :                 if (nodechar &lt; keychar) {</span>
<span class="lineNum">    1645 </span><span class="lineCov">       6853 :                     if (!raxSeekGreatest(it)) return 0;</span>
<span class="lineNum">    1646 </span><span class="lineCov">       6853 :                     it-&gt;data = raxGetData(it-&gt;node);</span>
<span class="lineNum">    1647 </span>            :                 } else {
<span class="lineNum">    1648 </span><span class="lineCov">        589 :                     if (!raxIteratorAddChars(it,it-&gt;node-&gt;data,it-&gt;node-&gt;size))</span>
<span class="lineNum">    1649 </span>            :                         return 0;
<span class="lineNum">    1650 </span><span class="lineCov">        589 :                     if (!raxIteratorPrevStep(it,1)) return 0;</span>
<span class="lineNum">    1651 </span>            :                 }
<span class="lineNum">    1652 </span>            :             }
<span class="lineNum">    1653 </span><span class="lineCov">       7523 :             it-&gt;flags |= RAX_ITER_JUST_SEEKED; /* Ignore next call. */</span>
<span class="lineNum">    1654 </span>            :         } else {
<span class="lineNum">    1655 </span>            :             debugf(&quot;No mismatch: %.*s\n&quot;,
<span class="lineNum">    1656 </span><span class="lineCov">       9511 :                 (int)it-&gt;key_len, (char*)it-&gt;key);</span>
<span class="lineNum">    1657 </span>            :             /* If there was no mismatch we are into a node representing the
<span class="lineNum">    1658 </span>            :              * key, (but which is not a key or the seek operator does not
<span class="lineNum">    1659 </span>            :              * include 'eq'), or we stopped in the middle of a compressed node
<span class="lineNum">    1660 </span>            :              * after processing all the key. Continue iterating as this was
<span class="lineNum">    1661 </span>            :              * a legitimate key we stopped at. */
<span class="lineNum">    1662 </span><span class="lineCov">       9511 :             it-&gt;flags &amp;= ~RAX_ITER_JUST_SEEKED;</span>
<span class="lineNum">    1663 </span><span class="lineCov">       9511 :             if (it-&gt;node-&gt;iscompr &amp;&amp; it-&gt;node-&gt;iskey &amp;&amp; splitpos &amp;&amp; lt) {</span>
<span class="lineNum">    1664 </span>            :                 /* If we stopped in the middle of a compressed node with
<span class="lineNum">    1665 </span>            :                  * perfect match, and the condition is to seek a key &quot;&lt;&quot; than
<span class="lineNum">    1666 </span>            :                  * the specified one, then if this node is a key it already
<span class="lineNum">    1667 </span>            :                  * represents our match. For instance we may have nodes:
<span class="lineNum">    1668 </span>            :                  *
<span class="lineNum">    1669 </span>            :                  * &quot;f&quot; -&gt; &quot;oobar&quot; = 1 -&gt; &quot;&quot; = 2
<span class="lineNum">    1670 </span>            :                  *
<span class="lineNum">    1671 </span>            :                  * Representing keys &quot;f&quot; = 1, &quot;foobar&quot; = 2. A seek for
<span class="lineNum">    1672 </span>            :                  * the key &lt; &quot;foo&quot; will stop in the middle of the &quot;oobar&quot;
<span class="lineNum">    1673 </span>            :                  * node, but will be our match, representing the key &quot;f&quot;.
<span class="lineNum">    1674 </span>            :                  *
<span class="lineNum">    1675 </span>            :                  * So in that case, we don't seek backward. */
<span class="lineNum">    1676 </span>            :             } else {
<span class="lineNum">    1677 </span><span class="lineCov">       9511 :                 if (gt &amp;&amp; !raxIteratorNextStep(it,0)) return 0;</span>
<span class="lineNum">    1678 </span><span class="lineCov">       9511 :                 if (lt &amp;&amp; !raxIteratorPrevStep(it,0)) return 0;</span>
<span class="lineNum">    1679 </span>            :             }
<span class="lineNum">    1680 </span><span class="lineCov">       9511 :             it-&gt;flags |= RAX_ITER_JUST_SEEKED; /* Ignore next call. */</span>
<span class="lineNum">    1681 </span>            :         }
<span class="lineNum">    1682 </span>            :     } else {
<span class="lineNum">    1683 </span>            :         /* If we are here just eq was set but no match was found. */
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :         it-&gt;flags |= RAX_ITER_EOF;</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    1686 </span>            :     }
<span class="lineNum">    1687 </span>            :     return 1;
<span class="lineNum">    1688 </span>            : }
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : /* Go to the next element in the scope of the iterator 'it'.
<a name="1691"><span class="lineNum">    1691 </span>            :  * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is</a>
<span class="lineNum">    1692 </span>            :  * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */
<span class="lineNum">    1693 </span><span class="lineCov">     106957 : int raxNext(raxIterator *it) {</span>
<span class="lineNum">    1694 </span><span class="lineCov">     106957 :     if (!raxIteratorNextStep(it,0)) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :         errno = ENOMEM;</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1697 </span>            :     }
<span class="lineNum">    1698 </span><span class="lineCov">     106957 :     if (it-&gt;flags &amp; RAX_ITER_EOF) {</span>
<span class="lineNum">    1699 </span><span class="lineCov">        745 :         errno = 0;</span>
<span class="lineNum">    1700 </span><span class="lineCov">        745 :         return 0;</span>
<span class="lineNum">    1701 </span>            :     }
<span class="lineNum">    1702 </span>            :     return 1;
<span class="lineNum">    1703 </span>            : }
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span>            : /* Go to the previous element in the scope of the iterator 'it'.
<a name="1706"><span class="lineNum">    1706 </span>            :  * If EOF (or out of memory) is reached, 0 is returned, otherwise 1 is</a>
<span class="lineNum">    1707 </span>            :  * returned. In case 0 is returned because of OOM, errno is set to ENOMEM. */
<span class="lineNum">    1708 </span><span class="lineCov">       6423 : int raxPrev(raxIterator *it) {</span>
<span class="lineNum">    1709 </span><span class="lineCov">       6423 :     if (!raxIteratorPrevStep(it,0)) {</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         errno = ENOMEM;</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1712 </span>            :     }
<span class="lineNum">    1713 </span><span class="lineCov">       6423 :     if (it-&gt;flags &amp; RAX_ITER_EOF) {</span>
<span class="lineNum">    1714 </span><span class="lineCov">         30 :         errno = 0;</span>
<span class="lineNum">    1715 </span><span class="lineCov">         30 :         return 0;</span>
<span class="lineNum">    1716 </span>            :     }
<span class="lineNum">    1717 </span>            :     return 1;
<span class="lineNum">    1718 </span>            : }
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            : /* Perform a random walk starting in the current position of the iterator.
<span class="lineNum">    1721 </span>            :  * Return 0 if the tree is empty or on out of memory. Otherwise 1 is returned
<span class="lineNum">    1722 </span>            :  * and the iterator is set to the node reached after doing a random walk
<span class="lineNum">    1723 </span>            :  * of 'steps' steps. If the 'steps' argument is 0, the random walk is performed
<span class="lineNum">    1724 </span>            :  * using a random number of steps between 1 and two times the logarithm of
<span class="lineNum">    1725 </span>            :  * the number of elements.
<span class="lineNum">    1726 </span>            :  *
<span class="lineNum">    1727 </span>            :  * NOTE: if you use this function to generate random elements from the radix
<span class="lineNum">    1728 </span>            :  * tree, expect a disappointing distribution. A random walk produces good
<span class="lineNum">    1729 </span>            :  * random elements if the tree is not sparse, however in the case of a radix
<a name="1730"><span class="lineNum">    1730 </span>            :  * tree certain keys will be reported much more often than others. At least</a>
<span class="lineNum">    1731 </span>            :  * this function should be able to expore every possible element eventually. */
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 : int raxRandomWalk(raxIterator *it, size_t steps) {</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :     if (it-&gt;rt-&gt;numele == 0) {</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :         it-&gt;flags |= RAX_ITER_EOF;</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1736 </span>            :     }
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :     if (steps == 0) {</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :         size_t fle = floor(log(it-&gt;rt-&gt;numele));</span>
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 :         fle *= 2;</span>
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :         steps = 1 + rand() % fle;</span>
<span class="lineNum">    1742 </span>            :     }
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     raxNode *n = it-&gt;node;</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :     while(steps &gt; 0 || !n-&gt;iskey) {</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :         int numchildren = n-&gt;iscompr ? 1 : n-&gt;size;</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :         int r = rand() % (numchildren+(n != it-&gt;rt-&gt;head));</span>
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :         if (r == numchildren) {</span>
<span class="lineNum">    1750 </span>            :             /* Go up to parent. */
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :             n = raxStackPop(&amp;it-&gt;stack);</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :             int todel = n-&gt;iscompr ? n-&gt;size : 1;</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :             raxIteratorDelChars(it,todel);</span>
<span class="lineNum">    1754 </span>            :         } else {
<span class="lineNum">    1755 </span>            :             /* Select a random child. */
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :             if (n-&gt;iscompr) {</span>
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :                 if (!raxIteratorAddChars(it,n-&gt;data,n-&gt;size)) return 0;</span>
<span class="lineNum">    1758 </span>            :             } else {
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :                 if (!raxIteratorAddChars(it,n-&gt;data+r,1)) return 0;</span>
<span class="lineNum">    1760 </span>            :             }
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :             raxNode **cp = raxNodeFirstChildPtr(n)+r;</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :             if (!raxStackPush(&amp;it-&gt;stack,n)) return 0;</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :             memcpy(&amp;n,cp,sizeof(n));</span>
<span class="lineNum">    1764 </span>            :         }
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :         if (n-&gt;iskey) steps--;</span>
<span class="lineNum">    1766 </span>            :     }
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     it-&gt;node = n;</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :     return 1;</span>
<span class="lineNum">    1769 </span>            : }
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            : /* Compare the key currently pointed by the iterator to the specified
<a name="1772"><span class="lineNum">    1772 </span>            :  * key according to the specified operator. Returns 1 if the comparison is</a>
<span class="lineNum">    1773 </span>            :  * true, otherwise 0 is returned. */
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 : int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     int eq = 0, lt = 0, gt = 0;</span>
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     if (op[0] == '=' || op[1] == '=') eq = 1;</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :     if (op[0] == '&gt;') gt = 1;</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :     else if (op[0] == '&lt;') lt = 1;</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :     else if (op[1] != '=') return 0; /* Syntax error. */</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :     size_t minlen = key_len &lt; iter-&gt;key_len ? key_len : iter-&gt;key_len;</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :     int cmp = memcmp(iter-&gt;key,key,minlen);</span>
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span>            :     /* Handle == */
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :     if (lt == 0 &amp;&amp; gt == 0) return cmp == 0 &amp;&amp; key_len == iter-&gt;key_len;</span>
<span class="lineNum">    1787 </span>            : 
<span class="lineNum">    1788 </span>            :     /* Handle &gt;, &gt;=, &lt;, &lt;= */
<span class="lineNum">    1789 </span><span class="lineNoCov">          0 :     if (cmp == 0) {</span>
<span class="lineNum">    1790 </span>            :         /* Same prefix: longer wins. */
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :         if (eq &amp;&amp; key_len == iter-&gt;key_len) return 1;</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :         else if (lt) return iter-&gt;key_len &lt; key_len;</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :         else if (gt) return iter-&gt;key_len &gt; key_len;</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :     } if (cmp &gt; 0) {</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :         return gt ? 1 : 0;</span>
<span class="lineNum">    1796 </span>            :     } else /* (cmp &lt; 0) */ {
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :         return lt ? 1 : 0;</span>
<span class="lineNum">    1798 </span>            :     }
<span class="lineNum">    1799 </span>            : }
<a name="1800"><span class="lineNum">    1800 </span>            : </a>
<span class="lineNum">    1801 </span>            : /* Free the iterator. */
<span class="lineNum">    1802 </span><span class="lineCov">      92950 : void raxStop(raxIterator *it) {</span>
<span class="lineNum">    1803 </span><span class="lineCov">      92950 :     if (it-&gt;key != it-&gt;key_static_string) rax_free(it-&gt;key);</span>
<span class="lineNum">    1804 </span><span class="lineCov">      92950 :     raxStackFree(&amp;it-&gt;stack);</span>
<span class="lineNum">    1805 </span><span class="lineCov">      92950 : }</span>
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            : /* Return if the iterator is in an EOF state. This happens when raxSeek()
<span class="lineNum">    1808 </span>            :  * failed to seek an appropriate element, so that raxNext() or raxPrev()
<a name="1809"><span class="lineNum">    1809 </span>            :  * will return zero, or when an EOF condition was reached while iterating</a>
<span class="lineNum">    1810 </span>            :  * with raxNext() and raxPrev(). */
<span class="lineNum">    1811 </span><span class="lineCov">      19136 : int raxEOF(raxIterator *it) {</span>
<span class="lineNum">    1812 </span><span class="lineCov">      19136 :     return it-&gt;flags &amp; RAX_ITER_EOF;</span>
<span class="lineNum">    1813 </span>            : }
<a name="1814"><span class="lineNum">    1814 </span>            : </a>
<span class="lineNum">    1815 </span>            : /* Return the number of elements inside the radix tree. */
<span class="lineNum">    1816 </span><span class="lineCov">       6341 : uint64_t raxSize(rax *rax) {</span>
<span class="lineNum">    1817 </span><span class="lineCov">       6341 :     return rax-&gt;numele;</span>
<span class="lineNum">    1818 </span>            : }
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            : /* ----------------------------- Introspection ------------------------------ */
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span>            : /* This function is mostly used for debugging and learning purposes.
<span class="lineNum">    1823 </span>            :  * It shows an ASCII representation of a tree on standard output, outling
<span class="lineNum">    1824 </span>            :  * all the nodes and the contained keys.
<span class="lineNum">    1825 </span>            :  *
<span class="lineNum">    1826 </span>            :  * The representation is as follow:
<span class="lineNum">    1827 </span>            :  *
<span class="lineNum">    1828 </span>            :  *  &quot;foobar&quot; (compressed node)
<span class="lineNum">    1829 </span>            :  *  [abc] (normal node with three children)
<span class="lineNum">    1830 </span>            :  *  [abc]=0x12345678 (node is a key, pointing to value 0x12345678)
<span class="lineNum">    1831 </span>            :  *  [] (a normal empty node)
<span class="lineNum">    1832 </span>            :  *
<span class="lineNum">    1833 </span>            :  *  Children are represented in new idented lines, each children prefixed by
<span class="lineNum">    1834 </span>            :  *  the &quot;`-(x)&quot; string, where &quot;x&quot; is the edge byte.
<span class="lineNum">    1835 </span>            :  *
<span class="lineNum">    1836 </span>            :  *  [abc]
<span class="lineNum">    1837 </span>            :  *   `-(a) &quot;ladin&quot;
<span class="lineNum">    1838 </span>            :  *   `-(b) [kj]
<span class="lineNum">    1839 </span>            :  *   `-(c) []
<span class="lineNum">    1840 </span>            :  *
<span class="lineNum">    1841 </span>            :  *  However when a node has a single child the following representation
<span class="lineNum">    1842 </span>            :  *  is used instead:
<span class="lineNum">    1843 </span>            :  *
<span class="lineNum">    1844 </span>            :  *  [abc] -&gt; &quot;ladin&quot; -&gt; []
<span class="lineNum">    1845 </span>            :  */
<a name="1846"><span class="lineNum">    1846 </span>            : </a>
<span class="lineNum">    1847 </span>            : /* The actual implementation of raxShow(). */
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 : void raxRecursiveShow(int level, int lpad, raxNode *n) {</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :     char s = n-&gt;iscompr ? '&quot;' : '[';</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :     char e = n-&gt;iscompr ? '&quot;' : ']';</span>
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :     int numchars = printf(&quot;%c%.*s%c&quot;, s, n-&gt;size, n-&gt;data, e);</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :     if (n-&gt;iskey) {</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :         numchars += printf(&quot;=%p&quot;,raxGetData(n));</span>
<span class="lineNum">    1855 </span>            :     }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :     int numchildren = n-&gt;iscompr ? 1 : n-&gt;size;</span>
<span class="lineNum">    1858 </span>            :     /* Note that 7 and 4 magic constants are the string length
<span class="lineNum">    1859 </span>            :      * of &quot; `-(x) &quot; and &quot; -&gt; &quot; respectively. */
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :     if (level) {</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         lpad += (numchildren &gt; 1) ? 7 : 4;</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :         if (numchildren == 1) lpad += numchars;</span>
<span class="lineNum">    1863 </span>            :     }
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :     raxNode **cp = raxNodeFirstChildPtr(n);</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; numchildren; i++) {</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :         char *branch = &quot; `-(%c) &quot;;</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :         if (numchildren &gt; 1) {</span>
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :             printf(&quot;\n&quot;);</span>
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :             for (int j = 0; j &lt; lpad; j++) putchar(' ');</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :             printf(branch,n-&gt;data[i]);</span>
<span class="lineNum">    1871 </span>            :         } else {
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :             printf(&quot; -&gt; &quot;);</span>
<span class="lineNum">    1873 </span>            :         }
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :         raxNode *child;</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :         memcpy(&amp;child,cp,sizeof(child));</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :         raxRecursiveShow(level+1,lpad,child);</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :         cp++;</span>
<span class="lineNum">    1878 </span>            :     }
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 : }</span>
<a name="1880"><span class="lineNum">    1880 </span>            : </a>
<span class="lineNum">    1881 </span>            : /* Show a tree, as outlined in the comment above. */
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 : void raxShow(rax *rax) {</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :     raxRecursiveShow(0,0,rax-&gt;head);</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :     putchar('\n');</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 : }</span>
<a name="1886"><span class="lineNum">    1886 </span>            : </a>
<span class="lineNum">    1887 </span>            : /* Used by debugnode() macro to show info about a given node. */
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 : void raxDebugShowNode(const char *msg, raxNode *n) {</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :     if (raxDebugMsg == 0) return;</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :     printf(&quot;%s: %p [%.*s] key:%d size:%d children:&quot;,</span>
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :         msg, (void*)n, (int)n-&gt;size, (char*)n-&gt;data, n-&gt;iskey, n-&gt;size);</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :     int numcld = n-&gt;iscompr ? 1 : n-&gt;size;</span>
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :     raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     while(numcld--) {</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :         raxNode *child;</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :         memcpy(&amp;child,cldptr,sizeof(child));</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :         cldptr++;</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :         printf(&quot;%p &quot;, (void*)child);</span>
<span class="lineNum">    1899 </span>            :     }
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     printf(&quot;\n&quot;);</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     fflush(stdout);</span>
<span class="lineNum">    1902 </span>            : }
<span class="lineNum">    1903 </span>            : 
<span class="lineNum">    1904 </span>            : /* Touch all the nodes of a tree returning a check sum. This is useful
<span class="lineNum">    1905 </span>            :  * in order to make Valgrind detect if there is something wrong while
<span class="lineNum">    1906 </span>            :  * reading the data structure.
<span class="lineNum">    1907 </span>            :  *
<span class="lineNum">    1908 </span>            :  * This function was used in order to identify Rax bugs after a big refactoring
<span class="lineNum">    1909 </span>            :  * using this technique:
<span class="lineNum">    1910 </span>            :  *
<span class="lineNum">    1911 </span>            :  * 1. The rax-test is executed using Valgrind, adding a printf() so that for
<span class="lineNum">    1912 </span>            :  *    the fuzz tester we see what iteration in the loop we are in.
<span class="lineNum">    1913 </span>            :  * 2. After every modification of the radix tree made by the fuzz tester
<span class="lineNum">    1914 </span>            :  *    in rax-test.c, we add a call to raxTouch().
<span class="lineNum">    1915 </span>            :  * 3. Now as soon as an operation will corrupt the tree, raxTouch() will
<span class="lineNum">    1916 </span>            :  *    detect it (via Valgrind) immediately. We can add more calls to narrow
<span class="lineNum">    1917 </span>            :  *    the state.
<span class="lineNum">    1918 </span>            :  * 4. At this point a good idea is to enable Rax debugging messages immediately
<a name="1919"><span class="lineNum">    1919 </span>            :  *    before the moment the tree is corrupted, to see what happens.</a>
<span class="lineNum">    1920 </span>            :  */
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 : unsigned long raxTouch(raxNode *n) {</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     debugf(&quot;Touching %p\n&quot;, (void*)n);</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :     unsigned long sum = 0;</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :     if (n-&gt;iskey) {</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :         sum += (unsigned long)raxGetData(n);</span>
<span class="lineNum">    1926 </span>            :     }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     int numchildren = n-&gt;iscompr ? 1 : n-&gt;size;</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     raxNode **cp = raxNodeFirstChildPtr(n);</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :     int count = 0;</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :     for (int i = 0; i &lt; numchildren; i++) {</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :         if (numchildren &gt; 1) {</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :             sum += (long)n-&gt;data[i];</span>
<span class="lineNum">    1934 </span>            :         }
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :         raxNode *child;</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :         memcpy(&amp;child,cp,sizeof(child));</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :         if (child == (void*)0x65d1760) count++;</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :         if (count &gt; 1) exit(1);</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :         sum += raxTouch(child);</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :         cp++;</span>
<span class="lineNum">    1941 </span>            :     }
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :     return sum;</span>
<span class="lineNum">    1943 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
