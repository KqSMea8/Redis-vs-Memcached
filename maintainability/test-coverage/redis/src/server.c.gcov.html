<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - redis.info - src/server.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - server.c<span style="font-size: 80%;"> (source / <a href="server.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">redis.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1499</td>
            <td class="headerCovTableEntry">1884</td>
            <td class="headerCovTableEntryMed">79.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-11-29 23:16:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">75</td>
            <td class="headerCovTableEntry">90</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2009-2016, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
<span class="lineNum">       3 </span>            :  * All rights reserved.
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  *   * Redistributions of source code must retain the above copyright notice,
<span class="lineNum">       9 </span>            :  *     this list of conditions and the following disclaimer.
<span class="lineNum">      10 </span>            :  *   * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      11 </span>            :  *     notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      12 </span>            :  *     documentation and/or other materials provided with the distribution.
<span class="lineNum">      13 </span>            :  *   * Neither the name of Redis nor the names of its contributors may be used
<span class="lineNum">      14 </span>            :  *     to endorse or promote products derived from this software without
<span class="lineNum">      15 </span>            :  *     specific prior written permission.
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      18 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      19 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      20 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      21 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      22 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      23 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      24 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      25 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      26 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      27 </span>            :  * POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      28 </span>            :  */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;server.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;cluster.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;slowlog.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;bio.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;latency.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;atomicvar.h&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;sys/wait.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;ctype.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      44 </span>            : #include &lt;arpa/inet.h&gt;
<span class="lineNum">      45 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      46 </span>            : #include &lt;fcntl.h&gt;
<span class="lineNum">      47 </span>            : #include &lt;sys/time.h&gt;
<span class="lineNum">      48 </span>            : #include &lt;sys/resource.h&gt;
<span class="lineNum">      49 </span>            : #include &lt;sys/uio.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;sys/un.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;limits.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;sys/resource.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;sys/utsname.h&gt;
<span class="lineNum">      56 </span>            : #include &lt;locale.h&gt;
<span class="lineNum">      57 </span>            : #include &lt;sys/socket.h&gt;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* Our shared &quot;common&quot; objects */
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : struct sharedObjectsStruct shared;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : /* Global vars that are actually used as constants. The following double
<span class="lineNum">      64 </span>            :  * values are used for double on-disk serialization, and are initialized
<span class="lineNum">      65 </span>            :  * at runtime to avoid strange compiler optimizations. */
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : double R_Zero, R_PosInf, R_NegInf, R_Nan;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : /*================================= Globals ================================= */
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /* Global vars */
<span class="lineNum">      72 </span>            : struct redisServer server; /* Server global state */
<span class="lineNum">      73 </span>            : volatile unsigned long lru_clock; /* Server global current LRU time. */
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /* Our command table.
<span class="lineNum">      76 </span>            :  *
<span class="lineNum">      77 </span>            :  * Every entry is composed of the following fields:
<span class="lineNum">      78 </span>            :  *
<span class="lineNum">      79 </span>            :  * name: a string representing the command name.
<span class="lineNum">      80 </span>            :  * function: pointer to the C function implementing the command.
<span class="lineNum">      81 </span>            :  * arity: number of arguments, it is possible to use -N to say &gt;= N
<span class="lineNum">      82 </span>            :  * sflags: command flags as string. See below for a table of flags.
<span class="lineNum">      83 </span>            :  * flags: flags as bitmask. Computed by Redis using the 'sflags' field.
<span class="lineNum">      84 </span>            :  * get_keys_proc: an optional function to get key arguments from a command.
<span class="lineNum">      85 </span>            :  *                This is only used when the following three fields are not
<span class="lineNum">      86 </span>            :  *                enough to specify what arguments are keys.
<span class="lineNum">      87 </span>            :  * first_key_index: first argument that is a key
<span class="lineNum">      88 </span>            :  * last_key_index: last argument that is a key
<span class="lineNum">      89 </span>            :  * key_step: step to get all the keys from first to last argument. For instance
<span class="lineNum">      90 </span>            :  *           in MSET the step is two since arguments are key,val,key,val,...
<span class="lineNum">      91 </span>            :  * microseconds: microseconds of total execution time for this command.
<span class="lineNum">      92 </span>            :  * calls: total number of calls of this command.
<span class="lineNum">      93 </span>            :  *
<span class="lineNum">      94 </span>            :  * The flags, microseconds and calls fields are computed by Redis and should
<span class="lineNum">      95 </span>            :  * always be set to zero.
<span class="lineNum">      96 </span>            :  *
<span class="lineNum">      97 </span>            :  * Command flags are expressed using strings where every character represents
<span class="lineNum">      98 </span>            :  * a flag. Later the populateCommandTable() function will take care of
<span class="lineNum">      99 </span>            :  * populating the real 'flags' field using this characters.
<span class="lineNum">     100 </span>            :  *
<span class="lineNum">     101 </span>            :  * This is the meaning of the flags:
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * w: write command (may modify the key space).
<span class="lineNum">     104 </span>            :  * r: read command  (will never modify the key space).
<span class="lineNum">     105 </span>            :  * m: may increase memory usage once called. Don't allow if out of memory.
<span class="lineNum">     106 </span>            :  * a: admin command, like SAVE or SHUTDOWN.
<span class="lineNum">     107 </span>            :  * p: Pub/Sub related command.
<span class="lineNum">     108 </span>            :  * f: force replication of this command, regardless of server.dirty.
<span class="lineNum">     109 </span>            :  * s: command not allowed in scripts.
<span class="lineNum">     110 </span>            :  * R: random command. Command is not deterministic, that is, the same command
<span class="lineNum">     111 </span>            :  *    with the same arguments, with the same key space, may have different
<span class="lineNum">     112 </span>            :  *    results. For instance SPOP and RANDOMKEY are two random commands.
<span class="lineNum">     113 </span>            :  * S: Sort command output array if called from script, so that the output
<span class="lineNum">     114 </span>            :  *    is deterministic.
<span class="lineNum">     115 </span>            :  * l: Allow command while loading the database.
<span class="lineNum">     116 </span>            :  * t: Allow command while a slave has stale data but is not allowed to
<span class="lineNum">     117 </span>            :  *    server this data. Normally no command is accepted in this condition
<span class="lineNum">     118 </span>            :  *    but just a few.
<span class="lineNum">     119 </span>            :  * M: Do not automatically propagate the command on MONITOR.
<span class="lineNum">     120 </span>            :  * k: Perform an implicit ASKING for this command, so the command will be
<span class="lineNum">     121 </span>            :  *    accepted in cluster mode if the slot is marked as 'importing'.
<span class="lineNum">     122 </span>            :  * F: Fast command: O(1) or O(log(N)) command that should never delay
<span class="lineNum">     123 </span>            :  *    its execution as long as the kernel scheduler is giving us time.
<span class="lineNum">     124 </span>            :  *    Note that commands that may trigger a DEL as a side effect (like SET)
<span class="lineNum">     125 </span>            :  *    are not fast commands.
<span class="lineNum">     126 </span>            :  */
<span class="lineNum">     127 </span>            : struct redisCommand redisCommandTable[] = {
<span class="lineNum">     128 </span>            :     {&quot;module&quot;,moduleCommand,-2,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     129 </span>            :     {&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     130 </span>            :     {&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     131 </span>            :     {&quot;setnx&quot;,setnxCommand,3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     132 </span>            :     {&quot;setex&quot;,setexCommand,4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     133 </span>            :     {&quot;psetex&quot;,psetexCommand,4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     134 </span>            :     {&quot;append&quot;,appendCommand,3,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     135 </span>            :     {&quot;strlen&quot;,strlenCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     136 </span>            :     {&quot;del&quot;,delCommand,-2,&quot;w&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     137 </span>            :     {&quot;unlink&quot;,unlinkCommand,-2,&quot;wF&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     138 </span>            :     {&quot;exists&quot;,existsCommand,-2,&quot;rF&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     139 </span>            :     {&quot;setbit&quot;,setbitCommand,4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     140 </span>            :     {&quot;getbit&quot;,getbitCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     141 </span>            :     {&quot;bitfield&quot;,bitfieldCommand,-2,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     142 </span>            :     {&quot;setrange&quot;,setrangeCommand,4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     143 </span>            :     {&quot;getrange&quot;,getrangeCommand,4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     144 </span>            :     {&quot;substr&quot;,getrangeCommand,4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     145 </span>            :     {&quot;incr&quot;,incrCommand,2,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     146 </span>            :     {&quot;decr&quot;,decrCommand,2,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     147 </span>            :     {&quot;mget&quot;,mgetCommand,-2,&quot;rF&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     148 </span>            :     {&quot;rpush&quot;,rpushCommand,-3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     149 </span>            :     {&quot;lpush&quot;,lpushCommand,-3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     150 </span>            :     {&quot;rpushx&quot;,rpushxCommand,-3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     151 </span>            :     {&quot;lpushx&quot;,lpushxCommand,-3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     152 </span>            :     {&quot;linsert&quot;,linsertCommand,5,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     153 </span>            :     {&quot;rpop&quot;,rpopCommand,2,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     154 </span>            :     {&quot;lpop&quot;,lpopCommand,2,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     155 </span>            :     {&quot;brpop&quot;,brpopCommand,-3,&quot;ws&quot;,0,NULL,1,-2,1,0,0},
<span class="lineNum">     156 </span>            :     {&quot;brpoplpush&quot;,brpoplpushCommand,4,&quot;wms&quot;,0,NULL,1,2,1,0,0},
<span class="lineNum">     157 </span>            :     {&quot;blpop&quot;,blpopCommand,-3,&quot;ws&quot;,0,NULL,1,-2,1,0,0},
<span class="lineNum">     158 </span>            :     {&quot;llen&quot;,llenCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     159 </span>            :     {&quot;lindex&quot;,lindexCommand,3,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     160 </span>            :     {&quot;lset&quot;,lsetCommand,4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     161 </span>            :     {&quot;lrange&quot;,lrangeCommand,4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     162 </span>            :     {&quot;ltrim&quot;,ltrimCommand,4,&quot;w&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     163 </span>            :     {&quot;lrem&quot;,lremCommand,4,&quot;w&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     164 </span>            :     {&quot;rpoplpush&quot;,rpoplpushCommand,3,&quot;wm&quot;,0,NULL,1,2,1,0,0},
<span class="lineNum">     165 </span>            :     {&quot;sadd&quot;,saddCommand,-3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     166 </span>            :     {&quot;srem&quot;,sremCommand,-3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     167 </span>            :     {&quot;smove&quot;,smoveCommand,4,&quot;wF&quot;,0,NULL,1,2,1,0,0},
<span class="lineNum">     168 </span>            :     {&quot;sismember&quot;,sismemberCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     169 </span>            :     {&quot;scard&quot;,scardCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     170 </span>            :     {&quot;spop&quot;,spopCommand,-2,&quot;wRF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     171 </span>            :     {&quot;srandmember&quot;,srandmemberCommand,-2,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     172 </span>            :     {&quot;sinter&quot;,sinterCommand,-2,&quot;rS&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     173 </span>            :     {&quot;sinterstore&quot;,sinterstoreCommand,-3,&quot;wm&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     174 </span>            :     {&quot;sunion&quot;,sunionCommand,-2,&quot;rS&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     175 </span>            :     {&quot;sunionstore&quot;,sunionstoreCommand,-3,&quot;wm&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     176 </span>            :     {&quot;sdiff&quot;,sdiffCommand,-2,&quot;rS&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     177 </span>            :     {&quot;sdiffstore&quot;,sdiffstoreCommand,-3,&quot;wm&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     178 </span>            :     {&quot;smembers&quot;,sinterCommand,2,&quot;rS&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     179 </span>            :     {&quot;sscan&quot;,sscanCommand,-3,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     180 </span>            :     {&quot;zadd&quot;,zaddCommand,-4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     181 </span>            :     {&quot;zincrby&quot;,zincrbyCommand,4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     182 </span>            :     {&quot;zrem&quot;,zremCommand,-3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     183 </span>            :     {&quot;zremrangebyscore&quot;,zremrangebyscoreCommand,4,&quot;w&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     184 </span>            :     {&quot;zremrangebyrank&quot;,zremrangebyrankCommand,4,&quot;w&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     185 </span>            :     {&quot;zremrangebylex&quot;,zremrangebylexCommand,4,&quot;w&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     186 </span>            :     {&quot;zunionstore&quot;,zunionstoreCommand,-4,&quot;wm&quot;,0,zunionInterGetKeys,0,0,0,0,0},
<span class="lineNum">     187 </span>            :     {&quot;zinterstore&quot;,zinterstoreCommand,-4,&quot;wm&quot;,0,zunionInterGetKeys,0,0,0,0,0},
<span class="lineNum">     188 </span>            :     {&quot;zrange&quot;,zrangeCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     189 </span>            :     {&quot;zrangebyscore&quot;,zrangebyscoreCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     190 </span>            :     {&quot;zrevrangebyscore&quot;,zrevrangebyscoreCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     191 </span>            :     {&quot;zrangebylex&quot;,zrangebylexCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     192 </span>            :     {&quot;zrevrangebylex&quot;,zrevrangebylexCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     193 </span>            :     {&quot;zcount&quot;,zcountCommand,4,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     194 </span>            :     {&quot;zlexcount&quot;,zlexcountCommand,4,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     195 </span>            :     {&quot;zrevrange&quot;,zrevrangeCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     196 </span>            :     {&quot;zcard&quot;,zcardCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     197 </span>            :     {&quot;zscore&quot;,zscoreCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     198 </span>            :     {&quot;zrank&quot;,zrankCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     199 </span>            :     {&quot;zrevrank&quot;,zrevrankCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     200 </span>            :     {&quot;zscan&quot;,zscanCommand,-3,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     201 </span>            :     {&quot;zpopmin&quot;,zpopminCommand,-2,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     202 </span>            :     {&quot;zpopmax&quot;,zpopmaxCommand,-2,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     203 </span>            :     {&quot;bzpopmin&quot;,bzpopminCommand,-2,&quot;wsF&quot;,0,NULL,1,-2,1,0,0},
<span class="lineNum">     204 </span>            :     {&quot;bzpopmax&quot;,bzpopmaxCommand,-2,&quot;wsF&quot;,0,NULL,1,-2,1,0,0},
<span class="lineNum">     205 </span>            :     {&quot;hset&quot;,hsetCommand,-4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     206 </span>            :     {&quot;hsetnx&quot;,hsetnxCommand,4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     207 </span>            :     {&quot;hget&quot;,hgetCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     208 </span>            :     {&quot;hmset&quot;,hsetCommand,-4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     209 </span>            :     {&quot;hmget&quot;,hmgetCommand,-3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     210 </span>            :     {&quot;hincrby&quot;,hincrbyCommand,4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     211 </span>            :     {&quot;hincrbyfloat&quot;,hincrbyfloatCommand,4,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     212 </span>            :     {&quot;hdel&quot;,hdelCommand,-3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     213 </span>            :     {&quot;hlen&quot;,hlenCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     214 </span>            :     {&quot;hstrlen&quot;,hstrlenCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     215 </span>            :     {&quot;hkeys&quot;,hkeysCommand,2,&quot;rS&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     216 </span>            :     {&quot;hvals&quot;,hvalsCommand,2,&quot;rS&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     217 </span>            :     {&quot;hgetall&quot;,hgetallCommand,2,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     218 </span>            :     {&quot;hexists&quot;,hexistsCommand,3,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     219 </span>            :     {&quot;hscan&quot;,hscanCommand,-3,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     220 </span>            :     {&quot;incrby&quot;,incrbyCommand,3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     221 </span>            :     {&quot;decrby&quot;,decrbyCommand,3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     222 </span>            :     {&quot;incrbyfloat&quot;,incrbyfloatCommand,3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     223 </span>            :     {&quot;getset&quot;,getsetCommand,3,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     224 </span>            :     {&quot;mset&quot;,msetCommand,-3,&quot;wm&quot;,0,NULL,1,-1,2,0,0},
<span class="lineNum">     225 </span>            :     {&quot;msetnx&quot;,msetnxCommand,-3,&quot;wm&quot;,0,NULL,1,-1,2,0,0},
<span class="lineNum">     226 </span>            :     {&quot;randomkey&quot;,randomkeyCommand,1,&quot;rR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     227 </span>            :     {&quot;select&quot;,selectCommand,2,&quot;lF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     228 </span>            :     {&quot;swapdb&quot;,swapdbCommand,3,&quot;wF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     229 </span>            :     {&quot;move&quot;,moveCommand,3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     230 </span>            :     {&quot;rename&quot;,renameCommand,3,&quot;w&quot;,0,NULL,1,2,1,0,0},
<span class="lineNum">     231 </span>            :     {&quot;renamenx&quot;,renamenxCommand,3,&quot;wF&quot;,0,NULL,1,2,1,0,0},
<span class="lineNum">     232 </span>            :     {&quot;expire&quot;,expireCommand,3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     233 </span>            :     {&quot;expireat&quot;,expireatCommand,3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     234 </span>            :     {&quot;pexpire&quot;,pexpireCommand,3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     235 </span>            :     {&quot;pexpireat&quot;,pexpireatCommand,3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     236 </span>            :     {&quot;keys&quot;,keysCommand,2,&quot;rS&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     237 </span>            :     {&quot;scan&quot;,scanCommand,-2,&quot;rR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     238 </span>            :     {&quot;dbsize&quot;,dbsizeCommand,1,&quot;rF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     239 </span>            :     {&quot;auth&quot;,authCommand,2,&quot;sltF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     240 </span>            :     {&quot;ping&quot;,pingCommand,-1,&quot;tF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     241 </span>            :     {&quot;echo&quot;,echoCommand,2,&quot;F&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     242 </span>            :     {&quot;save&quot;,saveCommand,1,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     243 </span>            :     {&quot;bgsave&quot;,bgsaveCommand,-1,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     244 </span>            :     {&quot;bgrewriteaof&quot;,bgrewriteaofCommand,1,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     245 </span>            :     {&quot;shutdown&quot;,shutdownCommand,-1,&quot;aslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     246 </span>            :     {&quot;lastsave&quot;,lastsaveCommand,1,&quot;RF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     247 </span>            :     {&quot;type&quot;,typeCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     248 </span>            :     {&quot;multi&quot;,multiCommand,1,&quot;sF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     249 </span>            :     {&quot;exec&quot;,execCommand,1,&quot;sM&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     250 </span>            :     {&quot;discard&quot;,discardCommand,1,&quot;sF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     251 </span>            :     {&quot;sync&quot;,syncCommand,1,&quot;ars&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     252 </span>            :     {&quot;psync&quot;,syncCommand,3,&quot;ars&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     253 </span>            :     {&quot;replconf&quot;,replconfCommand,-1,&quot;aslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     254 </span>            :     {&quot;flushdb&quot;,flushdbCommand,-1,&quot;w&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     255 </span>            :     {&quot;flushall&quot;,flushallCommand,-1,&quot;w&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     256 </span>            :     {&quot;sort&quot;,sortCommand,-2,&quot;wm&quot;,0,sortGetKeys,1,1,1,0,0},
<span class="lineNum">     257 </span>            :     {&quot;info&quot;,infoCommand,-1,&quot;ltR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     258 </span>            :     {&quot;monitor&quot;,monitorCommand,1,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     259 </span>            :     {&quot;ttl&quot;,ttlCommand,2,&quot;rFR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     260 </span>            :     {&quot;touch&quot;,touchCommand,-2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     261 </span>            :     {&quot;pttl&quot;,pttlCommand,2,&quot;rFR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     262 </span>            :     {&quot;persist&quot;,persistCommand,2,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     263 </span>            :     {&quot;slaveof&quot;,replicaofCommand,3,&quot;ast&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     264 </span>            :     {&quot;replicaof&quot;,replicaofCommand,3,&quot;ast&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     265 </span>            :     {&quot;role&quot;,roleCommand,1,&quot;lst&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     266 </span>            :     {&quot;debug&quot;,debugCommand,-2,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     267 </span>            :     {&quot;config&quot;,configCommand,-2,&quot;last&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     268 </span>            :     {&quot;subscribe&quot;,subscribeCommand,-2,&quot;pslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     269 </span>            :     {&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;pslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     270 </span>            :     {&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;pslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     271 </span>            :     {&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;pslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     272 </span>            :     {&quot;publish&quot;,publishCommand,3,&quot;pltF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     273 </span>            :     {&quot;pubsub&quot;,pubsubCommand,-2,&quot;pltR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     274 </span>            :     {&quot;watch&quot;,watchCommand,-2,&quot;sF&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     275 </span>            :     {&quot;unwatch&quot;,unwatchCommand,1,&quot;sF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     276 </span>            :     {&quot;cluster&quot;,clusterCommand,-2,&quot;a&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     277 </span>            :     {&quot;restore&quot;,restoreCommand,-4,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     278 </span>            :     {&quot;restore-asking&quot;,restoreCommand,-4,&quot;wmk&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     279 </span>            :     {&quot;migrate&quot;,migrateCommand,-6,&quot;wR&quot;,0,migrateGetKeys,0,0,0,0,0},
<span class="lineNum">     280 </span>            :     {&quot;asking&quot;,askingCommand,1,&quot;F&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     281 </span>            :     {&quot;readonly&quot;,readonlyCommand,1,&quot;F&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     282 </span>            :     {&quot;readwrite&quot;,readwriteCommand,1,&quot;F&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     283 </span>            :     {&quot;dump&quot;,dumpCommand,2,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     284 </span>            :     {&quot;object&quot;,objectCommand,-2,&quot;rR&quot;,0,NULL,2,2,1,0,0},
<span class="lineNum">     285 </span>            :     {&quot;memory&quot;,memoryCommand,-2,&quot;rR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     286 </span>            :     {&quot;client&quot;,clientCommand,-2,&quot;as&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     287 </span>            :     {&quot;eval&quot;,evalCommand,-3,&quot;s&quot;,0,evalGetKeys,0,0,0,0,0},
<span class="lineNum">     288 </span>            :     {&quot;evalsha&quot;,evalShaCommand,-3,&quot;s&quot;,0,evalGetKeys,0,0,0,0,0},
<span class="lineNum">     289 </span>            :     {&quot;slowlog&quot;,slowlogCommand,-2,&quot;aR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     290 </span>            :     {&quot;script&quot;,scriptCommand,-2,&quot;s&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     291 </span>            :     {&quot;time&quot;,timeCommand,1,&quot;RF&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     292 </span>            :     {&quot;bitop&quot;,bitopCommand,-4,&quot;wm&quot;,0,NULL,2,-1,1,0,0},
<span class="lineNum">     293 </span>            :     {&quot;bitcount&quot;,bitcountCommand,-2,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     294 </span>            :     {&quot;bitpos&quot;,bitposCommand,-3,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     295 </span>            :     {&quot;wait&quot;,waitCommand,3,&quot;s&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     296 </span>            :     {&quot;command&quot;,commandCommand,0,&quot;ltR&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     297 </span>            :     {&quot;geoadd&quot;,geoaddCommand,-5,&quot;wm&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     298 </span>            :     {&quot;georadius&quot;,georadiusCommand,-6,&quot;w&quot;,0,georadiusGetKeys,1,1,1,0,0},
<span class="lineNum">     299 </span>            :     {&quot;georadius_ro&quot;,georadiusroCommand,-6,&quot;r&quot;,0,georadiusGetKeys,1,1,1,0,0},
<span class="lineNum">     300 </span>            :     {&quot;georadiusbymember&quot;,georadiusbymemberCommand,-5,&quot;w&quot;,0,georadiusGetKeys,1,1,1,0,0},
<span class="lineNum">     301 </span>            :     {&quot;georadiusbymember_ro&quot;,georadiusbymemberroCommand,-5,&quot;r&quot;,0,georadiusGetKeys,1,1,1,0,0},
<span class="lineNum">     302 </span>            :     {&quot;geohash&quot;,geohashCommand,-2,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     303 </span>            :     {&quot;geopos&quot;,geoposCommand,-2,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     304 </span>            :     {&quot;geodist&quot;,geodistCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     305 </span>            :     {&quot;pfselftest&quot;,pfselftestCommand,1,&quot;a&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     306 </span>            :     {&quot;pfadd&quot;,pfaddCommand,-2,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     307 </span>            :     {&quot;pfcount&quot;,pfcountCommand,-2,&quot;r&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     308 </span>            :     {&quot;pfmerge&quot;,pfmergeCommand,-2,&quot;wm&quot;,0,NULL,1,-1,1,0,0},
<span class="lineNum">     309 </span>            :     {&quot;pfdebug&quot;,pfdebugCommand,-3,&quot;w&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     310 </span>            :     {&quot;xadd&quot;,xaddCommand,-5,&quot;wmFR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     311 </span>            :     {&quot;xrange&quot;,xrangeCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     312 </span>            :     {&quot;xrevrange&quot;,xrevrangeCommand,-4,&quot;r&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     313 </span>            :     {&quot;xlen&quot;,xlenCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     314 </span>            :     {&quot;xread&quot;,xreadCommand,-4,&quot;rs&quot;,0,xreadGetKeys,1,1,1,0,0},
<span class="lineNum">     315 </span>            :     {&quot;xreadgroup&quot;,xreadCommand,-7,&quot;ws&quot;,0,xreadGetKeys,1,1,1,0,0},
<span class="lineNum">     316 </span>            :     {&quot;xgroup&quot;,xgroupCommand,-2,&quot;wm&quot;,0,NULL,2,2,1,0,0},
<span class="lineNum">     317 </span>            :     {&quot;xsetid&quot;,xsetidCommand,3,&quot;wmF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     318 </span>            :     {&quot;xack&quot;,xackCommand,-4,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     319 </span>            :     {&quot;xpending&quot;,xpendingCommand,-3,&quot;rR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     320 </span>            :     {&quot;xclaim&quot;,xclaimCommand,-6,&quot;wRF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     321 </span>            :     {&quot;xinfo&quot;,xinfoCommand,-2,&quot;rR&quot;,0,NULL,2,2,1,0,0},
<span class="lineNum">     322 </span>            :     {&quot;xdel&quot;,xdelCommand,-3,&quot;wF&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     323 </span>            :     {&quot;xtrim&quot;,xtrimCommand,-2,&quot;wFR&quot;,0,NULL,1,1,1,0,0},
<span class="lineNum">     324 </span>            :     {&quot;post&quot;,securityWarningCommand,-1,&quot;lt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     325 </span>            :     {&quot;host:&quot;,securityWarningCommand,-1,&quot;lt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     326 </span>            :     {&quot;latency&quot;,latencyCommand,-2,&quot;aslt&quot;,0,NULL,0,0,0,0,0},
<span class="lineNum">     327 </span>            :     {&quot;lolwut&quot;,lolwutCommand,-1,&quot;r&quot;,0,NULL,0,0,0,0,0}
<span class="lineNum">     328 </span>            : };
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /*============================ Utility functions ============================ */
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : /* We use a private localtime implementation which is fork-safe. The logging
<span class="lineNum">     333 </span>            :  * function of Redis may be called from other threads. */
<span class="lineNum">     334 </span>            : void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);
<span class="lineNum">     335 </span>            : 
<a name="336"><span class="lineNum">     336 </span>            : /* Low level logging. To use only for very big messages, otherwise</a>
<span class="lineNum">     337 </span>            :  * serverLog() is to prefer. */
<span class="lineNum">     338 </span><span class="lineCov">     117566 : void serverLogRaw(int level, const char *msg) {</span>
<span class="lineNum">     339 </span><span class="lineCov">     117566 :     const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };</span>
<span class="lineNum">     340 </span><span class="lineCov">     117566 :     const char *c = &quot;.-*#&quot;;</span>
<span class="lineNum">     341 </span><span class="lineCov">     117566 :     FILE *fp;</span>
<span class="lineNum">     342 </span><span class="lineCov">     117566 :     char buf[64];</span>
<span class="lineNum">     343 </span><span class="lineCov">     117566 :     int rawmode = (level &amp; LL_RAW);</span>
<span class="lineNum">     344 </span><span class="lineCov">     117566 :     int log_to_stdout = server.logfile[0] == '\0';</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">     117566 :     level &amp;= 0xff; /* clear flags */</span>
<span class="lineNum">     347 </span><span class="lineCov">     117566 :     if (level &lt; server.verbosity) return;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">     117566 :     fp = log_to_stdout ? stdout : fopen(server.logfile,&quot;a&quot;);</span>
<span class="lineNum">     350 </span><span class="lineCov">     117566 :     if (!fp) return;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">     117566 :     if (rawmode) {</span>
<span class="lineNum">     353 </span><span class="lineCov">        656 :         fprintf(fp,&quot;%s&quot;,msg);</span>
<span class="lineNum">     354 </span>            :     } else {
<span class="lineNum">     355 </span><span class="lineCov">     116910 :         int off;</span>
<span class="lineNum">     356 </span><span class="lineCov">     116910 :         struct timeval tv;</span>
<span class="lineNum">     357 </span><span class="lineCov">     116910 :         int role_char;</span>
<span class="lineNum">     358 </span><span class="lineCov">     116910 :         pid_t pid = getpid();</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span><span class="lineCov">     116910 :         gettimeofday(&amp;tv,NULL);</span>
<span class="lineNum">     361 </span><span class="lineCov">     116910 :         struct tm tm;</span>
<span class="lineNum">     362 </span><span class="lineCov">     116910 :         nolocks_localtime(&amp;tm,tv.tv_sec,server.timezone,server.daylight_active);</span>
<span class="lineNum">     363 </span><span class="lineCov">     116910 :         off = strftime(buf,sizeof(buf),&quot;%d %b %Y %H:%M:%S.&quot;,&amp;tm);</span>
<span class="lineNum">     364 </span><span class="lineCov">     116910 :         snprintf(buf+off,sizeof(buf)-off,&quot;%03d&quot;,(int)tv.tv_usec/1000);</span>
<span class="lineNum">     365 </span><span class="lineCov">     116910 :         if (server.sentinel_mode) {</span>
<span class="lineNum">     366 </span>            :             role_char = 'X'; /* Sentinel. */
<span class="lineNum">     367 </span><span class="lineCov">     116910 :         } else if (pid != server.pid) {</span>
<span class="lineNum">     368 </span>            :             role_char = 'C'; /* RDB / AOF writing child. */
<span class="lineNum">     369 </span>            :         } else {
<span class="lineNum">     370 </span><span class="lineCov">     114349 :             role_char = (server.masterhost ? 'S':'M'); /* Slave or Master. */</span>
<span class="lineNum">     371 </span>            :         }
<span class="lineNum">     372 </span><span class="lineCov">     116910 :         fprintf(fp,&quot;%d:%c %s %c %s\n&quot;,</span>
<span class="lineNum">     373 </span><span class="lineCov">     116910 :             (int)getpid(),role_char, buf,c[level],msg);</span>
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span><span class="lineCov">     117566 :     fflush(fp);</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span><span class="lineCov">     117566 :     if (!log_to_stdout) fclose(fp);</span>
<span class="lineNum">     378 </span><span class="lineCov">     117566 :     if (server.syslog_enabled) syslog(syslogLevelMap[level], &quot;%s&quot;, msg);</span>
<span class="lineNum">     379 </span>            : }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : /* Like serverLogRaw() but with printf-alike support. This is the function that
<a name="382"><span class="lineNum">     382 </span>            :  * is used across the code. The raw version is only used in order to dump</a>
<span class="lineNum">     383 </span>            :  * the INFO output on crash. */
<span class="lineNum">     384 </span><span class="lineCov">     119230 : void serverLog(int level, const char *fmt, ...) {</span>
<span class="lineNum">     385 </span><span class="lineCov">     119230 :     va_list ap;</span>
<span class="lineNum">     386 </span><span class="lineCov">     119230 :     char msg[LOG_MAX_LEN];</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">     119230 :     if ((level&amp;0xff) &lt; server.verbosity) return;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineCov">     116910 :     va_start(ap, fmt);</span>
<span class="lineNum">     391 </span><span class="lineCov">     116910 :     vsnprintf(msg, sizeof(msg), fmt, ap);</span>
<span class="lineNum">     392 </span><span class="lineCov">     116910 :     va_end(ap);</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">     116910 :     serverLogRaw(level,msg);</span>
<span class="lineNum">     395 </span>            : }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : /* Log a fixed message without printf-alike capabilities, in a way that is
<span class="lineNum">     398 </span>            :  * safe to call from a signal handler.
<span class="lineNum">     399 </span>            :  *
<span class="lineNum">     400 </span>            :  * We actually use this only for signals that are not fatal from the point
<a name="401"><span class="lineNum">     401 </span>            :  * of view of Redis. Signals that are going to kill the server anyway and</a>
<span class="lineNum">     402 </span>            :  * where we need printf-alike features are served by serverLog(). */
<span class="lineNum">     403 </span><span class="lineCov">        415 : void serverLogFromHandler(int level, const char *msg) {</span>
<span class="lineNum">     404 </span><span class="lineCov">        415 :     int fd;</span>
<span class="lineNum">     405 </span><span class="lineCov">        415 :     int log_to_stdout = server.logfile[0] == '\0';</span>
<span class="lineNum">     406 </span><span class="lineCov">        415 :     char buf[64];</span>
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span><span class="lineCov">        415 :     if ((level&amp;0xff) &lt; server.verbosity || (log_to_stdout &amp;&amp; server.daemonize))</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">     410 </span><span class="lineCov">        415 :     fd = log_to_stdout ? STDOUT_FILENO :</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                          open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     if (fd == -1) return;</span>
<span class="lineNum">     413 </span><span class="lineCov">        415 :     ll2string(buf,sizeof(buf),getpid());</span>
<span class="lineNum">     414 </span><span class="lineCov">        415 :     if (write(fd,buf,strlen(buf)) == -1) goto err;</span>
<span class="lineNum">     415 </span><span class="lineCov">        415 :     if (write(fd,&quot;:signal-handler (&quot;,17) == -1) goto err;</span>
<span class="lineNum">     416 </span><span class="lineCov">        415 :     ll2string(buf,sizeof(buf),time(NULL));</span>
<span class="lineNum">     417 </span><span class="lineCov">        415 :     if (write(fd,buf,strlen(buf)) == -1) goto err;</span>
<span class="lineNum">     418 </span><span class="lineCov">        415 :     if (write(fd,&quot;) &quot;,2) == -1) goto err;</span>
<span class="lineNum">     419 </span><span class="lineCov">        415 :     if (write(fd,msg,strlen(msg)) == -1) goto err;</span>
<span class="lineNum">     420 </span><span class="lineCov">        415 :     if (write(fd,&quot;\n&quot;,1) == -1) goto err;</span>
<span class="lineNum">     421 </span><span class="lineCov">        415 : err:</span>
<span class="lineNum">     422 </span><span class="lineCov">        415 :     if (!log_to_stdout) close(fd);</span>
<span class="lineNum">     423 </span>            : }
<a name="424"><span class="lineNum">     424 </span>            : </a>
<span class="lineNum">     425 </span>            : /* Return the UNIX time in microseconds */
<span class="lineNum">     426 </span><span class="lineCov">   19802517 : long long ustime(void) {</span>
<span class="lineNum">     427 </span><span class="lineCov">  135907454 :     struct timeval tv;</span>
<span class="lineNum">     428 </span><span class="lineCov">  135907454 :     long long ust;</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">   19802517 :     gettimeofday(&amp;tv, NULL);</span>
<span class="lineNum">     431 </span><span class="lineCov">  135907454 :     ust = ((long long)tv.tv_sec)*1000000;</span>
<span class="lineNum">     432 </span><span class="lineCov">  135907454 :     ust += tv.tv_usec;</span>
<span class="lineNum">     433 </span><span class="lineCov">  135907454 :     return ust;</span>
<span class="lineNum">     434 </span>            : }
<a name="435"><span class="lineNum">     435 </span>            : </a>
<span class="lineNum">     436 </span>            : /* Return the UNIX time in milliseconds */
<span class="lineNum">     437 </span><span class="lineCov">    3169864 : mstime_t mstime(void) {</span>
<span class="lineNum">     438 </span><span class="lineCov">    3169864 :     return ustime()/1000;</span>
<span class="lineNum">     439 </span>            : }
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : /* After an RDB dump or AOF rewrite we exit from children using _exit() instead of
<span class="lineNum">     442 </span>            :  * exit(), because the latter may interact with the same file objects used by
<a name="443"><span class="lineNum">     443 </span>            :  * the parent process. However if we are testing the coverage normal exit() is</a>
<span class="lineNum">     444 </span>            :  * used in order to obtain the right coverage information. */
<span class="lineNum">     445 </span><span class="lineCov">        230 : void exitFromChild(int retcode) {</span>
<span class="lineNum">     446 </span>            : #ifdef COVERAGE_TEST
<span class="lineNum">     447 </span><span class="lineCov">        230 :     exit(retcode);</span>
<span class="lineNum">     448 </span>            : #else
<span class="lineNum">     449 </span>            :     _exit(retcode);
<span class="lineNum">     450 </span>            : #endif
<span class="lineNum">     451 </span>            : }
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            : /*====================== Hash table type implementation  ==================== */
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /* This is a hash table type that uses the SDS dynamic strings library as
<span class="lineNum">     456 </span>            :  * keys and redis objects as values (objects can hold SDS strings,
<a name="457"><span class="lineNum">     457 </span>            :  * lists, sets). */</a>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">        372 : void dictVanillaFree(void *privdata, void *val)</span>
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span><span class="lineCov">        372 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     462 </span><span class="lineCov">        372 :     zfree(val);</span>
<a name="463"><span class="lineNum">     463 </span><span class="lineCov">        372 : }</span></a>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineCov">        714 : void dictListDestructor(void *privdata, void *val)</span>
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span><span class="lineCov">        714 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     468 </span><span class="lineCov">        714 :     listRelease((list*)val);</span>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">        714 : }</span></a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">  147507357 : int dictSdsKeyCompare(void *privdata, const void *key1,</span>
<span class="lineNum">     472 </span>            :         const void *key2)
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineCov">  147507357 :     int l1,l2;</span>
<span class="lineNum">     475 </span><span class="lineCov">  147507357 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineCov">  147507357 :     l1 = sdslen((sds)key1);</span>
<span class="lineNum">     478 </span><span class="lineCov">  147507357 :     l2 = sdslen((sds)key2);</span>
<span class="lineNum">     479 </span><span class="lineCov">  147507357 :     if (l1 != l2) return 0;</span>
<span class="lineNum">     480 </span><span class="lineCov">  105015465 :     return memcmp(key1, key2, l1) == 0;</span>
<span class="lineNum">     481 </span>            : }
<span class="lineNum">     482 </span>            : 
<a name="483"><span class="lineNum">     483 </span>            : /* A case insensitive version used for the command lookup table and other</a>
<span class="lineNum">     484 </span>            :  * places where case insensitive non binary-safe comparison is needed. */
<span class="lineNum">     485 </span><span class="lineCov">   91905942 : int dictSdsKeyCaseCompare(void *privdata, const void *key1,</span>
<span class="lineNum">     486 </span>            :         const void *key2)
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span><span class="lineCov">   91905942 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">   91905942 :     return strcasecmp(key1, key2) == 0;</span>
<a name="491"><span class="lineNum">     491 </span>            : }</a>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineCov">   20350786 : void dictObjectDestructor(void *privdata, void *val)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineCov">   20350786 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineCov">   20350786 :     if (val == NULL) return; /* Lazy freeing will set value to NULL. */</span>
<span class="lineNum">     498 </span><span class="lineCov">   20350784 :     decrRefCount(val);</span>
<a name="499"><span class="lineNum">     499 </span>            : }</a>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span><span class="lineCov">   13446102 : void dictSdsDestructor(void *privdata, void *val)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineCov">   13446102 :     DICT_NOTUSED(privdata);</span>
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span><span class="lineCov">   13446102 :     sdsfree(val);</span>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">   13446102 : }</span></a>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineCov">     838453 : int dictObjKeyCompare(void *privdata, const void *key1,</span>
<span class="lineNum">     509 </span>            :         const void *key2)
<span class="lineNum">     510 </span>            : {
<span class="lineNum">     511 </span><span class="lineCov">     838453 :     const robj *o1 = key1, *o2 = key2;</span>
<span class="lineNum">     512 </span><span class="lineCov">     838453 :     return dictSdsKeyCompare(privdata,o1-&gt;ptr,o2-&gt;ptr);</span>
<a name="513"><span class="lineNum">     513 </span>            : }</a>
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span><span class="lineCov">     840638 : uint64_t dictObjHash(const void *key) {</span>
<span class="lineNum">     516 </span><span class="lineCov">     840638 :     const robj *o = key;</span>
<span class="lineNum">     517 </span><span class="lineCov">    1681276 :     return dictGenHashFunction(o-&gt;ptr, sdslen((sds)o-&gt;ptr));</span>
<a name="518"><span class="lineNum">     518 </span>            : }</a>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineCov">  215775745 : uint64_t dictSdsHash(const void *key) {</span>
<span class="lineNum">     521 </span><span class="lineCov">  431551490 :     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));</span>
<a name="522"><span class="lineNum">     522 </span>            : }</a>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">   65224971 : uint64_t dictSdsCaseHash(const void *key) {</span>
<span class="lineNum">     525 </span><span class="lineCov">  130449942 :     return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));</span>
<a name="526"><span class="lineNum">     526 </span>            : }</a>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineCov">        462 : int dictEncObjKeyCompare(void *privdata, const void *key1,</span>
<span class="lineNum">     529 </span>            :         const void *key2)
<span class="lineNum">     530 </span>            : {
<span class="lineNum">     531 </span><span class="lineCov">        462 :     robj *o1 = (robj*) key1, *o2 = (robj*) key2;</span>
<span class="lineNum">     532 </span><span class="lineCov">        462 :     int cmp;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span><span class="lineCov">        462 :     if (o1-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span>
<span class="lineNum">     535 </span><span class="lineCov">        166 :         o2-&gt;encoding == OBJ_ENCODING_INT)</span>
<span class="lineNum">     536 </span><span class="lineCov">        166 :             return o1-&gt;ptr == o2-&gt;ptr;</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">        296 :     o1 = getDecodedObject(o1);</span>
<span class="lineNum">     539 </span><span class="lineCov">        296 :     o2 = getDecodedObject(o2);</span>
<span class="lineNum">     540 </span><span class="lineCov">        296 :     cmp = dictSdsKeyCompare(privdata,o1-&gt;ptr,o2-&gt;ptr);</span>
<span class="lineNum">     541 </span><span class="lineCov">        296 :     decrRefCount(o1);</span>
<span class="lineNum">     542 </span><span class="lineCov">        296 :     decrRefCount(o2);</span>
<span class="lineNum">     543 </span><span class="lineCov">        296 :     return cmp;</span>
<a name="544"><span class="lineNum">     544 </span>            : }</a>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineCov">       1585 : uint64_t dictEncObjHash(const void *key) {</span>
<span class="lineNum">     547 </span><span class="lineCov">       1585 :     robj *o = (robj*) key;</span>
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">       1585 :     if (sdsEncodedObject(o)) {</span>
<span class="lineNum">     550 </span><span class="lineCov">       2450 :         return dictGenHashFunction(o-&gt;ptr, sdslen((sds)o-&gt;ptr));</span>
<span class="lineNum">     551 </span>            :     } else {
<span class="lineNum">     552 </span><span class="lineCov">        360 :         if (o-&gt;encoding == OBJ_ENCODING_INT) {</span>
<span class="lineNum">     553 </span><span class="lineCov">        360 :             char buf[32];</span>
<span class="lineNum">     554 </span><span class="lineCov">        360 :             int len;</span>
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineCov">        360 :             len = ll2string(buf,32,(long)o-&gt;ptr);</span>
<span class="lineNum">     557 </span><span class="lineCov">        360 :             return dictGenHashFunction((unsigned char*)buf, len);</span>
<span class="lineNum">     558 </span>            :         } else {
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :             uint64_t hash;</span>
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :             o = getDecodedObject(o);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :             hash = dictGenHashFunction(o-&gt;ptr, sdslen((sds)o-&gt;ptr));</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :             decrRefCount(o);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :             return hash;</span>
<span class="lineNum">     565 </span>            :         }
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span>            : }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : /* Generic hash table type where keys are Redis Objects, Values
<span class="lineNum">     570 </span>            :  * dummy pointers. */
<span class="lineNum">     571 </span>            : dictType objectKeyPointerValueDictType = {
<span class="lineNum">     572 </span>            :     dictEncObjHash,            /* hash function */
<span class="lineNum">     573 </span>            :     NULL,                      /* key dup */
<span class="lineNum">     574 </span>            :     NULL,                      /* val dup */
<span class="lineNum">     575 </span>            :     dictEncObjKeyCompare,      /* key compare */
<span class="lineNum">     576 </span>            :     dictObjectDestructor,      /* key destructor */
<span class="lineNum">     577 </span>            :     NULL                       /* val destructor */
<span class="lineNum">     578 </span>            : };
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : /* Like objectKeyPointerValueDictType(), but values can be destroyed, if
<span class="lineNum">     581 </span>            :  * not NULL, calling zfree(). */
<span class="lineNum">     582 </span>            : dictType objectKeyHeapPointerValueDictType = {
<span class="lineNum">     583 </span>            :     dictEncObjHash,            /* hash function */
<span class="lineNum">     584 </span>            :     NULL,                      /* key dup */
<span class="lineNum">     585 </span>            :     NULL,                      /* val dup */
<span class="lineNum">     586 </span>            :     dictEncObjKeyCompare,      /* key compare */
<span class="lineNum">     587 </span>            :     dictObjectDestructor,      /* key destructor */
<span class="lineNum">     588 </span>            :     dictVanillaFree            /* val destructor */
<span class="lineNum">     589 </span>            : };
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /* Set dictionary type. Keys are SDS strings, values are ot used. */
<span class="lineNum">     592 </span>            : dictType setDictType = {
<span class="lineNum">     593 </span>            :     dictSdsHash,               /* hash function */
<span class="lineNum">     594 </span>            :     NULL,                      /* key dup */
<span class="lineNum">     595 </span>            :     NULL,                      /* val dup */
<span class="lineNum">     596 </span>            :     dictSdsKeyCompare,         /* key compare */
<span class="lineNum">     597 </span>            :     dictSdsDestructor,         /* key destructor */
<span class="lineNum">     598 </span>            :     NULL                       /* val destructor */
<span class="lineNum">     599 </span>            : };
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            : /* Sorted sets hash (note: a skiplist is used in addition to the hash table) */
<span class="lineNum">     602 </span>            : dictType zsetDictType = {
<span class="lineNum">     603 </span>            :     dictSdsHash,               /* hash function */
<span class="lineNum">     604 </span>            :     NULL,                      /* key dup */
<span class="lineNum">     605 </span>            :     NULL,                      /* val dup */
<span class="lineNum">     606 </span>            :     dictSdsKeyCompare,         /* key compare */
<span class="lineNum">     607 </span>            :     NULL,                      /* Note: SDS string shared &amp; freed by skiplist */
<span class="lineNum">     608 </span>            :     NULL                       /* val destructor */
<span class="lineNum">     609 </span>            : };
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : /* Db-&gt;dict, keys are sds strings, vals are Redis objects. */
<span class="lineNum">     612 </span>            : dictType dbDictType = {
<span class="lineNum">     613 </span>            :     dictSdsHash,                /* hash function */
<span class="lineNum">     614 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     615 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     616 </span>            :     dictSdsKeyCompare,          /* key compare */
<span class="lineNum">     617 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     618 </span>            :     dictObjectDestructor   /* val destructor */
<span class="lineNum">     619 </span>            : };
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : /* server.lua_scripts sha (as sds string) -&gt; scripts (as robj) cache. */
<span class="lineNum">     622 </span>            : dictType shaScriptObjectDictType = {
<span class="lineNum">     623 </span>            :     dictSdsCaseHash,            /* hash function */
<span class="lineNum">     624 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     625 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     626 </span>            :     dictSdsKeyCaseCompare,      /* key compare */
<span class="lineNum">     627 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     628 </span>            :     dictObjectDestructor        /* val destructor */
<span class="lineNum">     629 </span>            : };
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span>            : /* Db-&gt;expires */
<span class="lineNum">     632 </span>            : dictType keyptrDictType = {
<span class="lineNum">     633 </span>            :     dictSdsHash,                /* hash function */
<span class="lineNum">     634 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     635 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     636 </span>            :     dictSdsKeyCompare,          /* key compare */
<span class="lineNum">     637 </span>            :     NULL,                       /* key destructor */
<span class="lineNum">     638 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     639 </span>            : };
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            : /* Command table. sds string -&gt; command struct pointer. */
<span class="lineNum">     642 </span>            : dictType commandTableDictType = {
<span class="lineNum">     643 </span>            :     dictSdsCaseHash,            /* hash function */
<span class="lineNum">     644 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     645 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     646 </span>            :     dictSdsKeyCaseCompare,      /* key compare */
<span class="lineNum">     647 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     648 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     649 </span>            : };
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : /* Hash type hash table (note that small hashes are represented with ziplists) */
<span class="lineNum">     652 </span>            : dictType hashDictType = {
<span class="lineNum">     653 </span>            :     dictSdsHash,                /* hash function */
<span class="lineNum">     654 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     655 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     656 </span>            :     dictSdsKeyCompare,          /* key compare */
<span class="lineNum">     657 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     658 </span>            :     dictSdsDestructor           /* val destructor */
<span class="lineNum">     659 </span>            : };
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : /* Keylist hash table type has unencoded redis objects as keys and
<span class="lineNum">     662 </span>            :  * lists as values. It's used for blocking operations (BLPOP) and to
<span class="lineNum">     663 </span>            :  * map swapped keys to a list of clients waiting for this keys to be loaded. */
<span class="lineNum">     664 </span>            : dictType keylistDictType = {
<span class="lineNum">     665 </span>            :     dictObjHash,                /* hash function */
<span class="lineNum">     666 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     667 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     668 </span>            :     dictObjKeyCompare,          /* key compare */
<span class="lineNum">     669 </span>            :     dictObjectDestructor,       /* key destructor */
<span class="lineNum">     670 </span>            :     dictListDestructor          /* val destructor */
<span class="lineNum">     671 </span>            : };
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : /* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to
<span class="lineNum">     674 </span>            :  * clusterNode structures. */
<span class="lineNum">     675 </span>            : dictType clusterNodesDictType = {
<span class="lineNum">     676 </span>            :     dictSdsHash,                /* hash function */
<span class="lineNum">     677 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     678 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     679 </span>            :     dictSdsKeyCompare,          /* key compare */
<span class="lineNum">     680 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     681 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     682 </span>            : };
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : /* Cluster re-addition blacklist. This maps node IDs to the time
<span class="lineNum">     685 </span>            :  * we can re-add this node. The goal is to avoid readding a removed
<span class="lineNum">     686 </span>            :  * node for some time. */
<span class="lineNum">     687 </span>            : dictType clusterNodesBlackListDictType = {
<span class="lineNum">     688 </span>            :     dictSdsCaseHash,            /* hash function */
<span class="lineNum">     689 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     690 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     691 </span>            :     dictSdsKeyCaseCompare,      /* key compare */
<span class="lineNum">     692 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     693 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     694 </span>            : };
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            : /* Cluster re-addition blacklist. This maps node IDs to the time
<span class="lineNum">     697 </span>            :  * we can re-add this node. The goal is to avoid readding a removed
<span class="lineNum">     698 </span>            :  * node for some time. */
<span class="lineNum">     699 </span>            : dictType modulesDictType = {
<span class="lineNum">     700 </span>            :     dictSdsCaseHash,            /* hash function */
<span class="lineNum">     701 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     702 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     703 </span>            :     dictSdsKeyCaseCompare,      /* key compare */
<span class="lineNum">     704 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     705 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     706 </span>            : };
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : /* Migrate cache dict type. */
<span class="lineNum">     709 </span>            : dictType migrateCacheDictType = {
<span class="lineNum">     710 </span>            :     dictSdsHash,                /* hash function */
<span class="lineNum">     711 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     712 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     713 </span>            :     dictSdsKeyCompare,          /* key compare */
<span class="lineNum">     714 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     715 </span>            :     NULL                        /* val destructor */
<span class="lineNum">     716 </span>            : };
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            : /* Replication cached script dict (server.repl_scriptcache_dict).
<span class="lineNum">     719 </span>            :  * Keys are sds SHA1 strings, while values are not used at all in the current
<span class="lineNum">     720 </span>            :  * implementation. */
<span class="lineNum">     721 </span>            : dictType replScriptCacheDictType = {
<span class="lineNum">     722 </span>            :     dictSdsCaseHash,            /* hash function */
<span class="lineNum">     723 </span>            :     NULL,                       /* key dup */
<span class="lineNum">     724 </span>            :     NULL,                       /* val dup */
<span class="lineNum">     725 </span>            :     dictSdsKeyCaseCompare,      /* key compare */
<span class="lineNum">     726 </span>            :     dictSdsDestructor,          /* key destructor */
<span class="lineNum">     727 </span>            :     NULL                        /* val destructor */
<a name="728"><span class="lineNum">     728 </span>            : };</a>
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span><span class="lineCov">     291455 : int htNeedsResize(dict *dict) {</span>
<span class="lineNum">     731 </span><span class="lineCov">    1603839 :     long long size, used;</span>
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span><span class="lineCov">    1603839 :     size = dictSlots(dict);</span>
<span class="lineNum">     734 </span><span class="lineCov">    1603839 :     used = dictSize(dict);</span>
<span class="lineNum">     735 </span><span class="lineCov">     291455 :     return (size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span>
<span class="lineNum">     736 </span><span class="lineCov">     190633 :             (used*100/size &lt; HASHTABLE_MIN_FILL));</span>
<span class="lineNum">     737 </span>            : }
<span class="lineNum">     738 </span>            : 
<a name="739"><span class="lineNum">     739 </span>            : /* If the percentage of used slots in the HT reaches HASHTABLE_MIN_FILL</a>
<span class="lineNum">     740 </span>            :  * we resize the hash table to save memory */
<span class="lineNum">     741 </span><span class="lineCov">     656192 : void tryResizeHashTables(int dbid) {</span>
<span class="lineNum">     742 </span><span class="lineCov">     656192 :     if (htNeedsResize(server.db[dbid].dict))</span>
<span class="lineNum">     743 </span><span class="lineCov">          3 :         dictResize(server.db[dbid].dict);</span>
<span class="lineNum">     744 </span><span class="lineCov">     656192 :     if (htNeedsResize(server.db[dbid].expires))</span>
<span class="lineNum">     745 </span><span class="lineCov">          6 :         dictResize(server.db[dbid].expires);</span>
<span class="lineNum">     746 </span><span class="lineCov">     656192 : }</span>
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : /* Our hash table implementation performs rehashing incrementally while
<span class="lineNum">     749 </span>            :  * we write/read from the hash table. Still if the server is idle, the hash
<span class="lineNum">     750 </span>            :  * table will use two tables for a long time. So we try to use 1 millisecond
<span class="lineNum">     751 </span>            :  * of CPU time at every call of this function to perform some rehahsing.
<span class="lineNum">     752 </span>            :  *
<a name="753"><span class="lineNum">     753 </span>            :  * The function returns 1 if some rehashing was performed, otherwise 0</a>
<span class="lineNum">     754 </span>            :  * is returned. */
<span class="lineNum">     755 </span><span class="lineCov">     628752 : int incrementallyRehash(int dbid) {</span>
<span class="lineNum">     756 </span>            :     /* Keys dictionary */
<span class="lineNum">     757 </span><span class="lineCov">     628752 :     if (dictIsRehashing(server.db[dbid].dict)) {</span>
<span class="lineNum">     758 </span><span class="lineCov">       2119 :         dictRehashMilliseconds(server.db[dbid].dict,1);</span>
<span class="lineNum">     759 </span><span class="lineCov">       2119 :         return 1; /* already used our millisecond for this loop... */</span>
<span class="lineNum">     760 </span>            :     }
<span class="lineNum">     761 </span>            :     /* Expires */
<span class="lineNum">     762 </span><span class="lineCov">     626633 :     if (dictIsRehashing(server.db[dbid].expires)) {</span>
<span class="lineNum">     763 </span><span class="lineCov">          8 :         dictRehashMilliseconds(server.db[dbid].expires,1);</span>
<span class="lineNum">     764 </span><span class="lineCov">          8 :         return 1; /* already used our millisecond for this loop... */</span>
<span class="lineNum">     765 </span>            :     }
<span class="lineNum">     766 </span>            :     return 0;
<span class="lineNum">     767 </span>            : }
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            : /* This function is called once a background process of some kind terminates,
<span class="lineNum">     770 </span>            :  * as we want to avoid resizing the hash tables when there is a child in order
<span class="lineNum">     771 </span>            :  * to play well with copy-on-write (otherwise when a resize happens lots of
<span class="lineNum">     772 </span>            :  * memory pages are copied). The goal of this function is to update the ability
<a name="773"><span class="lineNum">     773 </span>            :  * for dict.c to resize the hash tables accordingly to the fact we have o not</a>
<span class="lineNum">     774 </span>            :  * running childs. */
<span class="lineNum">     775 </span><span class="lineCov">       1536 : void updateDictResizePolicy(void) {</span>
<span class="lineNum">     776 </span><span class="lineCov">       1536 :     if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1)</span>
<span class="lineNum">     777 </span><span class="lineCov">        741 :         dictEnableResize();</span>
<span class="lineNum">     778 </span>            :     else
<span class="lineNum">     779 </span><span class="lineCov">        795 :         dictDisableResize();</span>
<span class="lineNum">     780 </span><span class="lineCov">       1536 : }</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : /* ======================= Cron: called every 100 ms ======================== */
<a name="783"><span class="lineNum">     783 </span>            : </a>
<span class="lineNum">     784 </span>            : /* Add a sample to the operations per second array of samples. */
<span class="lineNum">     785 </span><span class="lineCov">     128766 : void trackInstantaneousMetric(int metric, long long current_reading) {</span>
<span class="lineNum">     786 </span><span class="lineCov">     128766 :     long long t = mstime() - server.inst_metric[metric].last_sample_time;</span>
<span class="lineNum">     787 </span><span class="lineCov">     257532 :     long long ops = current_reading -</span>
<span class="lineNum">     788 </span><span class="lineCov">     128766 :                     server.inst_metric[metric].last_sample_count;</span>
<span class="lineNum">     789 </span><span class="lineCov">     128766 :     long long ops_sec;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span><span class="lineCov">     128766 :     ops_sec = t &gt; 0 ? (ops*1000/t) : 0;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineCov">     128766 :     server.inst_metric[metric].samples[server.inst_metric[metric].idx] =</span>
<span class="lineNum">     794 </span>            :         ops_sec;
<span class="lineNum">     795 </span><span class="lineCov">     128766 :     server.inst_metric[metric].idx++;</span>
<span class="lineNum">     796 </span><span class="lineCov">     128766 :     server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;</span>
<span class="lineNum">     797 </span><span class="lineCov">     128766 :     server.inst_metric[metric].last_sample_time = mstime();</span>
<span class="lineNum">     798 </span><span class="lineCov">     128766 :     server.inst_metric[metric].last_sample_count = current_reading;</span>
<span class="lineNum">     799 </span><span class="lineCov">     128766 : }</span>
<a name="800"><span class="lineNum">     800 </span>            : </a>
<span class="lineNum">     801 </span>            : /* Return the mean of all the samples. */
<span class="lineNum">     802 </span><span class="lineNoCov">          0 : long long getInstantaneousMetric(int metric) {</span>
<span class="lineNum">     803 </span><span class="lineCov">      30618 :     int j;</span>
<span class="lineNum">     804 </span><span class="lineCov">      30618 :     long long sum = 0;</span>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineCov">    1561518 :     for (j = 0; j &lt; STATS_METRIC_SAMPLES; j++)</span>
<span class="lineNum">     807 </span><span class="lineCov">    1469664 :         sum += server.inst_metric[metric].samples[j];</span>
<span class="lineNum">     808 </span><span class="lineCov">      91854 :     return sum / STATS_METRIC_SAMPLES;</span>
<span class="lineNum">     809 </span>            : }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : /* Check for timeouts. Returns non-zero if the client was terminated.
<span class="lineNum">     812 </span>            :  * The function gets the current time in milliseconds as argument since
<a name="813"><span class="lineNum">     813 </span>            :  * it gets called multiple times in a loop, so calling gettimeofday() for</a>
<span class="lineNum">     814 </span>            :  * each iteration would be costly without any actual gain. */
<span class="lineNum">     815 </span><span class="lineCov">      88967 : int clientsCronHandleTimeout(client *c, mstime_t now_ms) {</span>
<span class="lineNum">     816 </span><span class="lineCov">      88967 :     time_t now = now_ms/1000;</span>
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineCov">      88967 :     if (server.maxidletime &amp;&amp;</span>
<span class="lineNum">     819 </span>            :         !(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp;    /* no timeout for slaves */
<span class="lineNum">     820 </span>            :         !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;   /* no timeout for masters */
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         !(c-&gt;flags &amp; CLIENT_BLOCKED) &amp;&amp;  /* no timeout for BLPOP */</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :         !(c-&gt;flags &amp; CLIENT_PUBSUB) &amp;&amp;   /* no timeout for Pub/Sub clients */</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :         (now - c-&gt;lastinteraction &gt; server.maxidletime))</span>
<span class="lineNum">     824 </span>            :     {
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :         serverLog(LL_VERBOSE,&quot;Closing idle client&quot;);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :         freeClient(c);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">     828 </span><span class="lineCov">      88967 :     } else if (c-&gt;flags &amp; CLIENT_BLOCKED) {</span>
<span class="lineNum">     829 </span>            :         /* Blocked OPS timeout is handled with milliseconds resolution.
<span class="lineNum">     830 </span>            :          * However note that the actual resolution is limited by
<span class="lineNum">     831 </span>            :          * server.hz. */
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">       2595 :         if (c-&gt;bpop.timeout != 0 &amp;&amp; c-&gt;bpop.timeout &lt; now_ms) {</span>
<span class="lineNum">     834 </span>            :             /* Handle blocking operation specific timeout. */
<span class="lineNum">     835 </span><span class="lineCov">        121 :             replyToBlockedClientTimedOut(c);</span>
<span class="lineNum">     836 </span><span class="lineCov">        121 :             unblockClient(c);</span>
<span class="lineNum">     837 </span><span class="lineCov">       2474 :         } else if (server.cluster_enabled) {</span>
<span class="lineNum">     838 </span>            :             /* Cluster: handle unblock &amp; redirect of clients blocked
<span class="lineNum">     839 </span>            :              * into keys no longer served by this server. */
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :             if (clusterRedirectBlockedClientIfNeeded(c))</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                 unblockClient(c);</span>
<span class="lineNum">     842 </span>            :         }
<span class="lineNum">     843 </span>            :     }
<span class="lineNum">     844 </span>            :     return 0;
<span class="lineNum">     845 </span>            : }
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            : /* The client query buffer is an sds.c string that can end with a lot of
<span class="lineNum">     848 </span>            :  * free space not used, this function reclaims space if needed.
<a name="849"><span class="lineNum">     849 </span>            :  *</a>
<span class="lineNum">     850 </span>            :  * The function always returns 0 as it never terminates the client. */
<span class="lineNum">     851 </span><span class="lineCov">      88967 : int clientsCronResizeQueryBuffer(client *c) {</span>
<span class="lineNum">     852 </span><span class="lineCov">      88967 :     size_t querybuf_size = sdsAllocSize(c-&gt;querybuf);</span>
<span class="lineNum">     853 </span><span class="lineCov">      88967 :     time_t idletime = server.unixtime - c-&gt;lastinteraction;</span>
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :     /* There are two conditions to resize the query buffer:
<span class="lineNum">     856 </span>            :      * 1) Query buffer is &gt; BIG_ARG and too big for latest peak.
<span class="lineNum">     857 </span>            :      * 2) Query buffer is &gt; BIG_ARG and client is idle. */
<span class="lineNum">     858 </span><span class="lineCov">      88967 :     if (querybuf_size &gt; PROTO_MBULK_BIG_ARG &amp;&amp;</span>
<span class="lineNum">     859 </span><span class="lineCov">      41510 :          ((querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2 ||</span>
<span class="lineNum">     860 </span>            :           idletime &gt; 2))
<span class="lineNum">     861 </span>            :     {
<span class="lineNum">     862 </span>            :         /* Only resize the query buffer if it is actually wasting
<span class="lineNum">     863 </span>            :          * at least a few kbytes. */
<span class="lineNum">     864 </span><span class="lineCov">      40745 :         if (sdsavail(c-&gt;querybuf) &gt; 1024*4) {</span>
<span class="lineNum">     865 </span><span class="lineCov">      40745 :             c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);</span>
<span class="lineNum">     866 </span>            :         }
<span class="lineNum">     867 </span>            :     }
<span class="lineNum">     868 </span>            :     /* Reset the peak again to capture the peak memory usage in the next
<span class="lineNum">     869 </span>            :      * cycle. */
<span class="lineNum">     870 </span><span class="lineCov">      88967 :     c-&gt;querybuf_peak = 0;</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :     /* Clients representing masters also use a &quot;pending query buffer&quot; that
<span class="lineNum">     873 </span>            :      * is the yet not applied part of the stream we are reading. Such buffer
<span class="lineNum">     874 </span>            :      * also needs resizing from time to time, otherwise after a very large
<span class="lineNum">     875 </span>            :      * transfer (a huge value or a big MIGRATE operation) it will keep using
<span class="lineNum">     876 </span>            :      * a lot of memory. */
<span class="lineNum">     877 </span><span class="lineCov">      88967 :     if (c-&gt;flags &amp; CLIENT_MASTER) {</span>
<span class="lineNum">     878 </span>            :         /* There are two conditions to resize the pending query buffer:
<span class="lineNum">     879 </span>            :          * 1) Pending Query buffer is &gt; LIMIT_PENDING_QUERYBUF.
<span class="lineNum">     880 </span>            :          * 2) Used length is smaller than pending_querybuf_size/2 */
<span class="lineNum">     881 </span><span class="lineCov">       7523 :         size_t pending_querybuf_size = sdsAllocSize(c-&gt;pending_querybuf);</span>
<span class="lineNum">     882 </span><span class="lineCov">       7523 :         if(pending_querybuf_size &gt; LIMIT_PENDING_QUERYBUF &amp;&amp;</span>
<span class="lineNum">     883 </span><span class="lineCov">          4 :            sdslen(c-&gt;pending_querybuf) &lt; (pending_querybuf_size/2))</span>
<span class="lineNum">     884 </span>            :         {
<span class="lineNum">     885 </span><span class="lineCov">          2 :             c-&gt;pending_querybuf = sdsRemoveFreeSpace(c-&gt;pending_querybuf);</span>
<span class="lineNum">     886 </span>            :         }
<span class="lineNum">     887 </span>            :     }
<span class="lineNum">     888 </span><span class="lineCov">      88967 :     return 0;</span>
<span class="lineNum">     889 </span>            : }
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : /* This function is used in order to track clients using the biggest amount
<span class="lineNum">     892 </span>            :  * of memory in the latest few seconds. This way we can provide such information
<span class="lineNum">     893 </span>            :  * in the INFO output (clients section), without having to do an O(N) scan for
<span class="lineNum">     894 </span>            :  * all the clients.
<span class="lineNum">     895 </span>            :  *
<span class="lineNum">     896 </span>            :  * This is how it works. We have an array of CLIENTS_PEAK_MEM_USAGE_SLOTS slots
<span class="lineNum">     897 </span>            :  * where we track, for each, the biggest client output and input buffers we
<span class="lineNum">     898 </span>            :  * saw in that slot. Every slot correspond to one of the latest seconds, since
<span class="lineNum">     899 </span>            :  * the array is indexed by doing UNIXTIME % CLIENTS_PEAK_MEM_USAGE_SLOTS.
<span class="lineNum">     900 </span>            :  *
<span class="lineNum">     901 </span>            :  * When we want to know what was recently the peak memory usage, we just scan
<span class="lineNum">     902 </span>            :  * such few slots searching for the maximum value. */
<span class="lineNum">     903 </span>            : #define CLIENTS_PEAK_MEM_USAGE_SLOTS 8
<span class="lineNum">     904 </span>            : size_t ClientsPeakMemInput[CLIENTS_PEAK_MEM_USAGE_SLOTS];
<a name="905"><span class="lineNum">     905 </span>            : size_t ClientsPeakMemOutput[CLIENTS_PEAK_MEM_USAGE_SLOTS];</a>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">      88967 : int clientsCronTrackExpansiveClients(client *c) {</span>
<span class="lineNum">     908 </span><span class="lineCov">      88967 :     size_t in_usage = sdsAllocSize(c-&gt;querybuf);</span>
<span class="lineNum">     909 </span><span class="lineCov">      88967 :     size_t out_usage = getClientOutputBufferMemoryUsage(c);</span>
<span class="lineNum">     910 </span><span class="lineCov">      88967 :     int i = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;</span>
<span class="lineNum">     911 </span><span class="lineCov">      88967 :     int zeroidx = (i+1) % CLIENTS_PEAK_MEM_USAGE_SLOTS;</span>
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     /* Always zero the next sample, so that when we switch to that second, we'll
<span class="lineNum">     914 </span>            :      * only register samples that are greater in that second without considering
<span class="lineNum">     915 </span>            :      * the history of such slot.
<span class="lineNum">     916 </span>            :      *
<span class="lineNum">     917 </span>            :      * Note: our index may jump to any random position if serverCron() is not
<span class="lineNum">     918 </span>            :      * called for some reason with the normal frequency, for instance because
<span class="lineNum">     919 </span>            :      * some slow command is called taking multiple seconds to execute. In that
<span class="lineNum">     920 </span>            :      * case our array may end containing data which is potentially older
<span class="lineNum">     921 </span>            :      * than CLIENTS_PEAK_MEM_USAGE_SLOTS seconds: however this is not a problem
<span class="lineNum">     922 </span>            :      * since here we want just to track if &quot;recently&quot; there were very expansive
<span class="lineNum">     923 </span>            :      * clients from the POV of memory usage. */
<span class="lineNum">     924 </span><span class="lineCov">      88967 :     ClientsPeakMemInput[zeroidx] = 0;</span>
<span class="lineNum">     925 </span><span class="lineCov">      88967 :     ClientsPeakMemOutput[zeroidx] = 0;</span>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            :     /* Track the biggest values observed so far in this slot. */
<span class="lineNum">     928 </span><span class="lineCov">      88967 :     if (in_usage &gt; ClientsPeakMemInput[i]) ClientsPeakMemInput[i] = in_usage;</span>
<span class="lineNum">     929 </span><span class="lineCov">      88967 :     if (out_usage &gt; ClientsPeakMemOutput[i]) ClientsPeakMemOutput[i] = out_usage;</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">      88967 :     return 0; /* This function never terminates the client. */</span>
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : 
<a name="934"><span class="lineNum">     934 </span>            : /* Return the max samples in the memory usage of clients tracked by</a>
<span class="lineNum">     935 </span>            :  * the function clientsCronTrackExpansiveClients(). */
<span class="lineNum">     936 </span><span class="lineNoCov">          0 : void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :     size_t i = 0, o = 0;</span>
<span class="lineNum">     938 </span><span class="lineCov">     275562 :     for (int j = 0; j &lt; CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {</span>
<span class="lineNum">     939 </span><span class="lineCov">     244944 :         if (ClientsPeakMemInput[j] &gt; i) i = ClientsPeakMemInput[j];</span>
<span class="lineNum">     940 </span><span class="lineCov">     244944 :         if (ClientsPeakMemOutput[j] &gt; o) o = ClientsPeakMemOutput[j];</span>
<span class="lineNum">     941 </span>            :     }
<span class="lineNum">     942 </span><span class="lineCov">      30618 :     *in_usage = i;</span>
<span class="lineNum">     943 </span><span class="lineCov">      30618 :     *out_usage = o;</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : /* This function is called by serverCron() and is used in order to perform
<span class="lineNum">     947 </span>            :  * operations on clients that are important to perform constantly. For instance
<span class="lineNum">     948 </span>            :  * we use this function in order to disconnect clients after a timeout, including
<span class="lineNum">     949 </span>            :  * clients blocked in some blocking command with a non-zero timeout.
<span class="lineNum">     950 </span>            :  *
<span class="lineNum">     951 </span>            :  * The function makes some effort to process all the clients every second, even
<span class="lineNum">     952 </span>            :  * if this cannot be strictly guaranteed, since serverCron() may be called with
<span class="lineNum">     953 </span>            :  * an actual frequency lower than server.hz in case of latency events like slow
<span class="lineNum">     954 </span>            :  * commands.
<span class="lineNum">     955 </span>            :  *
<span class="lineNum">     956 </span>            :  * It is very important for this function, and the functions it calls, to be
<span class="lineNum">     957 </span>            :  * very fast: sometimes Redis has tens of hundreds of connected clients, and the
<span class="lineNum">     958 </span>            :  * default server.hz value is 10, so sometimes here we need to process thousands
<span class="lineNum">     959 </span>            :  * of clients per second, turning this function into a source of latency.
<a name="960"><span class="lineNum">     960 </span>            :  */</a>
<span class="lineNum">     961 </span>            : #define CLIENTS_CRON_MIN_ITERATIONS 5
<span class="lineNum">     962 </span><span class="lineCov">      42513 : void clientsCron(void) {</span>
<span class="lineNum">     963 </span>            :     /* Try to process at least numclients/server.hz of clients
<span class="lineNum">     964 </span>            :      * per call. Since normally (if there are no big latency events) this
<span class="lineNum">     965 </span>            :      * function is called server.hz times per second, in the average case we
<span class="lineNum">     966 </span>            :      * process all the clients in 1 second. */
<span class="lineNum">     967 </span><span class="lineCov">      42513 :     int numclients = listLength(server.clients);</span>
<span class="lineNum">     968 </span><span class="lineCov">      42513 :     int iterations = numclients/server.hz;</span>
<span class="lineNum">     969 </span><span class="lineCov">      42513 :     mstime_t now = mstime();</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span>            :     /* Process at least a few clients while we are at it, even if we need
<span class="lineNum">     972 </span>            :      * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract
<span class="lineNum">     973 </span>            :      * of processing each client once per second. */
<span class="lineNum">     974 </span><span class="lineCov">      42513 :     if (iterations &lt; CLIENTS_CRON_MIN_ITERATIONS)</span>
<span class="lineNum">     975 </span><span class="lineCov">      42083 :         iterations = (numclients &lt; CLIENTS_CRON_MIN_ITERATIONS) ?</span>
<span class="lineNum">     976 </span>            :                      numclients : CLIENTS_CRON_MIN_ITERATIONS;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineCov">     131480 :     while(listLength(server.clients) &amp;&amp; iterations--) {</span>
<span class="lineNum">     979 </span><span class="lineCov">      88967 :         client *c;</span>
<span class="lineNum">     980 </span><span class="lineCov">      88967 :         listNode *head;</span>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            :         /* Rotate the list, take the current head, process.
<span class="lineNum">     983 </span>            :          * This way if the client must be removed from the list it's the
<span class="lineNum">     984 </span>            :          * first element and we don't incur into O(N) computation. */
<span class="lineNum">     985 </span><span class="lineCov">      88967 :         listRotate(server.clients);</span>
<span class="lineNum">     986 </span><span class="lineCov">      88967 :         head = listFirst(server.clients);</span>
<span class="lineNum">     987 </span><span class="lineCov">      88967 :         c = listNodeValue(head);</span>
<span class="lineNum">     988 </span>            :         /* The following functions do different service checks on the client.
<span class="lineNum">     989 </span>            :          * The protocol is that they return non-zero if the client was
<span class="lineNum">     990 </span>            :          * terminated. */
<span class="lineNum">     991 </span><span class="lineCov">      88967 :         if (clientsCronHandleTimeout(c,now)) continue;</span>
<span class="lineNum">     992 </span><span class="lineCov">      88967 :         if (clientsCronResizeQueryBuffer(c)) continue;</span>
<span class="lineNum">     993 </span><span class="lineCov">      88967 :         if (clientsCronTrackExpansiveClients(c)) continue;</span>
<span class="lineNum">     994 </span>            :     }
<span class="lineNum">     995 </span><span class="lineCov">      42513 : }</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : /* This function handles 'background' operations we are required to do
<a name="998"><span class="lineNum">     998 </span>            :  * incrementally in Redis databases, such as active key expiring, resizing,</a>
<span class="lineNum">     999 </span>            :  * rehashing. */
<span class="lineNum">    1000 </span><span class="lineCov">      42513 : void databasesCron(void) {</span>
<span class="lineNum">    1001 </span>            :     /* Expire keys by random sampling. Not required for slaves
<span class="lineNum">    1002 </span>            :      * as master will synthesize DELs for us. */
<span class="lineNum">    1003 </span><span class="lineCov">      42513 :     if (server.active_expire_enabled &amp;&amp; server.masterhost == NULL) {</span>
<span class="lineNum">    1004 </span><span class="lineCov">      30673 :         activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);</span>
<span class="lineNum">    1005 </span><span class="lineCov">      11840 :     } else if (server.masterhost != NULL) {</span>
<span class="lineNum">    1006 </span><span class="lineCov">      11689 :         expireSlaveKeys();</span>
<span class="lineNum">    1007 </span>            :     }
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            :     /* Defrag keys gradually. */
<span class="lineNum">    1010 </span><span class="lineCov">      42513 :     if (server.active_defrag_enabled)</span>
<span class="lineNum">    1011 </span><span class="lineCov">        188 :         activeDefragCycle();</span>
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            :     /* Perform hash tables rehashing if needed, but only if there are no
<span class="lineNum">    1014 </span>            :      * other processes saving the DB on disk. Otherwise rehashing is bad
<span class="lineNum">    1015 </span>            :      * as will cause a lot of copy-on-write of memory pages. */
<span class="lineNum">    1016 </span><span class="lineCov">      42513 :     if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1) {</span>
<span class="lineNum">    1017 </span>            :         /* We use global counters so if we stop the computation at a given
<span class="lineNum">    1018 </span>            :          * DB we'll be able to start from the successive in the next
<span class="lineNum">    1019 </span>            :          * cron loop iteration. */
<span class="lineNum">    1020 </span><span class="lineCov">      41012 :         static unsigned int resize_db = 0;</span>
<span class="lineNum">    1021 </span><span class="lineCov">      41012 :         static unsigned int rehash_db = 0;</span>
<span class="lineNum">    1022 </span><span class="lineCov">      41012 :         int dbs_per_call = CRON_DBS_PER_CALL;</span>
<span class="lineNum">    1023 </span><span class="lineCov">      41012 :         int j;</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :         /* Don't test more DBs than we have. */
<span class="lineNum">    1026 </span><span class="lineCov">      41012 :         if (dbs_per_call &gt; server.dbnum) dbs_per_call = server.dbnum;</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :         /* Resize */
<span class="lineNum">    1029 </span><span class="lineCov">     697204 :         for (j = 0; j &lt; dbs_per_call; j++) {</span>
<span class="lineNum">    1030 </span><span class="lineCov">     656192 :             tryResizeHashTables(resize_db % server.dbnum);</span>
<span class="lineNum">    1031 </span><span class="lineCov">     656192 :             resize_db++;</span>
<span class="lineNum">    1032 </span>            :         }
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :         /* Rehash */
<span class="lineNum">    1035 </span><span class="lineCov">      41012 :         if (server.activerehashing) {</span>
<span class="lineNum">    1036 </span><span class="lineCov">     667637 :             for (j = 0; j &lt; dbs_per_call; j++) {</span>
<span class="lineNum">    1037 </span><span class="lineCov">     628752 :                 int work_done = incrementallyRehash(rehash_db);</span>
<span class="lineNum">    1038 </span><span class="lineCov">     628752 :                 if (work_done) {</span>
<span class="lineNum">    1039 </span>            :                     /* If the function did some work, stop here, we'll do
<span class="lineNum">    1040 </span>            :                      * more at the next cron loop. */
<span class="lineNum">    1041 </span>            :                     break;
<span class="lineNum">    1042 </span>            :                 } else {
<span class="lineNum">    1043 </span>            :                     /* If this db didn't need rehash, we'll try the next one. */
<span class="lineNum">    1044 </span><span class="lineCov">     626625 :                     rehash_db++;</span>
<span class="lineNum">    1045 </span><span class="lineCov">     626625 :                     rehash_db %= server.dbnum;</span>
<span class="lineNum">    1046 </span>            :                 }
<span class="lineNum">    1047 </span>            :             }
<span class="lineNum">    1048 </span>            :         }
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span><span class="lineCov">      42513 : }</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span>            : /* We take a cached value of the unix time in the global state because with
<span class="lineNum">    1053 </span>            :  * virtual memory and aging there is to store the current time in objects at
<a name="1054"><span class="lineNum">    1054 </span>            :  * every object access, and accuracy is not needed. To access a global var is</a>
<span class="lineNum">    1055 </span>            :  * a lot faster than calling time(NULL) */
<span class="lineNum">    1056 </span><span class="lineCov">      43798 : void updateCachedTime(void) {</span>
<span class="lineNum">    1057 </span><span class="lineCov">      43798 :     time_t unixtime = time(NULL);</span>
<span class="lineNum">    1058 </span><span class="lineCov">      43798 :     atomicSet(server.unixtime,unixtime);</span>
<span class="lineNum">    1059 </span><span class="lineCov">      43798 :     server.mstime = mstime();</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :     /* To get information about daylight saving time, we need to call localtime_r
<span class="lineNum">    1062 </span>            :      * and cache the result. However calling localtime_r in this context is safe
<span class="lineNum">    1063 </span>            :      * since we will never fork() while here, in the main thread. The logging
<span class="lineNum">    1064 </span>            :      * function will call a thread safe version of localtime that has no locks. */
<span class="lineNum">    1065 </span><span class="lineCov">      43798 :     struct tm tm;</span>
<span class="lineNum">    1066 </span><span class="lineCov">      43798 :     localtime_r(&amp;server.unixtime,&amp;tm);</span>
<span class="lineNum">    1067 </span><span class="lineCov">      43798 :     server.daylight_active = tm.tm_isdst;</span>
<span class="lineNum">    1068 </span><span class="lineCov">      43798 : }</span>
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            : /* This is our timer interrupt, called server.hz times per second.
<span class="lineNum">    1071 </span>            :  * Here is where we do a number of things that need to be done asynchronously.
<span class="lineNum">    1072 </span>            :  * For instance:
<span class="lineNum">    1073 </span>            :  *
<span class="lineNum">    1074 </span>            :  * - Active expired keys collection (it is also performed in a lazy way on
<span class="lineNum">    1075 </span>            :  *   lookup).
<span class="lineNum">    1076 </span>            :  * - Software watchdog.
<span class="lineNum">    1077 </span>            :  * - Update some statistic.
<span class="lineNum">    1078 </span>            :  * - Incremental rehashing of the DBs hash tables.
<span class="lineNum">    1079 </span>            :  * - Triggering BGSAVE / AOF rewrite, and handling of terminated children.
<span class="lineNum">    1080 </span>            :  * - Clients timeout of different kinds.
<span class="lineNum">    1081 </span>            :  * - Replication reconnection.
<span class="lineNum">    1082 </span>            :  * - Many more...
<span class="lineNum">    1083 </span>            :  *
<span class="lineNum">    1084 </span>            :  * Everything directly called here will be called server.hz times per second,
<span class="lineNum">    1085 </span>            :  * so in order to throttle execution of things we want to do less frequently
<span class="lineNum">    1086 </span>            :  * a macro is used: run_with_period(milliseconds) { .... }
<a name="1087"><span class="lineNum">    1087 </span>            :  */</a>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">      42922 : int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {</span>
<span class="lineNum">    1090 </span><span class="lineCov">      42922 :     int j;</span>
<span class="lineNum">    1091 </span><span class="lineCov">      42922 :     UNUSED(eventLoop);</span>
<span class="lineNum">    1092 </span><span class="lineCov">      42922 :     UNUSED(id);</span>
<span class="lineNum">    1093 </span><span class="lineCov">      42922 :     UNUSED(clientData);</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :     /* Software watchdog: deliver the SIGALRM that will reach the signal
<span class="lineNum">    1096 </span>            :      * handler if we don't return here fast enough. */
<span class="lineNum">    1097 </span><span class="lineCov">      42922 :     if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            :     /* Update the time cache. */
<span class="lineNum">    1100 </span><span class="lineCov">      42922 :     updateCachedTime();</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineCov">      42922 :     server.hz = server.config_hz;</span>
<span class="lineNum">    1103 </span>            :     /* Adapt the server.hz value to the number of configured clients. If we have
<span class="lineNum">    1104 </span>            :      * many clients, we want to call serverCron() with an higher frequency. */
<span class="lineNum">    1105 </span><span class="lineCov">      42922 :     if (server.dynamic_hz) {</span>
<span class="lineNum">    1106 </span><span class="lineCov">      42922 :         while (listLength(server.clients) / server.hz &gt;</span>
<span class="lineNum">    1107 </span>            :                MAX_CLIENTS_PER_CLOCK_TICK)
<span class="lineNum">    1108 </span>            :         {
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :             server.hz *= 2;</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :             if (server.hz &gt; CONFIG_MAX_HZ) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :                 server.hz = CONFIG_MAX_HZ;</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1113 </span>            :             }
<span class="lineNum">    1114 </span>            :         }
<span class="lineNum">    1115 </span>            :     }
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineCov">      42922 :     run_with_period(100) {</span>
<span class="lineNum">    1118 </span><span class="lineCov">      42922 :         trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</span>
<span class="lineNum">    1119 </span><span class="lineCov">      42922 :         trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</span>
<span class="lineNum">    1120 </span>            :                 server.stat_net_input_bytes);
<span class="lineNum">    1121 </span><span class="lineCov">      42922 :         trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</span>
<span class="lineNum">    1122 </span>            :                 server.stat_net_output_bytes);
<span class="lineNum">    1123 </span>            :     }
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            :     /* We have just LRU_BITS bits per object for LRU information.
<span class="lineNum">    1126 </span>            :      * So we use an (eventually wrapping) LRU clock.
<span class="lineNum">    1127 </span>            :      *
<span class="lineNum">    1128 </span>            :      * Note that even if the counter wraps it's not a big problem,
<span class="lineNum">    1129 </span>            :      * everything will still work but some object will appear younger
<span class="lineNum">    1130 </span>            :      * to Redis. However for this to happen a given object should never be
<span class="lineNum">    1131 </span>            :      * touched for all the time needed to the counter to wrap, which is
<span class="lineNum">    1132 </span>            :      * not likely.
<span class="lineNum">    1133 </span>            :      *
<span class="lineNum">    1134 </span>            :      * Note that you can change the resolution altering the
<span class="lineNum">    1135 </span>            :      * LRU_CLOCK_RESOLUTION define. */
<span class="lineNum">    1136 </span><span class="lineCov">      42922 :     unsigned long lruclock = getLRUClock();</span>
<span class="lineNum">    1137 </span><span class="lineCov">      42922 :     atomicSet(server.lruclock,lruclock);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            :     /* Record the max memory used since the server was started. */
<span class="lineNum">    1140 </span><span class="lineCov">      42922 :     if (zmalloc_used_memory() &gt; server.stat_peak_memory)</span>
<span class="lineNum">    1141 </span><span class="lineCov">      11710 :         server.stat_peak_memory = zmalloc_used_memory();</span>
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineCov">      42922 :     run_with_period(100) {</span>
<span class="lineNum">    1144 </span>            :         /* Sample the RSS and other metrics here since this is a relatively slow call.
<span class="lineNum">    1145 </span>            :          * We must sample the zmalloc_used at the same time we take the rss, otherwise
<span class="lineNum">    1146 </span>            :          * the frag ratio calculate may be off (ratio of two samples at different times) */
<span class="lineNum">    1147 </span><span class="lineCov">      42922 :         server.cron_malloc_stats.process_rss = zmalloc_get_rss();</span>
<span class="lineNum">    1148 </span><span class="lineCov">      42922 :         server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();</span>
<span class="lineNum">    1149 </span>            :         /* Sampling the allcator info can be slow too.
<span class="lineNum">    1150 </span>            :          * The fragmentation ratio it'll show is potentically more accurate
<span class="lineNum">    1151 </span>            :          * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc
<span class="lineNum">    1152 </span>            :          * allocations, and allocator reserved pages that can be pursed (all not actual frag) */
<span class="lineNum">    1153 </span><span class="lineCov">      42922 :         zmalloc_get_allocator_info(&amp;server.cron_malloc_stats.allocator_allocated,</span>
<span class="lineNum">    1154 </span>            :                                    &amp;server.cron_malloc_stats.allocator_active,
<span class="lineNum">    1155 </span>            :                                    &amp;server.cron_malloc_stats.allocator_resident);
<span class="lineNum">    1156 </span>            :         /* in case the allocator isn't providing these stats, fake them so that
<span class="lineNum">    1157 </span>            :          * fragmention info still shows some (inaccurate metrics) */
<span class="lineNum">    1158 </span><span class="lineCov">      42922 :         if (!server.cron_malloc_stats.allocator_resident) {</span>
<span class="lineNum">    1159 </span>            :             /* LUA memory isn't part of zmalloc_used, but it is part of the process RSS,
<span class="lineNum">    1160 </span>            :              * so we must desuct it in order to be able to calculate correct
<span class="lineNum">    1161 </span>            :              * &quot;allocator fragmentation&quot; ratio */
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             size_t lua_memory = lua_gc(server.lua,LUA_GCCOUNT,0)*1024LL;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             server.cron_malloc_stats.allocator_resident = server.cron_malloc_stats.process_rss - lua_memory;</span>
<span class="lineNum">    1164 </span>            :         }
<span class="lineNum">    1165 </span><span class="lineCov">      42922 :         if (!server.cron_malloc_stats.allocator_active)</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :             server.cron_malloc_stats.allocator_active = server.cron_malloc_stats.allocator_resident;</span>
<span class="lineNum">    1167 </span><span class="lineCov">      42922 :         if (!server.cron_malloc_stats.allocator_allocated)</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :             server.cron_malloc_stats.allocator_allocated = server.cron_malloc_stats.zmalloc_used;</span>
<span class="lineNum">    1169 </span>            :     }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            :     /* We received a SIGTERM, shutting down here in a safe way, as it is
<span class="lineNum">    1172 </span>            :      * not ok doing so inside the signal handler. */
<span class="lineNum">    1173 </span><span class="lineCov">      42922 :     if (server.shutdown_asap) {</span>
<span class="lineNum">    1174 </span><span class="lineCov">        409 :         if (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) exit(0);</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :         server.shutdown_asap = 0;</span>
<span class="lineNum">    1177 </span>            :     }
<span class="lineNum">    1178 </span>            : 
<span class="lineNum">    1179 </span>            :     /* Show some info about non-empty databases */
<span class="lineNum">    1180 </span><span class="lineCov">      42513 :     run_with_period(5000) {</span>
<span class="lineNum">    1181 </span><span class="lineCov">      21505 :         for (j = 0; j &lt; server.dbnum; j++) {</span>
<span class="lineNum">    1182 </span><span class="lineCov">      20240 :             long long size, used, vkeys;</span>
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span><span class="lineCov">      20240 :             size = dictSlots(server.db[j].dict);</span>
<span class="lineNum">    1185 </span><span class="lineCov">      20240 :             used = dictSize(server.db[j].dict);</span>
<span class="lineNum">    1186 </span><span class="lineCov">      20240 :             vkeys = dictSize(server.db[j].expires);</span>
<span class="lineNum">    1187 </span><span class="lineCov">      20240 :             if (used || vkeys) {</span>
<span class="lineNum">    1188 </span><span class="lineCov">        831 :                 serverLog(LL_VERBOSE,&quot;DB %d: %lld keys (%lld volatile) in %lld slots HT.&quot;,j,used,vkeys,size);</span>
<span class="lineNum">    1189 </span>            :                 /* dictPrintStats(server.dict); */
<span class="lineNum">    1190 </span>            :             }
<span class="lineNum">    1191 </span>            :         }
<span class="lineNum">    1192 </span>            :     }
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :     /* Show information about connected clients */
<span class="lineNum">    1195 </span><span class="lineCov">      42513 :     if (!server.sentinel_mode) {</span>
<span class="lineNum">    1196 </span><span class="lineCov">      42513 :         run_with_period(5000) {</span>
<span class="lineNum">    1197 </span><span class="lineCov">       1265 :             serverLog(LL_VERBOSE,</span>
<span class="lineNum">    1198 </span>            :                 &quot;%lu clients connected (%lu replicas), %zu bytes in use&quot;,
<span class="lineNum">    1199 </span><span class="lineCov">       1265 :                 listLength(server.clients)-listLength(server.slaves),</span>
<span class="lineNum">    1200 </span><span class="lineCov">       1265 :                 listLength(server.slaves),</span>
<span class="lineNum">    1201 </span>            :                 zmalloc_used_memory());
<span class="lineNum">    1202 </span>            :         }
<span class="lineNum">    1203 </span>            :     }
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span>            :     /* We need to do a few operations on clients asynchronously. */
<span class="lineNum">    1206 </span><span class="lineCov">      42513 :     clientsCron();</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            :     /* Handle background operations on Redis databases. */
<span class="lineNum">    1209 </span><span class="lineCov">      42513 :     databasesCron();</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            :     /* Start a scheduled AOF rewrite if this was requested by the user while
<span class="lineNum">    1212 </span>            :      * a BGSAVE was in progress. */
<span class="lineNum">    1213 </span><span class="lineCov">      42513 :     if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</span>
<span class="lineNum">    1214 </span><span class="lineCov">      41012 :         server.aof_rewrite_scheduled)</span>
<span class="lineNum">    1215 </span>            :     {
<span class="lineNum">    1216 </span><span class="lineCov">          6 :         rewriteAppendOnlyFileBackground();</span>
<span class="lineNum">    1217 </span>            :     }
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span>            :     /* Check if a background saving or AOF rewrite in progress terminated. */
<span class="lineNum">    1220 </span><span class="lineCov">      83516 :     if (server.rdb_child_pid != -1 || server.aof_child_pid != -1 ||</span>
<span class="lineNum">    1221 </span><span class="lineCov">      41006 :         ldbPendingChildren())</span>
<span class="lineNum">    1222 </span><span class="lineCov">       1504 :     {</span>
<span class="lineNum">    1223 </span><span class="lineCov">       1504 :         int statloc;</span>
<span class="lineNum">    1224 </span><span class="lineCov">       1504 :         pid_t pid;</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">       1504 :         if ((pid = wait3(&amp;statloc,WNOHANG,NULL)) != 0) {</span>
<span class="lineNum">    1227 </span><span class="lineCov">        741 :             int exitcode = WEXITSTATUS(statloc);</span>
<span class="lineNum">    1228 </span><span class="lineCov">        741 :             int bysignal = 0;</span>
<span class="lineNum">    1229 </span>            : 
<span class="lineNum">    1230 </span><span class="lineCov">        741 :             if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineCov">        741 :             if (pid == -1) {</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING,&quot;wait3() returned an error: %s. &quot;</span>
<span class="lineNum">    1234 </span>            :                     &quot;rdb_child_pid = %d, aof_child_pid = %d&quot;,
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :                     strerror(errno),</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                     (int) server.rdb_child_pid,</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :                     (int) server.aof_child_pid);</span>
<span class="lineNum">    1238 </span><span class="lineCov">        741 :             } else if (pid == server.rdb_child_pid) {</span>
<span class="lineNum">    1239 </span><span class="lineCov">        235 :                 backgroundSaveDoneHandler(exitcode,bysignal);</span>
<span class="lineNum">    1240 </span><span class="lineCov">        235 :                 if (!bysignal &amp;&amp; exitcode == 0) receiveChildInfo();</span>
<span class="lineNum">    1241 </span><span class="lineCov">        506 :             } else if (pid == server.aof_child_pid) {</span>
<span class="lineNum">    1242 </span><span class="lineCov">        506 :                 backgroundRewriteDoneHandler(exitcode,bysignal);</span>
<span class="lineNum">    1243 </span><span class="lineCov">        506 :                 if (!bysignal &amp;&amp; exitcode == 0) receiveChildInfo();</span>
<span class="lineNum">    1244 </span>            :             } else {
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                 if (!ldbRemoveChild(pid)) {</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :                     serverLog(LL_WARNING,</span>
<span class="lineNum">    1247 </span>            :                         &quot;Warning, detected child with unmatched pid: %ld&quot;,
<span class="lineNum">    1248 </span>            :                         (long)pid);
<span class="lineNum">    1249 </span>            :                 }
<span class="lineNum">    1250 </span>            :             }
<span class="lineNum">    1251 </span><span class="lineCov">        741 :             updateDictResizePolicy();</span>
<span class="lineNum">    1252 </span><span class="lineCov">        741 :             closeChildInfoPipe();</span>
<span class="lineNum">    1253 </span>            :         }
<span class="lineNum">    1254 </span>            :     } else {
<span class="lineNum">    1255 </span>            :         /* If there is not a background saving/rewrite in progress check if
<span class="lineNum">    1256 </span>            :          * we have to save/rewrite now. */
<span class="lineNum">    1257 </span><span class="lineCov">      81512 :         for (j = 0; j &lt; server.saveparamslen; j++) {</span>
<span class="lineNum">    1258 </span><span class="lineCov">      40512 :             struct saveparam *sp = server.saveparams+j;</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span>            :             /* Save if we reached the given amount of changes,
<span class="lineNum">    1261 </span>            :              * the given amount of seconds, and if the latest bgsave was
<span class="lineNum">    1262 </span>            :              * successful or if, in case of an error, at least
<span class="lineNum">    1263 </span>            :              * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */
<span class="lineNum">    1264 </span><span class="lineCov">      40512 :             if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span>
<span class="lineNum">    1265 </span><span class="lineCov">      15211 :                 server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span>
<span class="lineNum">    1266 </span><span class="lineCov">          6 :                 (server.unixtime-server.lastbgsave_try &gt;</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :                  CONFIG_BGSAVE_RETRY_DELAY ||</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :                  server.lastbgsave_status == C_OK))</span>
<span class="lineNum">    1269 </span>            :             {
<span class="lineNum">    1270 </span><span class="lineCov">          6 :                 serverLog(LL_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</span>
<span class="lineNum">    1271 </span>            :                     sp-&gt;changes, (int)sp-&gt;seconds);
<span class="lineNum">    1272 </span><span class="lineCov">          6 :                 rdbSaveInfo rsi, *rsiptr;</span>
<span class="lineNum">    1273 </span><span class="lineCov">          6 :                 rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span>
<span class="lineNum">    1274 </span><span class="lineCov">          6 :                 rdbSaveBackground(server.rdb_filename,rsiptr);</span>
<span class="lineNum">    1275 </span><span class="lineCov">          3 :                 break;</span>
<span class="lineNum">    1276 </span>            :             }
<span class="lineNum">    1277 </span>            :         }
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span>            :         /* Trigger an AOF rewrite if needed. */
<span class="lineNum">    1280 </span><span class="lineCov">      41003 :         if (server.aof_state == AOF_ON &amp;&amp;</span>
<span class="lineNum">    1281 </span><span class="lineCov">       1829 :             server.rdb_child_pid == -1 &amp;&amp;</span>
<span class="lineNum">    1282 </span><span class="lineCov">       1829 :             server.aof_child_pid == -1 &amp;&amp;</span>
<span class="lineNum">    1283 </span><span class="lineCov">       1829 :             server.aof_rewrite_perc &amp;&amp;</span>
<span class="lineNum">    1284 </span><span class="lineCov">       1176 :             server.aof_current_size &gt; server.aof_rewrite_min_size)</span>
<span class="lineNum">    1285 </span>            :         {
<span class="lineNum">    1286 </span><span class="lineNoCov">          0 :             long long base = server.aof_rewrite_base_size ?</span>
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :                 server.aof_rewrite_base_size : 1;</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :             long long growth = (server.aof_current_size*100/base) - 100;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :             if (growth &gt;= server.aof_rewrite_perc) {</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                 serverLog(LL_NOTICE,&quot;Starting automatic rewriting of AOF on %lld%% growth&quot;,growth);</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :                 rewriteAppendOnlyFileBackground();</span>
<span class="lineNum">    1292 </span>            :             }
<span class="lineNum">    1293 </span>            :         }
<span class="lineNum">    1294 </span>            :     }
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            :     /* AOF postponed flush: Try at every cron cycle if the slow fsync
<span class="lineNum">    1298 </span>            :      * completed. */
<span class="lineNum">    1299 </span><span class="lineCov">      42507 :     if (server.aof_flush_postponed_start) flushAppendOnlyFile(0);</span>
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :     /* AOF write errors: in this case we have a buffer to flush as well and
<span class="lineNum">    1302 </span>            :      * clear the AOF error in case of success to make the DB writable again,
<span class="lineNum">    1303 </span>            :      * however to try every second is enough in case of 'hz' is set to
<span class="lineNum">    1304 </span>            :      * an higher frequency. */
<span class="lineNum">    1305 </span><span class="lineCov">      42507 :     run_with_period(1000) {</span>
<span class="lineNum">    1306 </span><span class="lineCov">       4607 :         if (server.aof_last_write_status == C_ERR)</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :             flushAppendOnlyFile(0);</span>
<span class="lineNum">    1308 </span>            :     }
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :     /* Close clients that need to be closed asynchronous */
<span class="lineNum">    1311 </span><span class="lineCov">      42507 :     freeClientsInAsyncFreeQueue();</span>
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            :     /* Clear the paused clients flag if needed. */
<span class="lineNum">    1314 </span><span class="lineCov">      42507 :     clientsArePaused(); /* Don't check return value, just use the side effect.*/</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span>            :     /* Replication cron function -- used to reconnect to master,
<span class="lineNum">    1317 </span>            :      * detect transfer failures, start background RDB transfers and so forth. */
<span class="lineNum">    1318 </span><span class="lineCov">      42507 :     run_with_period(1000) replicationCron();</span>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :     /* Run the Redis Cluster cron. */
<span class="lineNum">    1321 </span><span class="lineCov">      42480 :     run_with_period(100) {</span>
<span class="lineNum">    1322 </span><span class="lineCov">      42480 :         if (server.cluster_enabled) clusterCron();</span>
<span class="lineNum">    1323 </span>            :     }
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            :     /* Run the Sentinel timer if we are in sentinel mode. */
<span class="lineNum">    1326 </span><span class="lineCov">      42480 :     if (server.sentinel_mode) sentinelTimer();</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span>            :     /* Cleanup expired MIGRATE cached sockets. */
<span class="lineNum">    1329 </span><span class="lineCov">      42480 :     run_with_period(1000) {</span>
<span class="lineNum">    1330 </span><span class="lineCov">       4580 :         migrateCloseTimedoutSockets();</span>
<span class="lineNum">    1331 </span>            :     }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :     /* Start a scheduled BGSAVE if the corresponding flag is set. This is
<span class="lineNum">    1334 </span>            :      * useful when we are forced to postpone a BGSAVE because an AOF
<span class="lineNum">    1335 </span>            :      * rewrite is in progress.
<span class="lineNum">    1336 </span>            :      *
<span class="lineNum">    1337 </span>            :      * Note: this code must be after the replicationCron() call above so
<span class="lineNum">    1338 </span>            :      * make sure when refactoring this file to keep this order. This is useful
<span class="lineNum">    1339 </span>            :      * because we want to give priority to RDB savings for replication. */
<span class="lineNum">    1340 </span><span class="lineCov">      42480 :     if (server.rdb_child_pid == -1 &amp;&amp; server.aof_child_pid == -1 &amp;&amp;</span>
<span class="lineNum">    1341 </span><span class="lineCov">      41675 :         server.rdb_bgsave_scheduled &amp;&amp;</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :         (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY ||</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :          server.lastbgsave_status == C_OK))</span>
<span class="lineNum">    1344 </span>            :     {
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :         rdbSaveInfo rsi, *rsiptr;</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :         rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :         if (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :             server.rdb_bgsave_scheduled = 0;</span>
<span class="lineNum">    1349 </span>            :     }
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span><span class="lineCov">      42480 :     server.cronloops++;</span>
<span class="lineNum">    1352 </span><span class="lineCov">      42480 :     return 1000/server.hz;</span>
<span class="lineNum">    1353 </span>            : }
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            : /* This function gets called every time Redis is entering the
<a name="1356"><span class="lineNum">    1356 </span>            :  * main loop of the event driven library, that is, before to sleep</a>
<span class="lineNum">    1357 </span>            :  * for ready file descriptors. */
<span class="lineNum">    1358 </span><span class="lineCov">   22711701 : void beforeSleep(struct aeEventLoop *eventLoop) {</span>
<span class="lineNum">    1359 </span><span class="lineCov">   22711701 :     UNUSED(eventLoop);</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :     /* Call the Redis Cluster before sleep function. Note that this function
<span class="lineNum">    1362 </span>            :      * may change the state of Redis Cluster (from ok to fail or vice versa),
<span class="lineNum">    1363 </span>            :      * so it's a good idea to call it before serving the unblocked clients
<span class="lineNum">    1364 </span>            :      * later in this function. */
<span class="lineNum">    1365 </span><span class="lineCov">   22711701 :     if (server.cluster_enabled) clusterBeforeSleep();</span>
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span>            :     /* Run a fast expire cycle (the called function will return
<span class="lineNum">    1368 </span>            :      * ASAP if a fast cycle is not needed). */
<span class="lineNum">    1369 </span><span class="lineCov">   22711701 :     if (server.active_expire_enabled &amp;&amp; server.masterhost == NULL)</span>
<span class="lineNum">    1370 </span><span class="lineCov">   19423601 :         activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</span>
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            :     /* Send all the slaves an ACK request if at least one client blocked
<span class="lineNum">    1373 </span>            :      * during the previous event loop iteration. */
<span class="lineNum">    1374 </span><span class="lineCov">   22711701 :     if (server.get_ack_from_slaves) {</span>
<span class="lineNum">    1375 </span><span class="lineCov">          6 :         robj *argv[3];</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineCov">          6 :         argv[0] = createStringObject(&quot;REPLCONF&quot;,8);</span>
<span class="lineNum">    1378 </span><span class="lineCov">          6 :         argv[1] = createStringObject(&quot;GETACK&quot;,6);</span>
<span class="lineNum">    1379 </span><span class="lineCov">          6 :         argv[2] = createStringObject(&quot;*&quot;,1); /* Not used argument. */</span>
<span class="lineNum">    1380 </span><span class="lineCov">          6 :         replicationFeedSlaves(server.slaves, server.slaveseldb, argv, 3);</span>
<span class="lineNum">    1381 </span><span class="lineCov">          6 :         decrRefCount(argv[0]);</span>
<span class="lineNum">    1382 </span><span class="lineCov">          6 :         decrRefCount(argv[1]);</span>
<span class="lineNum">    1383 </span><span class="lineCov">          6 :         decrRefCount(argv[2]);</span>
<span class="lineNum">    1384 </span><span class="lineCov">          6 :         server.get_ack_from_slaves = 0;</span>
<span class="lineNum">    1385 </span>            :     }
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span>            :     /* Unblock all the clients blocked for synchronous replication
<span class="lineNum">    1388 </span>            :      * in WAIT. */
<span class="lineNum">    1389 </span><span class="lineCov">   22711701 :     if (listLength(server.clients_waiting_acks))</span>
<span class="lineNum">    1390 </span><span class="lineCov">         90 :         processClientsWaitingReplicas();</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            :     /* Check if there are clients unblocked by modules that implement
<span class="lineNum">    1393 </span>            :      * blocking commands. */
<span class="lineNum">    1394 </span><span class="lineCov">   22711701 :     moduleHandleBlockedClients();</span>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            :     /* Try to process pending commands for clients that were just unblocked. */
<span class="lineNum">    1397 </span><span class="lineCov">   22711701 :     if (listLength(server.unblocked_clients))</span>
<span class="lineNum">    1398 </span><span class="lineCov">        204 :         processUnblockedClients();</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            :     /* Write the AOF buffer on disk */
<span class="lineNum">    1401 </span><span class="lineCov">   22711701 :     flushAppendOnlyFile(0);</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            :     /* Handle writes with pending output buffers. */
<span class="lineNum">    1404 </span><span class="lineCov">   22711701 :     handleClientsWithPendingWrites();</span>
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :     /* Before we are going to sleep, let the threads access the dataset by
<span class="lineNum">    1407 </span>            :      * releasing the GIL. Redis main thread will not touch anything at this
<span class="lineNum">    1408 </span>            :      * time. */
<span class="lineNum">    1409 </span><span class="lineCov">   22711701 :     if (moduleCount()) moduleReleaseGIL();</span>
<span class="lineNum">    1410 </span><span class="lineCov">   22711701 : }</span>
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span>            : /* This function is called immadiately after the event loop multiplexing
<a name="1413"><span class="lineNum">    1413 </span>            :  * API returned, and the control is going to soon return to Redis by invoking</a>
<span class="lineNum">    1414 </span>            :  * the different events callbacks. */
<span class="lineNum">    1415 </span><span class="lineCov">   22711701 : void afterSleep(struct aeEventLoop *eventLoop) {</span>
<span class="lineNum">    1416 </span><span class="lineCov">   22711701 :     UNUSED(eventLoop);</span>
<span class="lineNum">    1417 </span><span class="lineCov">   22711701 :     if (moduleCount()) moduleAcquireGIL();</span>
<span class="lineNum">    1418 </span><span class="lineCov">   22711701 : }</span>
<span class="lineNum">    1419 </span>            : 
<a name="1420"><span class="lineNum">    1420 </span>            : /* =========================== Server initialization ======================== */</a>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span><span class="lineCov">        656 : void createSharedObjects(void) {</span>
<span class="lineNum">    1423 </span><span class="lineCov">        656 :     int j;</span>
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span><span class="lineCov">        656 :     shared.crlf = createObject(OBJ_STRING,sdsnew(&quot;\r\n&quot;));</span>
<span class="lineNum">    1426 </span><span class="lineCov">        656 :     shared.ok = createObject(OBJ_STRING,sdsnew(&quot;+OK\r\n&quot;));</span>
<span class="lineNum">    1427 </span><span class="lineCov">        656 :     shared.err = createObject(OBJ_STRING,sdsnew(&quot;-ERR\r\n&quot;));</span>
<span class="lineNum">    1428 </span><span class="lineCov">        656 :     shared.emptybulk = createObject(OBJ_STRING,sdsnew(&quot;$0\r\n\r\n&quot;));</span>
<span class="lineNum">    1429 </span><span class="lineCov">        656 :     shared.czero = createObject(OBJ_STRING,sdsnew(&quot;:0\r\n&quot;));</span>
<span class="lineNum">    1430 </span><span class="lineCov">        656 :     shared.cone = createObject(OBJ_STRING,sdsnew(&quot;:1\r\n&quot;));</span>
<span class="lineNum">    1431 </span><span class="lineCov">        656 :     shared.cnegone = createObject(OBJ_STRING,sdsnew(&quot;:-1\r\n&quot;));</span>
<span class="lineNum">    1432 </span><span class="lineCov">        656 :     shared.nullbulk = createObject(OBJ_STRING,sdsnew(&quot;$-1\r\n&quot;));</span>
<span class="lineNum">    1433 </span><span class="lineCov">        656 :     shared.nullmultibulk = createObject(OBJ_STRING,sdsnew(&quot;*-1\r\n&quot;));</span>
<span class="lineNum">    1434 </span><span class="lineCov">        656 :     shared.emptymultibulk = createObject(OBJ_STRING,sdsnew(&quot;*0\r\n&quot;));</span>
<span class="lineNum">    1435 </span><span class="lineCov">        656 :     shared.pong = createObject(OBJ_STRING,sdsnew(&quot;+PONG\r\n&quot;));</span>
<span class="lineNum">    1436 </span><span class="lineCov">        656 :     shared.queued = createObject(OBJ_STRING,sdsnew(&quot;+QUEUED\r\n&quot;));</span>
<span class="lineNum">    1437 </span><span class="lineCov">        656 :     shared.emptyscan = createObject(OBJ_STRING,sdsnew(&quot;*2\r\n$1\r\n0\r\n*0\r\n&quot;));</span>
<span class="lineNum">    1438 </span><span class="lineCov">        656 :     shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1439 </span>            :         &quot;-WRONGTYPE Operation against a key holding the wrong kind of value\r\n&quot;));
<span class="lineNum">    1440 </span><span class="lineCov">        656 :     shared.nokeyerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1441 </span>            :         &quot;-ERR no such key\r\n&quot;));
<span class="lineNum">    1442 </span><span class="lineCov">        656 :     shared.syntaxerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1443 </span>            :         &quot;-ERR syntax error\r\n&quot;));
<span class="lineNum">    1444 </span><span class="lineCov">        656 :     shared.sameobjecterr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1445 </span>            :         &quot;-ERR source and destination objects are the same\r\n&quot;));
<span class="lineNum">    1446 </span><span class="lineCov">        656 :     shared.outofrangeerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1447 </span>            :         &quot;-ERR index out of range\r\n&quot;));
<span class="lineNum">    1448 </span><span class="lineCov">        656 :     shared.noscripterr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1449 </span>            :         &quot;-NOSCRIPT No matching script. Please use EVAL.\r\n&quot;));
<span class="lineNum">    1450 </span><span class="lineCov">        656 :     shared.loadingerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1451 </span>            :         &quot;-LOADING Redis is loading the dataset in memory\r\n&quot;));
<span class="lineNum">    1452 </span><span class="lineCov">        656 :     shared.slowscripterr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1453 </span>            :         &quot;-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\r\n&quot;));
<span class="lineNum">    1454 </span><span class="lineCov">        656 :     shared.masterdownerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1455 </span>            :         &quot;-MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\r\n&quot;));
<span class="lineNum">    1456 </span><span class="lineCov">        656 :     shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1457 </span>            :         &quot;-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\r\n&quot;));
<span class="lineNum">    1458 </span><span class="lineCov">        656 :     shared.roslaveerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1459 </span>            :         &quot;-READONLY You can't write against a read only replica.\r\n&quot;));
<span class="lineNum">    1460 </span><span class="lineCov">        656 :     shared.noautherr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1461 </span>            :         &quot;-NOAUTH Authentication required.\r\n&quot;));
<span class="lineNum">    1462 </span><span class="lineCov">        656 :     shared.oomerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1463 </span>            :         &quot;-OOM command not allowed when used memory &gt; 'maxmemory'.\r\n&quot;));
<span class="lineNum">    1464 </span><span class="lineCov">        656 :     shared.execaborterr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1465 </span>            :         &quot;-EXECABORT Transaction discarded because of previous errors.\r\n&quot;));
<span class="lineNum">    1466 </span><span class="lineCov">        656 :     shared.noreplicaserr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1467 </span>            :         &quot;-NOREPLICAS Not enough good replicas to write.\r\n&quot;));
<span class="lineNum">    1468 </span><span class="lineCov">        656 :     shared.busykeyerr = createObject(OBJ_STRING,sdsnew(</span>
<span class="lineNum">    1469 </span>            :         &quot;-BUSYKEY Target key name already exists.\r\n&quot;));
<span class="lineNum">    1470 </span><span class="lineCov">        656 :     shared.space = createObject(OBJ_STRING,sdsnew(&quot; &quot;));</span>
<span class="lineNum">    1471 </span><span class="lineCov">        656 :     shared.colon = createObject(OBJ_STRING,sdsnew(&quot;:&quot;));</span>
<span class="lineNum">    1472 </span><span class="lineCov">        656 :     shared.plus = createObject(OBJ_STRING,sdsnew(&quot;+&quot;));</span>
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineCov">       7216 :     for (j = 0; j &lt; PROTO_SHARED_SELECT_CMDS; j++) {</span>
<span class="lineNum">    1475 </span><span class="lineCov">       6560 :         char dictid_str[64];</span>
<span class="lineNum">    1476 </span><span class="lineCov">       6560 :         int dictid_len;</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineCov">       6560 :         dictid_len = ll2string(dictid_str,sizeof(dictid_str),j);</span>
<span class="lineNum">    1479 </span><span class="lineCov">       6560 :         shared.select[j] = createObject(OBJ_STRING,</span>
<span class="lineNum">    1480 </span><span class="lineCov">       6560 :             sdscatprintf(sdsempty(),</span>
<span class="lineNum">    1481 </span>            :                 &quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;,
<span class="lineNum">    1482 </span>            :                 dictid_len, dictid_str));
<span class="lineNum">    1483 </span>            :     }
<span class="lineNum">    1484 </span><span class="lineCov">        656 :     shared.messagebulk = createStringObject(&quot;$7\r\nmessage\r\n&quot;,13);</span>
<span class="lineNum">    1485 </span><span class="lineCov">        656 :     shared.pmessagebulk = createStringObject(&quot;$8\r\npmessage\r\n&quot;,14);</span>
<span class="lineNum">    1486 </span><span class="lineCov">        656 :     shared.subscribebulk = createStringObject(&quot;$9\r\nsubscribe\r\n&quot;,15);</span>
<span class="lineNum">    1487 </span><span class="lineCov">        656 :     shared.unsubscribebulk = createStringObject(&quot;$11\r\nunsubscribe\r\n&quot;,18);</span>
<span class="lineNum">    1488 </span><span class="lineCov">        656 :     shared.psubscribebulk = createStringObject(&quot;$10\r\npsubscribe\r\n&quot;,17);</span>
<span class="lineNum">    1489 </span><span class="lineCov">        656 :     shared.punsubscribebulk = createStringObject(&quot;$12\r\npunsubscribe\r\n&quot;,19);</span>
<span class="lineNum">    1490 </span><span class="lineCov">        656 :     shared.del = createStringObject(&quot;DEL&quot;,3);</span>
<span class="lineNum">    1491 </span><span class="lineCov">        656 :     shared.unlink = createStringObject(&quot;UNLINK&quot;,6);</span>
<span class="lineNum">    1492 </span><span class="lineCov">        656 :     shared.rpop = createStringObject(&quot;RPOP&quot;,4);</span>
<span class="lineNum">    1493 </span><span class="lineCov">        656 :     shared.lpop = createStringObject(&quot;LPOP&quot;,4);</span>
<span class="lineNum">    1494 </span><span class="lineCov">        656 :     shared.lpush = createStringObject(&quot;LPUSH&quot;,5);</span>
<span class="lineNum">    1495 </span><span class="lineCov">        656 :     shared.rpoplpush = createStringObject(&quot;RPOPLPUSH&quot;,9);</span>
<span class="lineNum">    1496 </span><span class="lineCov">        656 :     shared.zpopmin = createStringObject(&quot;ZPOPMIN&quot;,7);</span>
<span class="lineNum">    1497 </span><span class="lineCov">        656 :     shared.zpopmax = createStringObject(&quot;ZPOPMAX&quot;,7);</span>
<span class="lineNum">    1498 </span><span class="lineCov">    6560656 :     for (j = 0; j &lt; OBJ_SHARED_INTEGERS; j++) {</span>
<span class="lineNum">    1499 </span><span class="lineCov">   13120000 :         shared.integers[j] =</span>
<span class="lineNum">    1500 </span><span class="lineCov">    6560000 :             makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));</span>
<span class="lineNum">    1501 </span><span class="lineCov">    6560000 :         shared.integers[j]-&gt;encoding = OBJ_ENCODING_INT;</span>
<span class="lineNum">    1502 </span>            :     }
<span class="lineNum">    1503 </span><span class="lineCov">      21648 :     for (j = 0; j &lt; OBJ_SHARED_BULKHDR_LEN; j++) {</span>
<span class="lineNum">    1504 </span><span class="lineCov">      20992 :         shared.mbulkhdr[j] = createObject(OBJ_STRING,</span>
<span class="lineNum">    1505 </span><span class="lineCov">      20992 :             sdscatprintf(sdsempty(),&quot;*%d\r\n&quot;,j));</span>
<span class="lineNum">    1506 </span><span class="lineCov">      20992 :         shared.bulkhdr[j] = createObject(OBJ_STRING,</span>
<span class="lineNum">    1507 </span><span class="lineCov">      20992 :             sdscatprintf(sdsempty(),&quot;$%d\r\n&quot;,j));</span>
<span class="lineNum">    1508 </span>            :     }
<span class="lineNum">    1509 </span>            :     /* The following two shared objects, minstring and maxstrings, are not
<span class="lineNum">    1510 </span>            :      * actually used for their value but as a special object meaning
<span class="lineNum">    1511 </span>            :      * respectively the minimum possible string and the maximum possible
<span class="lineNum">    1512 </span>            :      * string in string comparisons for the ZRANGEBYLEX command. */
<span class="lineNum">    1513 </span><span class="lineCov">        656 :     shared.minstring = sdsnew(&quot;minstring&quot;);</span>
<span class="lineNum">    1514 </span><span class="lineCov">        656 :     shared.maxstring = sdsnew(&quot;maxstring&quot;);</span>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineCov">        656 : }</span></a>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineCov">        662 : void initServerConfig(void) {</span>
<span class="lineNum">    1518 </span><span class="lineCov">        662 :     int j;</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">        662 :     pthread_mutex_init(&amp;server.next_client_id_mutex,NULL);</span>
<span class="lineNum">    1521 </span><span class="lineCov">        662 :     pthread_mutex_init(&amp;server.lruclock_mutex,NULL);</span>
<span class="lineNum">    1522 </span><span class="lineCov">        662 :     pthread_mutex_init(&amp;server.unixtime_mutex,NULL);</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineCov">        662 :     updateCachedTime();</span>
<span class="lineNum">    1525 </span><span class="lineCov">        662 :     getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);</span>
<span class="lineNum">    1526 </span><span class="lineCov">        662 :     server.runid[CONFIG_RUN_ID_SIZE] = '\0';</span>
<span class="lineNum">    1527 </span><span class="lineCov">        662 :     changeReplicationId();</span>
<span class="lineNum">    1528 </span><span class="lineCov">        662 :     clearReplicationId2();</span>
<span class="lineNum">    1529 </span><span class="lineCov">        662 :     server.timezone = getTimeZone(); /* Initialized by tzset(). */</span>
<span class="lineNum">    1530 </span><span class="lineCov">        662 :     server.configfile = NULL;</span>
<span class="lineNum">    1531 </span><span class="lineCov">        662 :     server.executable = NULL;</span>
<span class="lineNum">    1532 </span><span class="lineCov">        662 :     server.hz = server.config_hz = CONFIG_DEFAULT_HZ;</span>
<span class="lineNum">    1533 </span><span class="lineCov">        662 :     server.dynamic_hz = CONFIG_DEFAULT_DYNAMIC_HZ;</span>
<span class="lineNum">    1534 </span><span class="lineCov">        662 :     server.arch_bits = (sizeof(long) == 8) ? 64 : 32;</span>
<span class="lineNum">    1535 </span><span class="lineCov">        662 :     server.port = CONFIG_DEFAULT_SERVER_PORT;</span>
<span class="lineNum">    1536 </span><span class="lineCov">        662 :     server.tcp_backlog = CONFIG_DEFAULT_TCP_BACKLOG;</span>
<span class="lineNum">    1537 </span><span class="lineCov">        662 :     server.bindaddr_count = 0;</span>
<span class="lineNum">    1538 </span><span class="lineCov">        662 :     server.unixsocket = NULL;</span>
<span class="lineNum">    1539 </span><span class="lineCov">        662 :     server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;</span>
<span class="lineNum">    1540 </span><span class="lineCov">        662 :     server.ipfd_count = 0;</span>
<span class="lineNum">    1541 </span><span class="lineCov">        662 :     server.sofd = -1;</span>
<span class="lineNum">    1542 </span><span class="lineCov">        662 :     server.protected_mode = CONFIG_DEFAULT_PROTECTED_MODE;</span>
<span class="lineNum">    1543 </span><span class="lineCov">        662 :     server.dbnum = CONFIG_DEFAULT_DBNUM;</span>
<span class="lineNum">    1544 </span><span class="lineCov">        662 :     server.verbosity = CONFIG_DEFAULT_VERBOSITY;</span>
<span class="lineNum">    1545 </span><span class="lineCov">        662 :     server.maxidletime = CONFIG_DEFAULT_CLIENT_TIMEOUT;</span>
<span class="lineNum">    1546 </span><span class="lineCov">        662 :     server.tcpkeepalive = CONFIG_DEFAULT_TCP_KEEPALIVE;</span>
<span class="lineNum">    1547 </span><span class="lineCov">        662 :     server.active_expire_enabled = 1;</span>
<span class="lineNum">    1548 </span><span class="lineCov">        662 :     server.active_defrag_enabled = CONFIG_DEFAULT_ACTIVE_DEFRAG;</span>
<span class="lineNum">    1549 </span><span class="lineCov">        662 :     server.active_defrag_ignore_bytes = CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES;</span>
<span class="lineNum">    1550 </span><span class="lineCov">        662 :     server.active_defrag_threshold_lower = CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER;</span>
<span class="lineNum">    1551 </span><span class="lineCov">        662 :     server.active_defrag_threshold_upper = CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER;</span>
<span class="lineNum">    1552 </span><span class="lineCov">        662 :     server.active_defrag_cycle_min = CONFIG_DEFAULT_DEFRAG_CYCLE_MIN;</span>
<span class="lineNum">    1553 </span><span class="lineCov">        662 :     server.active_defrag_cycle_max = CONFIG_DEFAULT_DEFRAG_CYCLE_MAX;</span>
<span class="lineNum">    1554 </span><span class="lineCov">        662 :     server.active_defrag_max_scan_fields = CONFIG_DEFAULT_DEFRAG_MAX_SCAN_FIELDS;</span>
<span class="lineNum">    1555 </span><span class="lineCov">        662 :     server.proto_max_bulk_len = CONFIG_DEFAULT_PROTO_MAX_BULK_LEN;</span>
<span class="lineNum">    1556 </span><span class="lineCov">        662 :     server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;</span>
<span class="lineNum">    1557 </span><span class="lineCov">        662 :     server.saveparams = NULL;</span>
<span class="lineNum">    1558 </span><span class="lineCov">        662 :     server.loading = 0;</span>
<span class="lineNum">    1559 </span><span class="lineCov">        662 :     server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);</span>
<span class="lineNum">    1560 </span><span class="lineCov">        662 :     server.syslog_enabled = CONFIG_DEFAULT_SYSLOG_ENABLED;</span>
<span class="lineNum">    1561 </span><span class="lineCov">        662 :     server.syslog_ident = zstrdup(CONFIG_DEFAULT_SYSLOG_IDENT);</span>
<span class="lineNum">    1562 </span><span class="lineCov">        662 :     server.syslog_facility = LOG_LOCAL0;</span>
<span class="lineNum">    1563 </span><span class="lineCov">        662 :     server.daemonize = CONFIG_DEFAULT_DAEMONIZE;</span>
<span class="lineNum">    1564 </span><span class="lineCov">        662 :     server.supervised = 0;</span>
<span class="lineNum">    1565 </span><span class="lineCov">        662 :     server.supervised_mode = SUPERVISED_NONE;</span>
<span class="lineNum">    1566 </span><span class="lineCov">        662 :     server.aof_state = AOF_OFF;</span>
<span class="lineNum">    1567 </span><span class="lineCov">        662 :     server.aof_fsync = CONFIG_DEFAULT_AOF_FSYNC;</span>
<span class="lineNum">    1568 </span><span class="lineCov">        662 :     server.aof_no_fsync_on_rewrite = CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE;</span>
<span class="lineNum">    1569 </span><span class="lineCov">        662 :     server.aof_rewrite_perc = AOF_REWRITE_PERC;</span>
<span class="lineNum">    1570 </span><span class="lineCov">        662 :     server.aof_rewrite_min_size = AOF_REWRITE_MIN_SIZE;</span>
<span class="lineNum">    1571 </span><span class="lineCov">        662 :     server.aof_rewrite_base_size = 0;</span>
<span class="lineNum">    1572 </span><span class="lineCov">        662 :     server.aof_rewrite_scheduled = 0;</span>
<span class="lineNum">    1573 </span><span class="lineCov">        662 :     server.aof_last_fsync = time(NULL);</span>
<span class="lineNum">    1574 </span><span class="lineCov">        662 :     server.aof_rewrite_time_last = -1;</span>
<span class="lineNum">    1575 </span><span class="lineCov">        662 :     server.aof_rewrite_time_start = -1;</span>
<span class="lineNum">    1576 </span><span class="lineCov">        662 :     server.aof_lastbgrewrite_status = C_OK;</span>
<span class="lineNum">    1577 </span><span class="lineCov">        662 :     server.aof_delayed_fsync = 0;</span>
<span class="lineNum">    1578 </span><span class="lineCov">        662 :     server.aof_fd = -1;</span>
<span class="lineNum">    1579 </span><span class="lineCov">        662 :     server.aof_selected_db = -1; /* Make sure the first time will not match */</span>
<span class="lineNum">    1580 </span><span class="lineCov">        662 :     server.aof_flush_postponed_start = 0;</span>
<span class="lineNum">    1581 </span><span class="lineCov">        662 :     server.aof_rewrite_incremental_fsync = CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;</span>
<span class="lineNum">    1582 </span><span class="lineCov">        662 :     server.rdb_save_incremental_fsync = CONFIG_DEFAULT_RDB_SAVE_INCREMENTAL_FSYNC;</span>
<span class="lineNum">    1583 </span><span class="lineCov">        662 :     server.aof_load_truncated = CONFIG_DEFAULT_AOF_LOAD_TRUNCATED;</span>
<span class="lineNum">    1584 </span><span class="lineCov">        662 :     server.aof_use_rdb_preamble = CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE;</span>
<span class="lineNum">    1585 </span><span class="lineCov">        662 :     server.pidfile = NULL;</span>
<span class="lineNum">    1586 </span><span class="lineCov">        662 :     server.rdb_filename = zstrdup(CONFIG_DEFAULT_RDB_FILENAME);</span>
<span class="lineNum">    1587 </span><span class="lineCov">        662 :     server.aof_filename = zstrdup(CONFIG_DEFAULT_AOF_FILENAME);</span>
<span class="lineNum">    1588 </span><span class="lineCov">        662 :     server.requirepass = NULL;</span>
<span class="lineNum">    1589 </span><span class="lineCov">        662 :     server.rdb_compression = CONFIG_DEFAULT_RDB_COMPRESSION;</span>
<span class="lineNum">    1590 </span><span class="lineCov">        662 :     server.rdb_checksum = CONFIG_DEFAULT_RDB_CHECKSUM;</span>
<span class="lineNum">    1591 </span><span class="lineCov">        662 :     server.stop_writes_on_bgsave_err = CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;</span>
<span class="lineNum">    1592 </span><span class="lineCov">        662 :     server.activerehashing = CONFIG_DEFAULT_ACTIVE_REHASHING;</span>
<span class="lineNum">    1593 </span><span class="lineCov">        662 :     server.active_defrag_running = 0;</span>
<span class="lineNum">    1594 </span><span class="lineCov">        662 :     server.notify_keyspace_events = 0;</span>
<span class="lineNum">    1595 </span><span class="lineCov">        662 :     server.maxclients = CONFIG_DEFAULT_MAX_CLIENTS;</span>
<span class="lineNum">    1596 </span><span class="lineCov">        662 :     server.blocked_clients = 0;</span>
<span class="lineNum">    1597 </span><span class="lineCov">        662 :     memset(server.blocked_clients_by_type,0,</span>
<span class="lineNum">    1598 </span>            :            sizeof(server.blocked_clients_by_type));
<span class="lineNum">    1599 </span><span class="lineCov">        662 :     server.maxmemory = CONFIG_DEFAULT_MAXMEMORY;</span>
<span class="lineNum">    1600 </span><span class="lineCov">        662 :     server.maxmemory_policy = CONFIG_DEFAULT_MAXMEMORY_POLICY;</span>
<span class="lineNum">    1601 </span><span class="lineCov">        662 :     server.maxmemory_samples = CONFIG_DEFAULT_MAXMEMORY_SAMPLES;</span>
<span class="lineNum">    1602 </span><span class="lineCov">        662 :     server.lfu_log_factor = CONFIG_DEFAULT_LFU_LOG_FACTOR;</span>
<span class="lineNum">    1603 </span><span class="lineCov">        662 :     server.lfu_decay_time = CONFIG_DEFAULT_LFU_DECAY_TIME;</span>
<span class="lineNum">    1604 </span><span class="lineCov">        662 :     server.hash_max_ziplist_entries = OBJ_HASH_MAX_ZIPLIST_ENTRIES;</span>
<span class="lineNum">    1605 </span><span class="lineCov">        662 :     server.hash_max_ziplist_value = OBJ_HASH_MAX_ZIPLIST_VALUE;</span>
<span class="lineNum">    1606 </span><span class="lineCov">        662 :     server.list_max_ziplist_size = OBJ_LIST_MAX_ZIPLIST_SIZE;</span>
<span class="lineNum">    1607 </span><span class="lineCov">        662 :     server.list_compress_depth = OBJ_LIST_COMPRESS_DEPTH;</span>
<span class="lineNum">    1608 </span><span class="lineCov">        662 :     server.set_max_intset_entries = OBJ_SET_MAX_INTSET_ENTRIES;</span>
<span class="lineNum">    1609 </span><span class="lineCov">        662 :     server.zset_max_ziplist_entries = OBJ_ZSET_MAX_ZIPLIST_ENTRIES;</span>
<span class="lineNum">    1610 </span><span class="lineCov">        662 :     server.zset_max_ziplist_value = OBJ_ZSET_MAX_ZIPLIST_VALUE;</span>
<span class="lineNum">    1611 </span><span class="lineCov">        662 :     server.hll_sparse_max_bytes = CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES;</span>
<span class="lineNum">    1612 </span><span class="lineCov">        662 :     server.stream_node_max_bytes = OBJ_STREAM_NODE_MAX_BYTES;</span>
<span class="lineNum">    1613 </span><span class="lineCov">        662 :     server.stream_node_max_entries = OBJ_STREAM_NODE_MAX_ENTRIES;</span>
<span class="lineNum">    1614 </span><span class="lineCov">        662 :     server.shutdown_asap = 0;</span>
<span class="lineNum">    1615 </span><span class="lineCov">        662 :     server.cluster_enabled = 0;</span>
<span class="lineNum">    1616 </span><span class="lineCov">        662 :     server.cluster_node_timeout = CLUSTER_DEFAULT_NODE_TIMEOUT;</span>
<span class="lineNum">    1617 </span><span class="lineCov">        662 :     server.cluster_migration_barrier = CLUSTER_DEFAULT_MIGRATION_BARRIER;</span>
<span class="lineNum">    1618 </span><span class="lineCov">        662 :     server.cluster_slave_validity_factor = CLUSTER_DEFAULT_SLAVE_VALIDITY;</span>
<span class="lineNum">    1619 </span><span class="lineCov">        662 :     server.cluster_require_full_coverage = CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE;</span>
<span class="lineNum">    1620 </span><span class="lineCov">        662 :     server.cluster_slave_no_failover = CLUSTER_DEFAULT_SLAVE_NO_FAILOVER;</span>
<span class="lineNum">    1621 </span><span class="lineCov">        662 :     server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);</span>
<span class="lineNum">    1622 </span><span class="lineCov">        662 :     server.cluster_announce_ip = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP;</span>
<span class="lineNum">    1623 </span><span class="lineCov">        662 :     server.cluster_announce_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT;</span>
<span class="lineNum">    1624 </span><span class="lineCov">        662 :     server.cluster_announce_bus_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT;</span>
<span class="lineNum">    1625 </span><span class="lineCov">        662 :     server.cluster_module_flags = CLUSTER_MODULE_FLAG_NONE;</span>
<span class="lineNum">    1626 </span><span class="lineCov">        662 :     server.migrate_cached_sockets = dictCreate(&amp;migrateCacheDictType,NULL);</span>
<span class="lineNum">    1627 </span><span class="lineCov">        662 :     server.next_client_id = 1; /* Client IDs, start from 1 .*/</span>
<span class="lineNum">    1628 </span><span class="lineCov">        662 :     server.loading_process_events_interval_bytes = (1024*1024*2);</span>
<span class="lineNum">    1629 </span><span class="lineCov">        662 :     server.lazyfree_lazy_eviction = CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION;</span>
<span class="lineNum">    1630 </span><span class="lineCov">        662 :     server.lazyfree_lazy_expire = CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE;</span>
<span class="lineNum">    1631 </span><span class="lineCov">        662 :     server.lazyfree_lazy_server_del = CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL;</span>
<span class="lineNum">    1632 </span><span class="lineCov">        662 :     server.always_show_logo = CONFIG_DEFAULT_ALWAYS_SHOW_LOGO;</span>
<span class="lineNum">    1633 </span><span class="lineCov">        662 :     server.lua_time_limit = LUA_SCRIPT_TIME_LIMIT;</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineCov">        662 :     unsigned int lruclock = getLRUClock();</span>
<span class="lineNum">    1636 </span><span class="lineCov">        662 :     atomicSet(server.lruclock,lruclock);</span>
<span class="lineNum">    1637 </span><span class="lineCov">        662 :     resetServerSaveParams();</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineCov">        662 :     appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */</span>
<span class="lineNum">    1640 </span><span class="lineCov">        662 :     appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */</span>
<span class="lineNum">    1641 </span><span class="lineCov">        662 :     appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */</span>
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :     /* Replication related */
<span class="lineNum">    1644 </span><span class="lineCov">        662 :     server.masterauth = NULL;</span>
<span class="lineNum">    1645 </span><span class="lineCov">        662 :     server.masterhost = NULL;</span>
<span class="lineNum">    1646 </span><span class="lineCov">        662 :     server.masterport = 6379;</span>
<span class="lineNum">    1647 </span><span class="lineCov">        662 :     server.master = NULL;</span>
<span class="lineNum">    1648 </span><span class="lineCov">        662 :     server.cached_master = NULL;</span>
<span class="lineNum">    1649 </span><span class="lineCov">        662 :     server.master_initial_offset = -1;</span>
<span class="lineNum">    1650 </span><span class="lineCov">        662 :     server.repl_state = REPL_STATE_NONE;</span>
<span class="lineNum">    1651 </span><span class="lineCov">        662 :     server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;</span>
<span class="lineNum">    1652 </span><span class="lineCov">        662 :     server.repl_serve_stale_data = CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA;</span>
<span class="lineNum">    1653 </span><span class="lineCov">        662 :     server.repl_slave_ro = CONFIG_DEFAULT_SLAVE_READ_ONLY;</span>
<span class="lineNum">    1654 </span><span class="lineCov">        662 :     server.repl_slave_ignore_maxmemory = CONFIG_DEFAULT_SLAVE_IGNORE_MAXMEMORY;</span>
<span class="lineNum">    1655 </span><span class="lineCov">        662 :     server.repl_slave_lazy_flush = CONFIG_DEFAULT_SLAVE_LAZY_FLUSH;</span>
<span class="lineNum">    1656 </span><span class="lineCov">        662 :     server.repl_down_since = 0; /* Never connected, repl is down since EVER. */</span>
<span class="lineNum">    1657 </span><span class="lineCov">        662 :     server.repl_disable_tcp_nodelay = CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY;</span>
<span class="lineNum">    1658 </span><span class="lineCov">        662 :     server.repl_diskless_sync = CONFIG_DEFAULT_REPL_DISKLESS_SYNC;</span>
<span class="lineNum">    1659 </span><span class="lineCov">        662 :     server.repl_diskless_sync_delay = CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY;</span>
<span class="lineNum">    1660 </span><span class="lineCov">        662 :     server.repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD;</span>
<span class="lineNum">    1661 </span><span class="lineCov">        662 :     server.repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT;</span>
<span class="lineNum">    1662 </span><span class="lineCov">        662 :     server.repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE;</span>
<span class="lineNum">    1663 </span><span class="lineCov">        662 :     server.repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG;</span>
<span class="lineNum">    1664 </span><span class="lineCov">        662 :     server.slave_priority = CONFIG_DEFAULT_SLAVE_PRIORITY;</span>
<span class="lineNum">    1665 </span><span class="lineCov">        662 :     server.slave_announce_ip = CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP;</span>
<span class="lineNum">    1666 </span><span class="lineCov">        662 :     server.slave_announce_port = CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT;</span>
<span class="lineNum">    1667 </span><span class="lineCov">        662 :     server.master_repl_offset = 0;</span>
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            :     /* Replication partial resync backlog */
<span class="lineNum">    1670 </span><span class="lineCov">        662 :     server.repl_backlog = NULL;</span>
<span class="lineNum">    1671 </span><span class="lineCov">        662 :     server.repl_backlog_size = CONFIG_DEFAULT_REPL_BACKLOG_SIZE;</span>
<span class="lineNum">    1672 </span><span class="lineCov">        662 :     server.repl_backlog_histlen = 0;</span>
<span class="lineNum">    1673 </span><span class="lineCov">        662 :     server.repl_backlog_idx = 0;</span>
<span class="lineNum">    1674 </span><span class="lineCov">        662 :     server.repl_backlog_off = 0;</span>
<span class="lineNum">    1675 </span><span class="lineCov">        662 :     server.repl_backlog_time_limit = CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT;</span>
<span class="lineNum">    1676 </span><span class="lineCov">        662 :     server.repl_no_slaves_since = time(NULL);</span>
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span>            :     /* Client output buffer limits */
<span class="lineNum">    1679 </span><span class="lineCov">       2648 :     for (j = 0; j &lt; CLIENT_TYPE_OBUF_COUNT; j++)</span>
<span class="lineNum">    1680 </span><span class="lineCov">       1986 :         server.client_obuf_limits[j] = clientBufferLimitsDefaults[j];</span>
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :     /* Double constants initialization */
<span class="lineNum">    1683 </span><span class="lineCov">        662 :     R_Zero = 0.0;</span>
<span class="lineNum">    1684 </span><span class="lineCov">        662 :     R_PosInf = 1.0/R_Zero;</span>
<span class="lineNum">    1685 </span><span class="lineCov">        662 :     R_NegInf = -1.0/R_Zero;</span>
<span class="lineNum">    1686 </span><span class="lineCov">        662 :     R_Nan = R_Zero/R_Zero;</span>
<span class="lineNum">    1687 </span>            : 
<span class="lineNum">    1688 </span>            :     /* Command table -- we initiialize it here as it is part of the
<span class="lineNum">    1689 </span>            :      * initial configuration, since command names may be changed via
<span class="lineNum">    1690 </span>            :      * redis.conf using the rename-command directive. */
<span class="lineNum">    1691 </span><span class="lineCov">        662 :     server.commands = dictCreate(&amp;commandTableDictType,NULL);</span>
<span class="lineNum">    1692 </span><span class="lineCov">        662 :     server.orig_commands = dictCreate(&amp;commandTableDictType,NULL);</span>
<span class="lineNum">    1693 </span><span class="lineCov">        662 :     populateCommandTable();</span>
<span class="lineNum">    1694 </span><span class="lineCov">        662 :     server.delCommand = lookupCommandByCString(&quot;del&quot;);</span>
<span class="lineNum">    1695 </span><span class="lineCov">        662 :     server.multiCommand = lookupCommandByCString(&quot;multi&quot;);</span>
<span class="lineNum">    1696 </span><span class="lineCov">        662 :     server.lpushCommand = lookupCommandByCString(&quot;lpush&quot;);</span>
<span class="lineNum">    1697 </span><span class="lineCov">        662 :     server.lpopCommand = lookupCommandByCString(&quot;lpop&quot;);</span>
<span class="lineNum">    1698 </span><span class="lineCov">        662 :     server.rpopCommand = lookupCommandByCString(&quot;rpop&quot;);</span>
<span class="lineNum">    1699 </span><span class="lineCov">        662 :     server.zpopminCommand = lookupCommandByCString(&quot;zpopmin&quot;);</span>
<span class="lineNum">    1700 </span><span class="lineCov">        662 :     server.zpopmaxCommand = lookupCommandByCString(&quot;zpopmax&quot;);</span>
<span class="lineNum">    1701 </span><span class="lineCov">        662 :     server.sremCommand = lookupCommandByCString(&quot;srem&quot;);</span>
<span class="lineNum">    1702 </span><span class="lineCov">        662 :     server.execCommand = lookupCommandByCString(&quot;exec&quot;);</span>
<span class="lineNum">    1703 </span><span class="lineCov">        662 :     server.expireCommand = lookupCommandByCString(&quot;expire&quot;);</span>
<span class="lineNum">    1704 </span><span class="lineCov">        662 :     server.pexpireCommand = lookupCommandByCString(&quot;pexpire&quot;);</span>
<span class="lineNum">    1705 </span><span class="lineCov">        662 :     server.xclaimCommand = lookupCommandByCString(&quot;xclaim&quot;);</span>
<span class="lineNum">    1706 </span><span class="lineCov">        662 :     server.xgroupCommand = lookupCommandByCString(&quot;xgroup&quot;);</span>
<span class="lineNum">    1707 </span>            : 
<span class="lineNum">    1708 </span>            :     /* Slow log */
<span class="lineNum">    1709 </span><span class="lineCov">        662 :     server.slowlog_log_slower_than = CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN;</span>
<span class="lineNum">    1710 </span><span class="lineCov">        662 :     server.slowlog_max_len = CONFIG_DEFAULT_SLOWLOG_MAX_LEN;</span>
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            :     /* Latency monitor */
<span class="lineNum">    1713 </span><span class="lineCov">        662 :     server.latency_monitor_threshold = CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD;</span>
<span class="lineNum">    1714 </span>            : 
<span class="lineNum">    1715 </span>            :     /* Debugging */
<span class="lineNum">    1716 </span><span class="lineCov">        662 :     server.assert_failed = &quot;&lt;no assertion failed&gt;&quot;;</span>
<span class="lineNum">    1717 </span><span class="lineCov">        662 :     server.assert_file = &quot;&lt;no file&gt;&quot;;</span>
<span class="lineNum">    1718 </span><span class="lineCov">        662 :     server.assert_line = 0;</span>
<span class="lineNum">    1719 </span><span class="lineCov">        662 :     server.bug_report_start = 0;</span>
<span class="lineNum">    1720 </span><span class="lineCov">        662 :     server.watchdog_period = 0;</span>
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            :     /* By default we want scripts to be always replicated by effects
<span class="lineNum">    1723 </span>            :      * (single commands executed by the script), and not by sending the
<span class="lineNum">    1724 </span>            :      * script to the slave / AOF. This is the new way starting from
<span class="lineNum">    1725 </span>            :      * Redis 5. However it is possible to revert it via redis.conf. */
<span class="lineNum">    1726 </span><span class="lineCov">        662 :     server.lua_always_replicate_commands = 1;</span>
<span class="lineNum">    1727 </span><span class="lineCov">        662 : }</span>
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            : extern char **environ;
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            : /* Restart the server, executing the same executable that started this
<span class="lineNum">    1732 </span>            :  * instance, with the same arguments and configuration file.
<span class="lineNum">    1733 </span>            :  *
<span class="lineNum">    1734 </span>            :  * The function is designed to directly call execve() so that the new
<span class="lineNum">    1735 </span>            :  * server instance will retain the PID of the previous one.
<span class="lineNum">    1736 </span>            :  *
<span class="lineNum">    1737 </span>            :  * The list of flags, that may be bitwise ORed together, alter the
<span class="lineNum">    1738 </span>            :  * behavior of this function:
<span class="lineNum">    1739 </span>            :  *
<span class="lineNum">    1740 </span>            :  * RESTART_SERVER_NONE              No flags.
<span class="lineNum">    1741 </span>            :  * RESTART_SERVER_GRACEFULLY        Do a proper shutdown before restarting.
<span class="lineNum">    1742 </span>            :  * RESTART_SERVER_CONFIG_REWRITE    Rewrite the config file before restarting.
<span class="lineNum">    1743 </span>            :  *
<a name="1744"><span class="lineNum">    1744 </span>            :  * On success the function does not return, because the process turns into</a>
<span class="lineNum">    1745 </span>            :  * a different process. On error C_ERR is returned. */
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 : int restartServer(int flags, mstime_t delay) {</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :     int j;</span>
<span class="lineNum">    1748 </span>            : 
<span class="lineNum">    1749 </span>            :     /* Check if we still have accesses to the executable that started this
<span class="lineNum">    1750 </span>            :      * server instance. */
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     if (access(server.executable,X_OK) == -1) {</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Can't restart: this process has no &quot;</span>
<span class="lineNum">    1753 </span>            :                              &quot;permissions to execute %s&quot;, server.executable);
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :         return C_ERR;</span>
<span class="lineNum">    1755 </span>            :     }
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span>            :     /* Config rewriting. */
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :     if (flags &amp; RESTART_SERVER_CONFIG_REWRITE &amp;&amp;</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :         server.configfile &amp;&amp;</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :         rewriteConfig(server.configfile) == -1)</span>
<span class="lineNum">    1761 </span>            :     {
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Can't restart: configuration rewrite process &quot;</span>
<span class="lineNum">    1763 </span>            :                              &quot;failed&quot;);
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :         return C_ERR;</span>
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :     /* Perform a proper shutdown. */
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :     if (flags &amp; RESTART_SERVER_GRACEFULLY &amp;&amp;</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :         prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK)</span>
<span class="lineNum">    1770 </span>            :     {
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Can't restart: error preparing for shutdown&quot;);</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :         return C_ERR;</span>
<span class="lineNum">    1773 </span>            :     }
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            :     /* Close all file descriptors, with the exception of stdin, stdout, strerr
<span class="lineNum">    1776 </span>            :      * which are useful if we restart a Redis server which is not daemonized. */
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :     for (j = 3; j &lt; (int)server.maxclients + 1024; j++) {</span>
<span class="lineNum">    1778 </span>            :         /* Test the descriptor validity before closing it, otherwise
<span class="lineNum">    1779 </span>            :          * Valgrind issues a warning on close(). */
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :         if (fcntl(j,F_GETFD) != -1) close(j);</span>
<span class="lineNum">    1781 </span>            :     }
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span>            :     /* Execute the server with the original command line. */
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :     if (delay) usleep(delay*1000);</span>
<span class="lineNum">    1785 </span><span class="lineNoCov">          0 :     zfree(server.exec_argv[0]);</span>
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :     server.exec_argv[0] = zstrdup(server.executable);</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :     execve(server.executable,server.exec_argv,environ);</span>
<span class="lineNum">    1788 </span>            : 
<span class="lineNum">    1789 </span>            :     /* If an error occurred here, there is nothing we can do, but exit. */
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :     _exit(1);</span>
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span>            :     return C_ERR; /* Never reached. */
<span class="lineNum">    1793 </span>            : }
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            : /* This function will try to raise the max number of open files accordingly to
<span class="lineNum">    1796 </span>            :  * the configured max number of clients. It also reserves a number of file
<span class="lineNum">    1797 </span>            :  * descriptors (CONFIG_MIN_RESERVED_FDS) for extra operations of
<span class="lineNum">    1798 </span>            :  * persistence, listening sockets, log files and so forth.
<span class="lineNum">    1799 </span>            :  *
<span class="lineNum">    1800 </span>            :  * If it will not be possible to set the limit accordingly to the configured
<a name="1801"><span class="lineNum">    1801 </span>            :  * max number of clients, the function will do the reverse setting</a>
<span class="lineNum">    1802 </span>            :  * server.maxclients to the value that we can actually handle. */
<span class="lineNum">    1803 </span><span class="lineCov">        656 : void adjustOpenFilesLimit(void) {</span>
<span class="lineNum">    1804 </span><span class="lineCov">        656 :     rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;</span>
<span class="lineNum">    1805 </span><span class="lineCov">        656 :     struct rlimit limit;</span>
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span><span class="lineCov">        656 :     if (getrlimit(RLIMIT_NOFILE,&amp;limit) == -1) {</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly.&quot;,</span>
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :             strerror(errno));</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :         server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;</span>
<span class="lineNum">    1811 </span>            :     } else {
<span class="lineNum">    1812 </span><span class="lineCov">        656 :         rlim_t oldlimit = limit.rlim_cur;</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            :         /* Set the max number of files if the current limit is not enough
<span class="lineNum">    1815 </span>            :          * for our needs. */
<span class="lineNum">    1816 </span><span class="lineCov">        656 :         if (oldlimit &lt; maxfiles) {</span>
<span class="lineNum">    1817 </span>            :             rlim_t bestlimit;
<span class="lineNum">    1818 </span>            :             int setrlimit_error = 0;
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            :             /* Try to set the file limit to match 'maxfiles' or at least
<span class="lineNum">    1821 </span>            :              * to the higher value supported less than maxfiles. */
<span class="lineNum">    1822 </span>            :             bestlimit = maxfiles;
<span class="lineNum">    1823 </span><span class="lineCov">     242172 :             while(bestlimit &gt; oldlimit) {</span>
<span class="lineNum">    1824 </span><span class="lineCov">     242172 :                 rlim_t decr_step = 16;</span>
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span><span class="lineCov">     242172 :                 limit.rlim_cur = bestlimit;</span>
<span class="lineNum">    1827 </span><span class="lineCov">     242172 :                 limit.rlim_max = bestlimit;</span>
<span class="lineNum">    1828 </span><span class="lineCov">     242172 :                 if (setrlimit(RLIMIT_NOFILE,&amp;limit) != -1) break;</span>
<span class="lineNum">    1829 </span><span class="lineCov">     241521 :                 setrlimit_error = errno;</span>
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :                 /* We failed to set file limit to 'bestlimit'. Try with a
<span class="lineNum">    1832 </span>            :                  * smaller limit decrementing by a few FDs per iteration. */
<span class="lineNum">    1833 </span><span class="lineCov">     241521 :                 if (bestlimit &lt; decr_step) break;</span>
<span class="lineNum">    1834 </span><span class="lineCov">     241521 :                 bestlimit -= decr_step;</span>
<span class="lineNum">    1835 </span>            :             }
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :             /* Assume that the limit we get initially is still valid if
<span class="lineNum">    1838 </span>            :              * our last try was even lower. */
<span class="lineNum">    1839 </span><span class="lineCov">        651 :             if (bestlimit &lt; oldlimit) bestlimit = oldlimit;</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineCov">        651 :             if (bestlimit &lt; maxfiles) {</span>
<span class="lineNum">    1842 </span><span class="lineCov">        651 :                 unsigned int old_maxclients = server.maxclients;</span>
<span class="lineNum">    1843 </span><span class="lineCov">        651 :                 server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;</span>
<span class="lineNum">    1844 </span>            :                 /* maxclients is unsigned so may overflow: in order
<span class="lineNum">    1845 </span>            :                  * to check if maxclients is now logically less than 1
<span class="lineNum">    1846 </span>            :                  * we test indirectly via bestlimit. */
<span class="lineNum">    1847 </span><span class="lineCov">        651 :                 if (bestlimit &lt;= CONFIG_MIN_RESERVED_FDS) {</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :                     serverLog(LL_WARNING,&quot;Your current 'ulimit -n' &quot;</span>
<span class="lineNum">    1849 </span>            :                         &quot;of %llu is not enough for the server to start. &quot;
<span class="lineNum">    1850 </span>            :                         &quot;Please increase your open file limit to at least &quot;
<span class="lineNum">    1851 </span>            :                         &quot;%llu. Exiting.&quot;,
<span class="lineNum">    1852 </span>            :                         (unsigned long long) oldlimit,
<span class="lineNum">    1853 </span>            :                         (unsigned long long) maxfiles);
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :                     exit(1);</span>
<span class="lineNum">    1855 </span>            :                 }
<span class="lineNum">    1856 </span><span class="lineCov">        651 :                 serverLog(LL_WARNING,&quot;You requested maxclients of %d &quot;</span>
<span class="lineNum">    1857 </span>            :                     &quot;requiring at least %llu max file descriptors.&quot;,
<span class="lineNum">    1858 </span>            :                     old_maxclients,
<span class="lineNum">    1859 </span>            :                     (unsigned long long) maxfiles);
<span class="lineNum">    1860 </span><span class="lineCov">        651 :                 serverLog(LL_WARNING,&quot;Server can't set maximum open files &quot;</span>
<span class="lineNum">    1861 </span>            :                     &quot;to %llu because of OS error: %s.&quot;,
<span class="lineNum">    1862 </span>            :                     (unsigned long long) maxfiles, strerror(setrlimit_error));
<span class="lineNum">    1863 </span><span class="lineCov">        651 :                 serverLog(LL_WARNING,&quot;Current maximum open files is %llu. &quot;</span>
<span class="lineNum">    1864 </span>            :                     &quot;maxclients has been reduced to %d to compensate for &quot;
<span class="lineNum">    1865 </span>            :                     &quot;low ulimit. &quot;
<span class="lineNum">    1866 </span>            :                     &quot;If you need higher maxclients increase 'ulimit -n'.&quot;,
<span class="lineNum">    1867 </span>            :                     (unsigned long long) bestlimit, server.maxclients);
<span class="lineNum">    1868 </span>            :             } else {
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :                 serverLog(LL_NOTICE,&quot;Increased maximum number of open files &quot;</span>
<span class="lineNum">    1870 </span>            :                     &quot;to %llu (it was originally set to %llu).&quot;,
<span class="lineNum">    1871 </span>            :                     (unsigned long long) maxfiles,
<span class="lineNum">    1872 </span>            :                     (unsigned long long) oldlimit);
<span class="lineNum">    1873 </span>            :             }
<span class="lineNum">    1874 </span>            :         }
<span class="lineNum">    1875 </span>            :     }
<span class="lineNum">    1876 </span><span class="lineCov">        656 : }</span>
<span class="lineNum">    1877 </span>            : 
<a name="1878"><span class="lineNum">    1878 </span>            : /* Check that server.tcp_backlog can be actually enforced in Linux according</a>
<span class="lineNum">    1879 </span>            :  * to the value of /proc/sys/net/core/somaxconn, or warn about it. */
<span class="lineNum">    1880 </span><span class="lineCov">        656 : void checkTcpBacklogSettings(void) {</span>
<span class="lineNum">    1881 </span>            : #ifdef HAVE_PROC_SOMAXCONN
<span class="lineNum">    1882 </span><span class="lineCov">        656 :     FILE *fp = fopen(&quot;/proc/sys/net/core/somaxconn&quot;,&quot;r&quot;);</span>
<span class="lineNum">    1883 </span><span class="lineCov">        656 :     char buf[1024];</span>
<span class="lineNum">    1884 </span><span class="lineCov">        656 :     if (!fp) return;</span>
<span class="lineNum">    1885 </span><span class="lineCov">        656 :     if (fgets(buf,sizeof(buf),fp) != NULL) {</span>
<span class="lineNum">    1886 </span><span class="lineCov">        656 :         int somaxconn = atoi(buf);</span>
<span class="lineNum">    1887 </span><span class="lineCov">        656 :         if (somaxconn &gt; 0 &amp;&amp; somaxconn &lt; server.tcp_backlog) {</span>
<span class="lineNum">    1888 </span><span class="lineCov">        656 :             serverLog(LL_WARNING,&quot;WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d.&quot;, server.tcp_backlog, somaxconn);</span>
<span class="lineNum">    1889 </span>            :         }
<span class="lineNum">    1890 </span>            :     }
<span class="lineNum">    1891 </span><span class="lineCov">        656 :     fclose(fp);</span>
<span class="lineNum">    1892 </span>            : #endif
<span class="lineNum">    1893 </span>            : }
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            : /* Initialize a set of file descriptors to listen to the specified 'port'
<span class="lineNum">    1896 </span>            :  * binding the addresses specified in the Redis server configuration.
<span class="lineNum">    1897 </span>            :  *
<span class="lineNum">    1898 </span>            :  * The listening file descriptors are stored in the integer array 'fds'
<span class="lineNum">    1899 </span>            :  * and their number is set in '*count'.
<span class="lineNum">    1900 </span>            :  *
<span class="lineNum">    1901 </span>            :  * The addresses to bind are specified in the global server.bindaddr array
<span class="lineNum">    1902 </span>            :  * and their number is server.bindaddr_count. If the server configuration
<span class="lineNum">    1903 </span>            :  * contains no specific addresses to bind, this function will try to
<span class="lineNum">    1904 </span>            :  * bind * (all addresses) for both the IPv4 and IPv6 protocols.
<span class="lineNum">    1905 </span>            :  *
<span class="lineNum">    1906 </span>            :  * On success the function returns C_OK.
<span class="lineNum">    1907 </span>            :  *
<span class="lineNum">    1908 </span>            :  * On error the function returns C_ERR. For the function to be on
<span class="lineNum">    1909 </span>            :  * error, at least one of the server.bindaddr addresses was
<span class="lineNum">    1910 </span>            :  * impossible to bind, or no bind addresses were specified in the server
<a name="1911"><span class="lineNum">    1911 </span>            :  * configuration but the function is not able to bind * for at least</a>
<span class="lineNum">    1912 </span>            :  * one of the IPv4 or IPv6 protocols. */
<span class="lineNum">    1913 </span><span class="lineCov">        656 : int listenToPort(int port, int *fds, int *count) {</span>
<span class="lineNum">    1914 </span><span class="lineCov">        656 :     int j;</span>
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            :     /* Force binding of 0.0.0.0 if no bind address is specified, always
<span class="lineNum">    1917 </span>            :      * entering the loop if j == 0. */
<span class="lineNum">    1918 </span><span class="lineCov">        656 :     if (server.bindaddr_count == 0) server.bindaddr[0] = NULL;</span>
<span class="lineNum">    1919 </span><span class="lineCov">       1312 :     for (j = 0; j &lt; server.bindaddr_count || j == 0; j++) {</span>
<span class="lineNum">    1920 </span><span class="lineCov">        656 :         if (server.bindaddr[j] == NULL) {</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :             int unsupported = 0;</span>
<span class="lineNum">    1922 </span>            :             /* Bind * for both IPv6 and IPv4, we enter here only if
<span class="lineNum">    1923 </span>            :              * server.bindaddr_count == 0. */
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :             fds[*count] = anetTcp6Server(server.neterr,port,NULL,</span>
<span class="lineNum">    1925 </span>            :                 server.tcp_backlog);
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :             if (fds[*count] != ANET_ERR) {</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :                 anetNonBlock(NULL,fds[*count]);</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :                 (*count)++;</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :             } else if (errno == EAFNOSUPPORT) {</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                 unsupported++;</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING,&quot;Not listening to IPv6: unsupproted&quot;);</span>
<span class="lineNum">    1932 </span>            :             }
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :             if (*count == 1 || unsupported) {</span>
<span class="lineNum">    1935 </span>            :                 /* Bind the IPv4 address as well. */
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :                 fds[*count] = anetTcpServer(server.neterr,port,NULL,</span>
<span class="lineNum">    1937 </span>            :                     server.tcp_backlog);
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                 if (fds[*count] != ANET_ERR) {</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :                     anetNonBlock(NULL,fds[*count]);</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                     (*count)++;</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :                 } else if (errno == EAFNOSUPPORT) {</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                     unsupported++;</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                     serverLog(LL_WARNING,&quot;Not listening to IPv4: unsupproted&quot;);</span>
<span class="lineNum">    1944 </span>            :                 }
<span class="lineNum">    1945 </span>            :             }
<span class="lineNum">    1946 </span>            :             /* Exit the loop if we were able to bind * on IPv4 and IPv6,
<span class="lineNum">    1947 </span>            :              * otherwise fds[*count] will be ANET_ERR and we'll print an
<span class="lineNum">    1948 </span>            :              * error and return to the caller with an error. */
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :             if (*count + unsupported == 2) break;</span>
<span class="lineNum">    1950 </span><span class="lineCov">        656 :         } else if (strchr(server.bindaddr[j],':')) {</span>
<span class="lineNum">    1951 </span>            :             /* Bind IPv6 address. */
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :             fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],</span>
<span class="lineNum">    1953 </span>            :                 server.tcp_backlog);
<span class="lineNum">    1954 </span>            :         } else {
<span class="lineNum">    1955 </span>            :             /* Bind IPv4 address. */
<span class="lineNum">    1956 </span><span class="lineCov">        656 :             fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],</span>
<span class="lineNum">    1957 </span>            :                 server.tcp_backlog);
<span class="lineNum">    1958 </span>            :         }
<span class="lineNum">    1959 </span><span class="lineCov">        656 :         if (fds[*count] == ANET_ERR) {</span>
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,</span>
<span class="lineNum">    1961 </span>            :                 &quot;Could not create server TCP listening socket %s:%d: %s&quot;,
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :                 server.bindaddr[j] ? server.bindaddr[j] : &quot;*&quot;,</span>
<span class="lineNum">    1963 </span>            :                 port, server.neterr);
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :                 if (errno == ENOPROTOOPT     || errno == EPROTONOSUPPORT ||</span>
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :                     errno == ESOCKTNOSUPPORT || errno == EPFNOSUPPORT ||</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :                     errno == EAFNOSUPPORT    || errno == EADDRNOTAVAIL)</span>
<span class="lineNum">    1967 </span>            :                     continue;
<span class="lineNum">    1968 </span>            :             return C_ERR;
<span class="lineNum">    1969 </span>            :         }
<span class="lineNum">    1970 </span><span class="lineCov">        656 :         anetNonBlock(NULL,fds[*count]);</span>
<span class="lineNum">    1971 </span><span class="lineCov">        656 :         (*count)++;</span>
<span class="lineNum">    1972 </span>            :     }
<span class="lineNum">    1973 </span>            :     return C_OK;
<span class="lineNum">    1974 </span>            : }
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : /* Resets the stats that we expose via INFO or other means that we want
<a name="1977"><span class="lineNum">    1977 </span>            :  * to reset via CONFIG RESETSTAT. The function is also used in order to</a>
<span class="lineNum">    1978 </span>            :  * initialize these fields in initServer() at server startup. */
<span class="lineNum">    1979 </span><span class="lineCov">        668 : void resetServerStats(void) {</span>
<span class="lineNum">    1980 </span><span class="lineCov">        668 :     int j;</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineCov">        668 :     server.stat_numcommands = 0;</span>
<span class="lineNum">    1983 </span><span class="lineCov">        668 :     server.stat_numconnections = 0;</span>
<span class="lineNum">    1984 </span><span class="lineCov">        668 :     server.stat_expiredkeys = 0;</span>
<span class="lineNum">    1985 </span><span class="lineCov">        668 :     server.stat_expired_stale_perc = 0;</span>
<span class="lineNum">    1986 </span><span class="lineCov">        668 :     server.stat_expired_time_cap_reached_count = 0;</span>
<span class="lineNum">    1987 </span><span class="lineCov">        668 :     server.stat_evictedkeys = 0;</span>
<span class="lineNum">    1988 </span><span class="lineCov">        668 :     server.stat_keyspace_misses = 0;</span>
<span class="lineNum">    1989 </span><span class="lineCov">        668 :     server.stat_keyspace_hits = 0;</span>
<span class="lineNum">    1990 </span><span class="lineCov">        668 :     server.stat_active_defrag_hits = 0;</span>
<span class="lineNum">    1991 </span><span class="lineCov">        668 :     server.stat_active_defrag_misses = 0;</span>
<span class="lineNum">    1992 </span><span class="lineCov">        668 :     server.stat_active_defrag_key_hits = 0;</span>
<span class="lineNum">    1993 </span><span class="lineCov">        668 :     server.stat_active_defrag_key_misses = 0;</span>
<span class="lineNum">    1994 </span><span class="lineCov">        668 :     server.stat_active_defrag_scanned = 0;</span>
<span class="lineNum">    1995 </span><span class="lineCov">        668 :     server.stat_fork_time = 0;</span>
<span class="lineNum">    1996 </span><span class="lineCov">        668 :     server.stat_fork_rate = 0;</span>
<span class="lineNum">    1997 </span><span class="lineCov">        668 :     server.stat_rejected_conn = 0;</span>
<span class="lineNum">    1998 </span><span class="lineCov">        668 :     server.stat_sync_full = 0;</span>
<span class="lineNum">    1999 </span><span class="lineCov">        668 :     server.stat_sync_partial_ok = 0;</span>
<span class="lineNum">    2000 </span><span class="lineCov">        668 :     server.stat_sync_partial_err = 0;</span>
<span class="lineNum">    2001 </span><span class="lineCov">       2672 :     for (j = 0; j &lt; STATS_METRIC_COUNT; j++) {</span>
<span class="lineNum">    2002 </span><span class="lineCov">       2004 :         server.inst_metric[j].idx = 0;</span>
<span class="lineNum">    2003 </span><span class="lineCov">       2004 :         server.inst_metric[j].last_sample_time = mstime();</span>
<span class="lineNum">    2004 </span><span class="lineCov">       2004 :         server.inst_metric[j].last_sample_count = 0;</span>
<span class="lineNum">    2005 </span><span class="lineCov">       4008 :         memset(server.inst_metric[j].samples,0,</span>
<span class="lineNum">    2006 </span>            :             sizeof(server.inst_metric[j].samples));
<span class="lineNum">    2007 </span>            :     }
<span class="lineNum">    2008 </span><span class="lineCov">        668 :     server.stat_net_input_bytes = 0;</span>
<span class="lineNum">    2009 </span><span class="lineCov">        668 :     server.stat_net_output_bytes = 0;</span>
<span class="lineNum">    2010 </span><span class="lineCov">        668 :     server.aof_delayed_fsync = 0;</span>
<a name="2011"><span class="lineNum">    2011 </span><span class="lineCov">        668 : }</span></a>
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span><span class="lineCov">        656 : void initServer(void) {</span>
<span class="lineNum">    2014 </span><span class="lineCov">        656 :     int j;</span>
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span><span class="lineCov">        656 :     signal(SIGHUP, SIG_IGN);</span>
<span class="lineNum">    2017 </span><span class="lineCov">        656 :     signal(SIGPIPE, SIG_IGN);</span>
<span class="lineNum">    2018 </span><span class="lineCov">        656 :     setupSignalHandlers();</span>
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span><span class="lineCov">        656 :     if (server.syslog_enabled) {</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :         openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span>
<span class="lineNum">    2022 </span>            :             server.syslog_facility);
<span class="lineNum">    2023 </span>            :     }
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineCov">        656 :     server.hz = server.config_hz;</span>
<span class="lineNum">    2026 </span><span class="lineCov">        656 :     server.pid = getpid();</span>
<span class="lineNum">    2027 </span><span class="lineCov">        656 :     server.current_client = NULL;</span>
<span class="lineNum">    2028 </span><span class="lineCov">        656 :     server.clients = listCreate();</span>
<span class="lineNum">    2029 </span><span class="lineCov">        656 :     server.clients_index = raxNew();</span>
<span class="lineNum">    2030 </span><span class="lineCov">        656 :     server.clients_to_close = listCreate();</span>
<span class="lineNum">    2031 </span><span class="lineCov">        656 :     server.slaves = listCreate();</span>
<span class="lineNum">    2032 </span><span class="lineCov">        656 :     server.monitors = listCreate();</span>
<span class="lineNum">    2033 </span><span class="lineCov">        656 :     server.clients_pending_write = listCreate();</span>
<span class="lineNum">    2034 </span><span class="lineCov">        656 :     server.slaveseldb = -1; /* Force to emit the first SELECT command. */</span>
<span class="lineNum">    2035 </span><span class="lineCov">        656 :     server.unblocked_clients = listCreate();</span>
<span class="lineNum">    2036 </span><span class="lineCov">        656 :     server.ready_keys = listCreate();</span>
<span class="lineNum">    2037 </span><span class="lineCov">        656 :     server.clients_waiting_acks = listCreate();</span>
<span class="lineNum">    2038 </span><span class="lineCov">        656 :     server.get_ack_from_slaves = 0;</span>
<span class="lineNum">    2039 </span><span class="lineCov">        656 :     server.clients_paused = 0;</span>
<span class="lineNum">    2040 </span><span class="lineCov">        656 :     server.system_memory_size = zmalloc_get_memory_size();</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineCov">        656 :     createSharedObjects();</span>
<span class="lineNum">    2043 </span><span class="lineCov">        656 :     adjustOpenFilesLimit();</span>
<span class="lineNum">    2044 </span><span class="lineCov">        656 :     server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span>
<span class="lineNum">    2045 </span><span class="lineCov">        656 :     if (server.el == NULL) {</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    2047 </span>            :             &quot;Failed creating the event loop. Error message: '%s'&quot;,
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :             strerror(errno));</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :         exit(1);</span>
<span class="lineNum">    2050 </span>            :     }
<span class="lineNum">    2051 </span><span class="lineCov">        656 :     server.db = zmalloc(sizeof(redisDb)*server.dbnum);</span>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :     /* Open the TCP listening socket for the user commands. */
<span class="lineNum">    2054 </span><span class="lineCov">       1312 :     if (server.port != 0 &amp;&amp;</span>
<span class="lineNum">    2055 </span><span class="lineCov">        656 :         listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         exit(1);</span>
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span>            :     /* Open the listening Unix domain socket. */
<span class="lineNum">    2059 </span><span class="lineCov">        656 :     if (server.unixsocket != NULL) {</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :         unlink(server.unixsocket); /* don't care if this fails */</span>
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         server.sofd = anetUnixServer(server.neterr,server.unixsocket,</span>
<span class="lineNum">    2062 </span>            :             server.unixsocketperm, server.tcp_backlog);
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :         if (server.sofd == ANET_ERR) {</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING, &quot;Opening Unix socket: %s&quot;, server.neterr);</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :             exit(1);</span>
<span class="lineNum">    2066 </span>            :         }
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :         anetNonBlock(NULL,server.sofd);</span>
<span class="lineNum">    2068 </span>            :     }
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :     /* Abort if there are no listening sockets at all. */
<span class="lineNum">    2071 </span><span class="lineCov">        656 :     if (server.ipfd_count == 0 &amp;&amp; server.sofd &lt; 0) {</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING, &quot;Configured to not listen anywhere, exiting.&quot;);</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         exit(1);</span>
<span class="lineNum">    2074 </span>            :     }
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span>            :     /* Create the Redis databases, and initialize other internal state. */
<span class="lineNum">    2077 </span><span class="lineCov">      11152 :     for (j = 0; j &lt; server.dbnum; j++) {</span>
<span class="lineNum">    2078 </span><span class="lineCov">      10496 :         server.db[j].dict = dictCreate(&amp;dbDictType,NULL);</span>
<span class="lineNum">    2079 </span><span class="lineCov">      10496 :         server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL);</span>
<span class="lineNum">    2080 </span><span class="lineCov">      10496 :         server.db[j].blocking_keys = dictCreate(&amp;keylistDictType,NULL);</span>
<span class="lineNum">    2081 </span><span class="lineCov">      10496 :         server.db[j].ready_keys = dictCreate(&amp;objectKeyPointerValueDictType,NULL);</span>
<span class="lineNum">    2082 </span><span class="lineCov">      10496 :         server.db[j].watched_keys = dictCreate(&amp;keylistDictType,NULL);</span>
<span class="lineNum">    2083 </span><span class="lineCov">      10496 :         server.db[j].id = j;</span>
<span class="lineNum">    2084 </span><span class="lineCov">      10496 :         server.db[j].avg_ttl = 0;</span>
<span class="lineNum">    2085 </span><span class="lineCov">      10496 :         server.db[j].defrag_later = listCreate();</span>
<span class="lineNum">    2086 </span>            :     }
<span class="lineNum">    2087 </span><span class="lineCov">        656 :     evictionPoolAlloc(); /* Initialize the LRU keys pool. */</span>
<span class="lineNum">    2088 </span><span class="lineCov">        656 :     server.pubsub_channels = dictCreate(&amp;keylistDictType,NULL);</span>
<span class="lineNum">    2089 </span><span class="lineCov">        656 :     server.pubsub_patterns = listCreate();</span>
<span class="lineNum">    2090 </span><span class="lineCov">        656 :     listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);</span>
<span class="lineNum">    2091 </span><span class="lineCov">        656 :     listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);</span>
<span class="lineNum">    2092 </span><span class="lineCov">        656 :     server.cronloops = 0;</span>
<span class="lineNum">    2093 </span><span class="lineCov">        656 :     server.rdb_child_pid = -1;</span>
<span class="lineNum">    2094 </span><span class="lineCov">        656 :     server.aof_child_pid = -1;</span>
<span class="lineNum">    2095 </span><span class="lineCov">        656 :     server.rdb_child_type = RDB_CHILD_TYPE_NONE;</span>
<span class="lineNum">    2096 </span><span class="lineCov">        656 :     server.rdb_bgsave_scheduled = 0;</span>
<span class="lineNum">    2097 </span><span class="lineCov">        656 :     server.child_info_pipe[0] = -1;</span>
<span class="lineNum">    2098 </span><span class="lineCov">        656 :     server.child_info_pipe[1] = -1;</span>
<span class="lineNum">    2099 </span><span class="lineCov">        656 :     server.child_info_data.magic = 0;</span>
<span class="lineNum">    2100 </span><span class="lineCov">        656 :     aofRewriteBufferReset();</span>
<span class="lineNum">    2101 </span><span class="lineCov">        656 :     server.aof_buf = sdsempty();</span>
<span class="lineNum">    2102 </span><span class="lineCov">        656 :     server.lastsave = time(NULL); /* At startup we consider the DB saved. */</span>
<span class="lineNum">    2103 </span><span class="lineCov">        656 :     server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */</span>
<span class="lineNum">    2104 </span><span class="lineCov">        656 :     server.rdb_save_time_last = -1;</span>
<span class="lineNum">    2105 </span><span class="lineCov">        656 :     server.rdb_save_time_start = -1;</span>
<span class="lineNum">    2106 </span><span class="lineCov">        656 :     server.dirty = 0;</span>
<span class="lineNum">    2107 </span><span class="lineCov">        656 :     resetServerStats();</span>
<span class="lineNum">    2108 </span>            :     /* A few stats we don't want to reset: server startup time, and peak mem. */
<span class="lineNum">    2109 </span><span class="lineCov">        656 :     server.stat_starttime = time(NULL);</span>
<span class="lineNum">    2110 </span><span class="lineCov">        656 :     server.stat_peak_memory = 0;</span>
<span class="lineNum">    2111 </span><span class="lineCov">        656 :     server.stat_rdb_cow_bytes = 0;</span>
<span class="lineNum">    2112 </span><span class="lineCov">        656 :     server.stat_aof_cow_bytes = 0;</span>
<span class="lineNum">    2113 </span><span class="lineCov">        656 :     server.cron_malloc_stats.zmalloc_used = 0;</span>
<span class="lineNum">    2114 </span><span class="lineCov">        656 :     server.cron_malloc_stats.process_rss = 0;</span>
<span class="lineNum">    2115 </span><span class="lineCov">        656 :     server.cron_malloc_stats.allocator_allocated = 0;</span>
<span class="lineNum">    2116 </span><span class="lineCov">        656 :     server.cron_malloc_stats.allocator_active = 0;</span>
<span class="lineNum">    2117 </span><span class="lineCov">        656 :     server.cron_malloc_stats.allocator_resident = 0;</span>
<span class="lineNum">    2118 </span><span class="lineCov">        656 :     server.lastbgsave_status = C_OK;</span>
<span class="lineNum">    2119 </span><span class="lineCov">        656 :     server.aof_last_write_status = C_OK;</span>
<span class="lineNum">    2120 </span><span class="lineCov">        656 :     server.aof_last_write_errno = 0;</span>
<span class="lineNum">    2121 </span><span class="lineCov">        656 :     server.repl_good_slaves_count = 0;</span>
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span>            :     /* Create the timer callback, this is our way to process many background
<span class="lineNum">    2124 </span>            :      * operations incrementally, like clients timeout, eviction of unaccessed
<span class="lineNum">    2125 </span>            :      * expired keys and so forth. */
<span class="lineNum">    2126 </span><span class="lineCov">        656 :     if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {</span>
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :         serverPanic(&quot;Can't create event loop timers.&quot;);</span>
<span class="lineNum">    2128 </span>            :         exit(1);
<span class="lineNum">    2129 </span>            :     }
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span>            :     /* Create an event handler for accepting new connections in TCP and Unix
<span class="lineNum">    2132 </span>            :      * domain sockets. */
<span class="lineNum">    2133 </span><span class="lineCov">       1312 :     for (j = 0; j &lt; server.ipfd_count; j++) {</span>
<span class="lineNum">    2134 </span><span class="lineCov">        656 :         if (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span>
<span class="lineNum">    2135 </span>            :             acceptTcpHandler,NULL) == AE_ERR)
<span class="lineNum">    2136 </span>            :             {
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :                 serverPanic(</span>
<span class="lineNum">    2138 </span>            :                     &quot;Unrecoverable error creating server.ipfd file event.&quot;);
<span class="lineNum">    2139 </span>            :             }
<span class="lineNum">    2140 </span>            :     }
<span class="lineNum">    2141 </span><span class="lineCov">        656 :     if (server.sofd &gt; 0 &amp;&amp; aeCreateFileEvent(server.el,server.sofd,AE_READABLE,</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :         acceptUnixHandler,NULL) == AE_ERR) serverPanic(&quot;Unrecoverable error creating server.sofd file event.&quot;);</span>
<span class="lineNum">    2143 </span>            : 
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span>            :     /* Register a readable event for the pipe used to awake the event loop
<span class="lineNum">    2146 </span>            :      * when a blocked client in a module needs attention. */
<span class="lineNum">    2147 </span><span class="lineCov">        656 :     if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,</span>
<span class="lineNum">    2148 </span>            :         moduleBlockedClientPipeReadable,NULL) == AE_ERR) {
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :             serverPanic(</span>
<span class="lineNum">    2150 </span>            :                 &quot;Error registering the readable event for the module &quot;
<span class="lineNum">    2151 </span>            :                 &quot;blocked clients subsystem.&quot;);
<span class="lineNum">    2152 </span>            :     }
<span class="lineNum">    2153 </span>            : 
<span class="lineNum">    2154 </span>            :     /* Open the AOF file if needed. */
<span class="lineNum">    2155 </span><span class="lineCov">        656 :     if (server.aof_state == AOF_ON) {</span>
<span class="lineNum">    2156 </span><span class="lineCov">         55 :         server.aof_fd = open(server.aof_filename,</span>
<span class="lineNum">    2157 </span>            :                                O_WRONLY|O_APPEND|O_CREAT,0644);
<span class="lineNum">    2158 </span><span class="lineCov">         55 :         if (server.aof_fd == -1) {</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING, &quot;Can't open the append-only file: %s&quot;,</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :                 strerror(errno));</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :             exit(1);</span>
<span class="lineNum">    2162 </span>            :         }
<span class="lineNum">    2163 </span>            :     }
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            :     /* 32 bit instances are limited to 4GB of address space, so if there is
<span class="lineNum">    2166 </span>            :      * no explicit limit in the user provided configuration we set a limit
<span class="lineNum">    2167 </span>            :      * at 3 GB using maxmemory with 'noeviction' policy'. This avoids
<span class="lineNum">    2168 </span>            :      * useless crashes of the Redis instance for out of memory. */
<span class="lineNum">    2169 </span><span class="lineCov">        656 :     if (server.arch_bits == 32 &amp;&amp; server.maxmemory == 0) {</span>
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;Warning: 32 bit instance detected but no memory limit set. Setting 3 GB maxmemory limit with 'noeviction' policy now.&quot;);</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :         server.maxmemory = 3072LL*(1024*1024); /* 3 GB */</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         server.maxmemory_policy = MAXMEMORY_NO_EVICTION;</span>
<span class="lineNum">    2173 </span>            :     }
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span><span class="lineCov">        656 :     if (server.cluster_enabled) clusterInit();</span>
<span class="lineNum">    2176 </span><span class="lineCov">        656 :     replicationScriptCacheInit();</span>
<span class="lineNum">    2177 </span><span class="lineCov">        656 :     scriptingInit(1);</span>
<span class="lineNum">    2178 </span><span class="lineCov">        656 :     slowlogInit();</span>
<span class="lineNum">    2179 </span><span class="lineCov">        656 :     latencyMonitorInit();</span>
<span class="lineNum">    2180 </span><span class="lineCov">        656 :     bioInit();</span>
<span class="lineNum">    2181 </span><span class="lineCov">        656 :     server.initial_memory_usage = zmalloc_used_memory();</span>
<span class="lineNum">    2182 </span><span class="lineCov">        656 : }</span>
<span class="lineNum">    2183 </span>            : 
<a name="2184"><span class="lineNum">    2184 </span>            : /* Populates the Redis Command Table starting from the hard coded list</a>
<span class="lineNum">    2185 </span>            :  * we have on top of redis.c file. */
<span class="lineNum">    2186 </span><span class="lineCov">        662 : void populateCommandTable(void) {</span>
<span class="lineNum">    2187 </span><span class="lineCov">        662 :     int j;</span>
<span class="lineNum">    2188 </span><span class="lineCov">        662 :     int numcommands = sizeof(redisCommandTable)/sizeof(struct redisCommand);</span>
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span><span class="lineCov">     133062 :     for (j = 0; j &lt; numcommands; j++) {</span>
<span class="lineNum">    2191 </span><span class="lineCov">     132400 :         struct redisCommand *c = redisCommandTable+j;</span>
<span class="lineNum">    2192 </span><span class="lineCov">     132400 :         char *f = c-&gt;sflags;</span>
<span class="lineNum">    2193 </span><span class="lineCov">     132400 :         int retval1, retval2;</span>
<span class="lineNum">    2194 </span>            : 
<span class="lineNum">    2195 </span><span class="lineCov">     408454 :         while(*f != '\0') {</span>
<span class="lineNum">    2196 </span><span class="lineCov">     276054 :             switch(*f) {</span>
<span class="lineNum">    2197 </span><span class="lineCov">      57594 :             case 'w': c-&gt;flags |= CMD_WRITE; break;</span>
<span class="lineNum">    2198 </span><span class="lineCov">      45016 :             case 'r': c-&gt;flags |= CMD_READONLY; break;</span>
<span class="lineNum">    2199 </span><span class="lineCov">      31114 :             case 'm': c-&gt;flags |= CMD_DENYOOM; break;</span>
<span class="lineNum">    2200 </span><span class="lineCov">      11916 :             case 'a': c-&gt;flags |= CMD_ADMIN; break;</span>
<span class="lineNum">    2201 </span><span class="lineCov">       3972 :             case 'p': c-&gt;flags |= CMD_PUBSUB; break;</span>
<span class="lineNum">    2202 </span><span class="lineCov">      24494 :             case 's': c-&gt;flags |= CMD_NOSCRIPT; break;</span>
<span class="lineNum">    2203 </span><span class="lineCov">      16550 :             case 'R': c-&gt;flags |= CMD_RANDOM; break;</span>
<span class="lineNum">    2204 </span><span class="lineCov">       4634 :             case 'S': c-&gt;flags |= CMD_SORT_FOR_SCRIPT; break;</span>
<span class="lineNum">    2205 </span><span class="lineCov">      11254 :             case 'l': c-&gt;flags |= CMD_LOADING; break;</span>
<span class="lineNum">    2206 </span><span class="lineCov">      12578 :             case 't': c-&gt;flags |= CMD_STALE; break;</span>
<span class="lineNum">    2207 </span><span class="lineCov">        662 :             case 'M': c-&gt;flags |= CMD_SKIP_MONITOR; break;</span>
<span class="lineNum">    2208 </span><span class="lineCov">        662 :             case 'k': c-&gt;flags |= CMD_ASKING; break;</span>
<span class="lineNum">    2209 </span><span class="lineCov">      55608 :             case 'F': c-&gt;flags |= CMD_FAST; break;</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :             default: serverPanic(&quot;Unsupported command flag&quot;); break;</span>
<span class="lineNum">    2211 </span>            :             }
<span class="lineNum">    2212 </span><span class="lineCov">     276054 :             f++;</span>
<span class="lineNum">    2213 </span>            :         }
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineCov">     132400 :         retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</span>
<span class="lineNum">    2216 </span>            :         /* Populate an additional dictionary that will be unaffected
<span class="lineNum">    2217 </span>            :          * by rename-command statements in redis.conf. */
<span class="lineNum">    2218 </span><span class="lineCov">     132400 :         retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</span>
<span class="lineNum">    2219 </span><span class="lineCov">     132400 :         serverAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</span>
<span class="lineNum">    2220 </span>            :     }
<a name="2221"><span class="lineNum">    2221 </span><span class="lineCov">        662 : }</span></a>
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span><span class="lineCov">         12 : void resetCommandTableStats(void) {</span>
<span class="lineNum">    2224 </span><span class="lineCov">         12 :     struct redisCommand *c;</span>
<span class="lineNum">    2225 </span><span class="lineCov">         12 :     dictEntry *de;</span>
<span class="lineNum">    2226 </span><span class="lineCov">         12 :     dictIterator *di;</span>
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineCov">         12 :     di = dictGetSafeIterator(server.commands);</span>
<span class="lineNum">    2229 </span><span class="lineCov">       2412 :     while((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">    2230 </span><span class="lineCov">       2400 :         c = (struct redisCommand *) dictGetVal(de);</span>
<span class="lineNum">    2231 </span><span class="lineCov">       2400 :         c-&gt;microseconds = 0;</span>
<span class="lineNum">    2232 </span><span class="lineCov">       2400 :         c-&gt;calls = 0;</span>
<span class="lineNum">    2233 </span>            :     }
<span class="lineNum">    2234 </span><span class="lineCov">         12 :     dictReleaseIterator(di);</span>
<span class="lineNum">    2235 </span>            : 
<span class="lineNum">    2236 </span><span class="lineCov">         12 : }</span>
<span class="lineNum">    2237 </span>            : 
<a name="2238"><span class="lineNum">    2238 </span>            : /* ========================== Redis OP Array API ============================ */</a>
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 : void redisOpArrayInit(redisOpArray *oa) {</span>
<span class="lineNum">    2241 </span><span class="lineCov">   56294366 :     oa-&gt;ops = NULL;</span>
<span class="lineNum">    2242 </span><span class="lineCov">   56294366 :     oa-&gt;numops = 0;</span>
<a name="2243"><span class="lineNum">    2243 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span><span class="lineCov">     490469 : int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,</span>
<span class="lineNum">    2246 </span>            :                        robj **argv, int argc, int target)
<span class="lineNum">    2247 </span>            : {
<span class="lineNum">    2248 </span><span class="lineCov">     490469 :     redisOp *op;</span>
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span><span class="lineCov">     490469 :     oa-&gt;ops = zrealloc(oa-&gt;ops,sizeof(redisOp)*(oa-&gt;numops+1));</span>
<span class="lineNum">    2251 </span><span class="lineCov">     490469 :     op = oa-&gt;ops+oa-&gt;numops;</span>
<span class="lineNum">    2252 </span><span class="lineCov">     490469 :     op-&gt;cmd = cmd;</span>
<span class="lineNum">    2253 </span><span class="lineCov">     490469 :     op-&gt;dbid = dbid;</span>
<span class="lineNum">    2254 </span><span class="lineCov">     490469 :     op-&gt;argv = argv;</span>
<span class="lineNum">    2255 </span><span class="lineCov">     490469 :     op-&gt;argc = argc;</span>
<span class="lineNum">    2256 </span><span class="lineCov">     490469 :     op-&gt;target = target;</span>
<span class="lineNum">    2257 </span><span class="lineCov">     490469 :     oa-&gt;numops++;</span>
<span class="lineNum">    2258 </span><span class="lineCov">     490469 :     return oa-&gt;numops;</span>
<a name="2259"><span class="lineNum">    2259 </span>            : }</a>
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineCov">     490185 : void redisOpArrayFree(redisOpArray *oa) {</span>
<span class="lineNum">    2262 </span><span class="lineCov">     980654 :     while(oa-&gt;numops) {</span>
<span class="lineNum">    2263 </span><span class="lineCov">     490469 :         int j;</span>
<span class="lineNum">    2264 </span><span class="lineCov">     490469 :         redisOp *op;</span>
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span><span class="lineCov">     490469 :         oa-&gt;numops--;</span>
<span class="lineNum">    2267 </span><span class="lineCov">     490469 :         op = oa-&gt;ops+oa-&gt;numops;</span>
<span class="lineNum">    2268 </span><span class="lineCov">     981620 :         for (j = 0; j &lt; op-&gt;argc; j++)</span>
<span class="lineNum">    2269 </span><span class="lineCov">     491151 :             decrRefCount(op-&gt;argv[j]);</span>
<span class="lineNum">    2270 </span><span class="lineCov">     490469 :         zfree(op-&gt;argv);</span>
<span class="lineNum">    2271 </span>            :     }
<span class="lineNum">    2272 </span><span class="lineCov">     490185 :     zfree(oa-&gt;ops);</span>
<span class="lineNum">    2273 </span><span class="lineCov">     490185 : }</span>
<span class="lineNum">    2274 </span>            : 
<a name="2275"><span class="lineNum">    2275 </span>            : /* ====================== Commands lookup and execution ===================== */</a>
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span><span class="lineCov">    7838850 : struct redisCommand *lookupCommand(sds name) {</span>
<span class="lineNum">    2278 </span><span class="lineCov">    7838850 :     return dictFetchValue(server.commands, name);</span>
<a name="2279"><span class="lineNum">    2279 </span>            : }</a>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineCov">       8606 : struct redisCommand *lookupCommandByCString(char *s) {</span>
<span class="lineNum">    2282 </span><span class="lineCov">       8606 :     struct redisCommand *cmd;</span>
<span class="lineNum">    2283 </span><span class="lineCov">       8606 :     sds name = sdsnew(s);</span>
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span><span class="lineCov">       8606 :     cmd = dictFetchValue(server.commands, name);</span>
<span class="lineNum">    2286 </span><span class="lineCov">       8606 :     sdsfree(name);</span>
<span class="lineNum">    2287 </span><span class="lineCov">       8606 :     return cmd;</span>
<span class="lineNum">    2288 </span>            : }
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span>            : /* Lookup the command in the current table, if not found also check in
<span class="lineNum">    2291 </span>            :  * the original table containing the original command names unaffected by
<span class="lineNum">    2292 </span>            :  * redis.conf rename-command statement.
<span class="lineNum">    2293 </span>            :  *
<span class="lineNum">    2294 </span>            :  * This is used by functions rewriting the argument vector such as
<a name="2295"><span class="lineNum">    2295 </span>            :  * rewriteClientCommandVector() in order to set client-&gt;cmd pointer</a>
<span class="lineNum">    2296 </span>            :  * correctly even if the command was renamed. */
<span class="lineNum">    2297 </span><span class="lineCov">      27262 : struct redisCommand *lookupCommandOrOriginal(sds name) {</span>
<span class="lineNum">    2298 </span><span class="lineCov">      27262 :     struct redisCommand *cmd = dictFetchValue(server.commands, name);</span>
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span><span class="lineCov">      27262 :     if (!cmd) cmd = dictFetchValue(server.orig_commands,name);</span>
<span class="lineNum">    2301 </span><span class="lineCov">      27262 :     return cmd;</span>
<span class="lineNum">    2302 </span>            : }
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span>            : /* Propagate the specified command (in the context of the specified database id)
<span class="lineNum">    2305 </span>            :  * to AOF and Slaves.
<span class="lineNum">    2306 </span>            :  *
<span class="lineNum">    2307 </span>            :  * flags are an xor between:
<span class="lineNum">    2308 </span>            :  * + PROPAGATE_NONE (no propagation of command at all)
<span class="lineNum">    2309 </span>            :  * + PROPAGATE_AOF (propagate into the AOF file if is enabled)
<span class="lineNum">    2310 </span>            :  * + PROPAGATE_REPL (propagate into the replication link)
<span class="lineNum">    2311 </span>            :  *
<span class="lineNum">    2312 </span>            :  * This should not be used inside commands implementation. Use instead
<a name="2313"><span class="lineNum">    2313 </span>            :  * alsoPropagate(), preventCommandPropagation(), forceCommandPropagation().</a>
<span class="lineNum">    2314 </span>            :  */
<span class="lineNum">    2315 </span><span class="lineCov">   46737507 : void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,</span>
<span class="lineNum">    2316 </span>            :                int flags)
<span class="lineNum">    2317 </span>            : {
<span class="lineNum">    2318 </span><span class="lineCov">   46737507 :     if (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span>
<span class="lineNum">    2319 </span><span class="lineCov">    9315703 :         feedAppendOnlyFile(cmd,dbid,argv,argc);</span>
<span class="lineNum">    2320 </span><span class="lineCov">   46737507 :     if (flags &amp; PROPAGATE_REPL)</span>
<span class="lineNum">    2321 </span><span class="lineCov">   46737505 :         replicationFeedSlaves(server.slaves,dbid,argv,argc);</span>
<span class="lineNum">    2322 </span><span class="lineCov">   46737507 : }</span>
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span>            : /* Used inside commands to schedule the propagation of additional commands
<span class="lineNum">    2325 </span>            :  * after the current command is propagated to AOF / Replication.
<span class="lineNum">    2326 </span>            :  *
<span class="lineNum">    2327 </span>            :  * 'cmd' must be a pointer to the Redis command to replicate, dbid is the
<span class="lineNum">    2328 </span>            :  * database ID the command should be propagated into.
<span class="lineNum">    2329 </span>            :  * Arguments of the command to propagte are passed as an array of redis
<span class="lineNum">    2330 </span>            :  * objects pointers of len 'argc', using the 'argv' vector.
<span class="lineNum">    2331 </span>            :  *
<span class="lineNum">    2332 </span>            :  * The function does not take a reference to the passed 'argv' vector,
<span class="lineNum">    2333 </span>            :  * so it is up to the caller to release the passed argv (but it is usually
<a name="2334"><span class="lineNum">    2334 </span>            :  * stack allocated).  The function autoamtically increments ref count of</a>
<span class="lineNum">    2335 </span>            :  * passed objects, so the caller does not need to. */
<span class="lineNum">    2336 </span><span class="lineCov">     490475 : void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,</span>
<span class="lineNum">    2337 </span>            :                    int target)
<span class="lineNum">    2338 </span>            : {
<span class="lineNum">    2339 </span><span class="lineCov">     490475 :     robj **argvcopy;</span>
<span class="lineNum">    2340 </span><span class="lineCov">     490475 :     int j;</span>
<span class="lineNum">    2341 </span>            : 
<span class="lineNum">    2342 </span><span class="lineCov">     490475 :     if (server.loading) return; /* No propagation during loading. */</span>
<span class="lineNum">    2343 </span>            : 
<span class="lineNum">    2344 </span><span class="lineCov">     490469 :     argvcopy = zmalloc(sizeof(robj*)*argc);</span>
<span class="lineNum">    2345 </span><span class="lineCov">     981620 :     for (j = 0; j &lt; argc; j++) {</span>
<span class="lineNum">    2346 </span><span class="lineCov">     491151 :         argvcopy[j] = argv[j];</span>
<span class="lineNum">    2347 </span><span class="lineCov">     491151 :         incrRefCount(argv[j]);</span>
<span class="lineNum">    2348 </span>            :     }
<span class="lineNum">    2349 </span><span class="lineCov">     490469 :     redisOpArrayAppend(&amp;server.also_propagate,cmd,dbid,argvcopy,argc,target);</span>
<span class="lineNum">    2350 </span>            : }
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span>            : /* It is possible to call the function forceCommandPropagation() inside a
<a name="2353"><span class="lineNum">    2353 </span>            :  * Redis command implementation in order to to force the propagation of a</a>
<span class="lineNum">    2354 </span>            :  * specific command execution into AOF / Replication. */
<span class="lineNum">    2355 </span><span class="lineCov">     837625 : void forceCommandPropagation(client *c, int flags) {</span>
<span class="lineNum">    2356 </span><span class="lineCov">     837625 :     if (flags &amp; PROPAGATE_REPL) c-&gt;flags |= CLIENT_FORCE_REPL;</span>
<span class="lineNum">    2357 </span><span class="lineCov">     837625 :     if (flags &amp; PROPAGATE_AOF) c-&gt;flags |= CLIENT_FORCE_AOF;</span>
<span class="lineNum">    2358 </span><span class="lineCov">     837625 : }</span>
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span>            : /* Avoid that the executed command is propagated at all. This way we
<a name="2361"><span class="lineNum">    2361 </span>            :  * are free to just propagate what we want using the alsoPropagate()</a>
<span class="lineNum">    2362 </span>            :  * API. */
<span class="lineNum">    2363 </span><span class="lineCov">     640603 : void preventCommandPropagation(client *c) {</span>
<span class="lineNum">    2364 </span><span class="lineCov">     640603 :     c-&gt;flags |= CLIENT_PREVENT_PROP;</span>
<span class="lineNum">    2365 </span><span class="lineCov">     640603 : }</span>
<a name="2366"><span class="lineNum">    2366 </span>            : </a>
<span class="lineNum">    2367 </span>            : /* AOF specific version of preventCommandPropagation(). */
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 : void preventCommandAOF(client *c) {</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :     c-&gt;flags |= CLIENT_PREVENT_AOF_PROP;</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 : }</span>
<a name="2371"><span class="lineNum">    2371 </span>            : </a>
<span class="lineNum">    2372 </span>            : /* Replication specific version of preventCommandPropagation(). */
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 : void preventCommandReplication(client *c) {</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :     c-&gt;flags |= CLIENT_PREVENT_REPL_PROP;</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            : /* Call() is the core of Redis execution of a command.
<span class="lineNum">    2378 </span>            :  *
<span class="lineNum">    2379 </span>            :  * The following flags can be passed:
<span class="lineNum">    2380 </span>            :  * CMD_CALL_NONE        No flags.
<span class="lineNum">    2381 </span>            :  * CMD_CALL_SLOWLOG     Check command speed and log in the slow log if needed.
<span class="lineNum">    2382 </span>            :  * CMD_CALL_STATS       Populate command stats.
<span class="lineNum">    2383 </span>            :  * CMD_CALL_PROPAGATE_AOF   Append command to AOF if it modified the dataset
<span class="lineNum">    2384 </span>            :  *                          or if the client flags are forcing propagation.
<span class="lineNum">    2385 </span>            :  * CMD_CALL_PROPAGATE_REPL  Send command to salves if it modified the dataset
<span class="lineNum">    2386 </span>            :  *                          or if the client flags are forcing propagation.
<span class="lineNum">    2387 </span>            :  * CMD_CALL_PROPAGATE   Alias for PROPAGATE_AOF|PROPAGATE_REPL.
<span class="lineNum">    2388 </span>            :  * CMD_CALL_FULL        Alias for SLOWLOG|STATS|PROPAGATE.
<span class="lineNum">    2389 </span>            :  *
<span class="lineNum">    2390 </span>            :  * The exact propagation behavior depends on the client flags.
<span class="lineNum">    2391 </span>            :  * Specifically:
<span class="lineNum">    2392 </span>            :  *
<span class="lineNum">    2393 </span>            :  * 1. If the client flags CLIENT_FORCE_AOF or CLIENT_FORCE_REPL are set
<span class="lineNum">    2394 </span>            :  *    and assuming the corresponding CMD_CALL_PROPAGATE_AOF/REPL is set
<span class="lineNum">    2395 </span>            :  *    in the call flags, then the command is propagated even if the
<span class="lineNum">    2396 </span>            :  *    dataset was not affected by the command.
<span class="lineNum">    2397 </span>            :  * 2. If the client flags CLIENT_PREVENT_REPL_PROP or CLIENT_PREVENT_AOF_PROP
<span class="lineNum">    2398 </span>            :  *    are set, the propagation into AOF or to slaves is not performed even
<span class="lineNum">    2399 </span>            :  *    if the command modified the dataset.
<span class="lineNum">    2400 </span>            :  *
<span class="lineNum">    2401 </span>            :  * Note that regardless of the client flags, if CMD_CALL_PROPAGATE_AOF
<span class="lineNum">    2402 </span>            :  * or CMD_CALL_PROPAGATE_REPL are not set, then respectively AOF or
<span class="lineNum">    2403 </span>            :  * slaves propagation will never occur.
<span class="lineNum">    2404 </span>            :  *
<span class="lineNum">    2405 </span>            :  * Client flags are modified by the implementation of a given command
<span class="lineNum">    2406 </span>            :  * using the following API:
<span class="lineNum">    2407 </span>            :  *
<span class="lineNum">    2408 </span>            :  * forceCommandPropagation(client *c, int flags);
<span class="lineNum">    2409 </span>            :  * preventCommandPropagation(client *c);
<span class="lineNum">    2410 </span>            :  * preventCommandAOF(client *c);
<span class="lineNum">    2411 </span>            :  * preventCommandReplication(client *c);
<a name="2412"><span class="lineNum">    2412 </span>            :  *</a>
<span class="lineNum">    2413 </span>            :  */
<span class="lineNum">    2414 </span><span class="lineCov">   56294366 : void call(client *c, int flags) {</span>
<span class="lineNum">    2415 </span><span class="lineCov">   56294366 :     long long dirty, start, duration;</span>
<span class="lineNum">    2416 </span><span class="lineCov">   56294366 :     int client_old_flags = c-&gt;flags;</span>
<span class="lineNum">    2417 </span><span class="lineCov">   56294366 :     struct redisCommand *real_cmd = c-&gt;cmd;</span>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :     /* Sent the command to clients in MONITOR mode, only if the commands are
<span class="lineNum">    2420 </span>            :      * not generated from reading an AOF. */
<span class="lineNum">    2421 </span><span class="lineCov">   56294366 :     if (listLength(server.monitors) &amp;&amp;</span>
<span class="lineNum">    2422 </span><span class="lineCov">         34 :         !server.loading &amp;&amp;</span>
<span class="lineNum">    2423 </span><span class="lineCov">         34 :         !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span>
<span class="lineNum">    2424 </span>            :     {
<span class="lineNum">    2425 </span><span class="lineCov">         12 :         replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span>
<span class="lineNum">    2426 </span>            :     }
<span class="lineNum">    2427 </span>            : 
<span class="lineNum">    2428 </span>            :     /* Initialization: clear the flags that must be set by the command on
<span class="lineNum">    2429 </span>            :      * demand, and initialize the array for additional commands propagation. */
<span class="lineNum">    2430 </span><span class="lineCov">   56294366 :     c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span>
<span class="lineNum">    2431 </span><span class="lineCov">   56294366 :     redisOpArray prev_also_propagate = server.also_propagate;</span>
<span class="lineNum">    2432 </span><span class="lineCov">  112588732 :     redisOpArrayInit(&amp;server.also_propagate);</span>
<span class="lineNum">    2433 </span>            : 
<span class="lineNum">    2434 </span>            :     /* Call the command. */
<span class="lineNum">    2435 </span><span class="lineCov">   56294366 :     dirty = server.dirty;</span>
<span class="lineNum">    2436 </span><span class="lineCov">   56294366 :     start = ustime();</span>
<span class="lineNum">    2437 </span><span class="lineCov">   56294366 :     c-&gt;cmd-&gt;proc(c);</span>
<span class="lineNum">    2438 </span><span class="lineCov">   56294162 :     duration = ustime()-start;</span>
<span class="lineNum">    2439 </span><span class="lineCov">   56294162 :     dirty = server.dirty-dirty;</span>
<span class="lineNum">    2440 </span><span class="lineCov">   56294162 :     if (dirty &lt; 0) dirty = 0;</span>
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span>            :     /* When EVAL is called loading the AOF we don't want commands called
<span class="lineNum">    2443 </span>            :      * from Lua to go into the slowlog or to populate statistics. */
<span class="lineNum">    2444 </span><span class="lineCov">   56294162 :     if (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :         flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span>
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            :     /* If the caller is Lua, we want to force the EVAL caller to propagate
<span class="lineNum">    2448 </span>            :      * the script if the command flag or client flag are forcing the
<span class="lineNum">    2449 </span>            :      * propagation. */
<span class="lineNum">    2450 </span><span class="lineCov">   56294162 :     if (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) {</span>
<span class="lineNum">    2451 </span><span class="lineCov">     690369 :         if (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :             server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span>
<span class="lineNum">    2453 </span><span class="lineCov">     690369 :         if (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :             server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span>
<span class="lineNum">    2455 </span>            :     }
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            :     /* Log the command into the Slow log if needed, and populate the
<span class="lineNum">    2458 </span>            :      * per-command statistics that we show in INFO commandstats. */
<span class="lineNum">    2459 </span><span class="lineCov">   56294162 :     if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) {</span>
<span class="lineNum">    2460 </span><span class="lineCov">  111867048 :         char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span>
<span class="lineNum">    2461 </span><span class="lineCov">   55933524 :                               &quot;fast-command&quot; : &quot;command&quot;;</span>
<span class="lineNum">    2462 </span><span class="lineCov">   55933524 :         latencyAddSampleIfNeeded(latency_event,duration/1000);</span>
<span class="lineNum">    2463 </span><span class="lineCov">   55933524 :         slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span>
<span class="lineNum">    2464 </span>            :     }
<span class="lineNum">    2465 </span><span class="lineCov">   56294162 :     if (flags &amp; CMD_CALL_STATS) {</span>
<span class="lineNum">    2466 </span>            :         /* use the real command that was executed (cmd and lastamc) may be
<span class="lineNum">    2467 </span>            :          * different, in case of MULTI-EXEC or re-written commands such as
<span class="lineNum">    2468 </span>            :          * EXPIRE, GEOADD, etc. */
<span class="lineNum">    2469 </span><span class="lineCov">   56114166 :         real_cmd-&gt;microseconds += duration;</span>
<span class="lineNum">    2470 </span><span class="lineCov">   56114166 :         real_cmd-&gt;calls++;</span>
<span class="lineNum">    2471 </span>            :     }
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span>            :     /* Propagate the command into the AOF and replication link */
<span class="lineNum">    2474 </span><span class="lineCov">   56294162 :     if (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span>
<span class="lineNum">    2475 </span><span class="lineCov">   56114156 :         (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span>
<span class="lineNum">    2476 </span>            :     {
<span class="lineNum">    2477 </span><span class="lineCov">   55473556 :         int propagate_flags = PROPAGATE_NONE;</span>
<span class="lineNum">    2478 </span>            : 
<span class="lineNum">    2479 </span>            :         /* Check if the command operated changes in the data set. If so
<span class="lineNum">    2480 </span>            :          * set for replication / AOF propagation. */
<span class="lineNum">    2481 </span><span class="lineCov">   55473556 :         if (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span>
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            :         /* If the client forced AOF / replication of the command, set
<span class="lineNum">    2484 </span>            :          * the flags regardless of the command effects on the data set. */
<span class="lineNum">    2485 </span><span class="lineCov">   55473556 :         if (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span>
<span class="lineNum">    2486 </span><span class="lineCov">   55473556 :         if (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span>
<span class="lineNum">    2487 </span>            : 
<span class="lineNum">    2488 </span>            :         /* However prevent AOF / replication propagation if the command
<span class="lineNum">    2489 </span>            :          * implementations called preventCommandPropagation() or similar,
<span class="lineNum">    2490 </span>            :          * or if we don't have the call() flags to do so. */
<span class="lineNum">    2491 </span><span class="lineCov">   55473556 :         if (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span>
<span class="lineNum">    2492 </span><span class="lineCov">   55473556 :             !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span>
<span class="lineNum">    2493 </span><span class="lineCov">          2 :                 propagate_flags &amp;= ~PROPAGATE_REPL;</span>
<span class="lineNum">    2494 </span><span class="lineCov">   55473556 :         if (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span>
<span class="lineNum">    2495 </span><span class="lineCov">   55473556 :             !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :                 propagate_flags &amp;= ~PROPAGATE_AOF;</span>
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span>            :         /* Call propagate() only if at least one of AOF / replication
<span class="lineNum">    2499 </span>            :          * propagation is needed. Note that modules commands handle replication
<span class="lineNum">    2500 </span>            :          * in an explicit way, so we never replicate them automatically. */
<span class="lineNum">    2501 </span><span class="lineCov">   55473556 :         if (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span>
<span class="lineNum">    2502 </span><span class="lineCov">   45396172 :             propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span>
<span class="lineNum">    2503 </span>            :     }
<span class="lineNum">    2504 </span>            : 
<span class="lineNum">    2505 </span>            :     /* Restore the old replication flags, since call() can be executed
<span class="lineNum">    2506 </span>            :      * recursively. */
<span class="lineNum">    2507 </span><span class="lineCov">   56294162 :     c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span>
<span class="lineNum">    2508 </span><span class="lineCov">   56294162 :     c-&gt;flags |= client_old_flags &amp;</span>
<span class="lineNum">    2509 </span>            :         (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span>            :     /* Handle the alsoPropagate() API to handle commands that want to propagate
<span class="lineNum">    2512 </span>            :      * multiple separated commands. Note that alsoPropagate() is not affected
<span class="lineNum">    2513 </span>            :      * by CLIENT_PREVENT_PROP flag. */
<span class="lineNum">    2514 </span><span class="lineCov">   56294162 :     if (server.also_propagate.numops) {</span>
<span class="lineNum">    2515 </span><span class="lineCov">     490185 :         int j;</span>
<span class="lineNum">    2516 </span><span class="lineCov">     490185 :         redisOp *rop;</span>
<span class="lineNum">    2517 </span>            : 
<span class="lineNum">    2518 </span><span class="lineCov">     490185 :         if (flags &amp; CMD_CALL_PROPAGATE) {</span>
<span class="lineNum">    2519 </span><span class="lineCov">     980654 :             for (j = 0; j &lt; server.also_propagate.numops; j++) {</span>
<span class="lineNum">    2520 </span><span class="lineCov">     490469 :                 rop = &amp;server.also_propagate.ops[j];</span>
<span class="lineNum">    2521 </span><span class="lineCov">     490469 :                 int target = rop-&gt;target;</span>
<span class="lineNum">    2522 </span>            :                 /* Whatever the command wish is, we honor the call() flags. */
<span class="lineNum">    2523 </span><span class="lineCov">     490469 :                 if (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span>
<span class="lineNum">    2524 </span><span class="lineCov">     490469 :                 if (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span>
<span class="lineNum">    2525 </span><span class="lineCov">     490469 :                 if (target)</span>
<span class="lineNum">    2526 </span><span class="lineCov">     490469 :                     propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span>
<span class="lineNum">    2527 </span>            :             }
<span class="lineNum">    2528 </span>            :         }
<span class="lineNum">    2529 </span><span class="lineCov">     490185 :         redisOpArrayFree(&amp;server.also_propagate);</span>
<span class="lineNum">    2530 </span>            :     }
<span class="lineNum">    2531 </span><span class="lineCov">   56294162 :     server.also_propagate = prev_also_propagate;</span>
<span class="lineNum">    2532 </span><span class="lineCov">   56294162 :     server.stat_numcommands++;</span>
<span class="lineNum">    2533 </span><span class="lineCov">   56294162 : }</span>
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            : /* If this function gets called we already read a whole
<span class="lineNum">    2536 </span>            :  * command, arguments are in the client argv/argc fields.
<span class="lineNum">    2537 </span>            :  * processCommand() execute the command or prepare the
<span class="lineNum">    2538 </span>            :  * server for a bulk read from the client.
<span class="lineNum">    2539 </span>            :  *
<span class="lineNum">    2540 </span>            :  * If C_OK is returned the client is still alive and valid and
<a name="2541"><span class="lineNum">    2541 </span>            :  * other operations can be performed by the caller. Otherwise</a>
<span class="lineNum">    2542 </span>            :  * if C_ERR is returned the client was destroyed (i.e. after QUIT). */
<span class="lineNum">    2543 </span><span class="lineCov">   55429932 : int processCommand(client *c) {</span>
<span class="lineNum">    2544 </span>            :     /* The QUIT command is handled separately. Normal command procs will
<span class="lineNum">    2545 </span>            :      * go through checking for replication and QUIT will cause trouble
<span class="lineNum">    2546 </span>            :      * when FORCE_REPLICATION is enabled and would be implemented in
<span class="lineNum">    2547 </span>            :      * a regular command proc. */
<span class="lineNum">    2548 </span><span class="lineCov">   55429932 :     if (!strcasecmp(c-&gt;argv[0]-&gt;ptr,&quot;quit&quot;)) {</span>
<span class="lineNum">    2549 </span><span class="lineCov">          9 :         addReply(c,shared.ok);</span>
<span class="lineNum">    2550 </span><span class="lineCov">          9 :         c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span>
<span class="lineNum">    2551 </span><span class="lineCov">          9 :         return C_ERR;</span>
<span class="lineNum">    2552 </span>            :     }
<span class="lineNum">    2553 </span>            : 
<span class="lineNum">    2554 </span>            :     /* Now lookup the command and check ASAP about trivial error conditions
<span class="lineNum">    2555 </span>            :      * such as wrong arity, bad command name and so forth. */
<span class="lineNum">    2556 </span><span class="lineCov">   55429923 :     c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);</span>
<span class="lineNum">    2557 </span><span class="lineCov">   55429923 :     if (!c-&gt;cmd) {</span>
<span class="lineNum">    2558 </span><span class="lineCov">         33 :         flagTransaction(c);</span>
<span class="lineNum">    2559 </span><span class="lineCov">         33 :         sds args = sdsempty();</span>
<span class="lineNum">    2560 </span><span class="lineCov">         33 :         int i;</span>
<span class="lineNum">    2561 </span><span class="lineCov">         33 :         for (i=1; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; 128; i++)</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :             args = sdscatprintf(args, &quot;`%.*s`, &quot;, 128-(int)sdslen(args), (char*)c-&gt;argv[i]-&gt;ptr);</span>
<span class="lineNum">    2563 </span><span class="lineCov">         66 :         addReplyErrorFormat(c,&quot;unknown command `%s`, with args beginning with: %s&quot;,</span>
<span class="lineNum">    2564 </span><span class="lineCov">         33 :             (char*)c-&gt;argv[0]-&gt;ptr, args);</span>
<span class="lineNum">    2565 </span><span class="lineCov">         33 :         sdsfree(args);</span>
<span class="lineNum">    2566 </span><span class="lineCov">         33 :         return C_OK;</span>
<span class="lineNum">    2567 </span><span class="lineCov">   55429890 :     } else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span>
<span class="lineNum">    2568 </span><span class="lineCov">   55429884 :                (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) {</span>
<span class="lineNum">    2569 </span><span class="lineCov">          6 :         flagTransaction(c);</span>
<span class="lineNum">    2570 </span><span class="lineCov">         12 :         addReplyErrorFormat(c,&quot;wrong number of arguments for '%s' command&quot;,</span>
<span class="lineNum">    2571 </span><span class="lineCov">          6 :             c-&gt;cmd-&gt;name);</span>
<span class="lineNum">    2572 </span><span class="lineCov">          6 :         return C_OK;</span>
<span class="lineNum">    2573 </span>            :     }
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            :     /* Check if the user is authenticated */
<span class="lineNum">    2576 </span><span class="lineCov">   55429884 :     if (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand)</span>
<span class="lineNum">    2577 </span>            :     {
<span class="lineNum">    2578 </span><span class="lineCov">          9 :         flagTransaction(c);</span>
<span class="lineNum">    2579 </span><span class="lineCov">          9 :         addReply(c,shared.noautherr);</span>
<span class="lineNum">    2580 </span><span class="lineCov">          9 :         return C_OK;</span>
<span class="lineNum">    2581 </span>            :     }
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span>            :     /* If cluster is enabled perform the cluster redirection here.
<span class="lineNum">    2584 </span>            :      * However we don't perform the redirection if:
<span class="lineNum">    2585 </span>            :      * 1) The sender of this command is our master.
<span class="lineNum">    2586 </span>            :      * 2) The command has no key arguments. */
<span class="lineNum">    2587 </span><span class="lineCov">   55429875 :     if (server.cluster_enabled &amp;&amp;</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :         !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :         !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span>
<span class="lineNum">    2590 </span><span class="lineNoCov">          0 :           server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span>
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :         !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey == 0 &amp;&amp;</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :           c-&gt;cmd-&gt;proc != execCommand))</span>
<span class="lineNum">    2593 </span>            :     {
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :         int hashslot;</span>
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :         int error_code;</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :         clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span>
<span class="lineNum">    2597 </span>            :                                         &amp;hashslot,&amp;error_code);
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :         if (n == NULL || n != server.cluster-&gt;myself) {</span>
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :             if (c-&gt;cmd-&gt;proc == execCommand) {</span>
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :                 discardTransaction(c);</span>
<span class="lineNum">    2601 </span>            :             } else {
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :                 flagTransaction(c);</span>
<span class="lineNum">    2603 </span>            :             }
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :             clusterRedirectClient(c,n,hashslot,error_code);</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :             return C_OK;</span>
<span class="lineNum">    2606 </span>            :         }
<span class="lineNum">    2607 </span>            :     }
<span class="lineNum">    2608 </span>            : 
<span class="lineNum">    2609 </span>            :     /* Handle the maxmemory directive.
<span class="lineNum">    2610 </span>            :      *
<span class="lineNum">    2611 </span>            :      * First we try to free some memory if possible (if there are volatile
<span class="lineNum">    2612 </span>            :      * keys in the dataset). If there are not the only thing we can do
<span class="lineNum">    2613 </span>            :      * is returning an error.
<span class="lineNum">    2614 </span>            :      *
<span class="lineNum">    2615 </span>            :      * Note that we do not want to reclaim memory if we are here re-entering
<span class="lineNum">    2616 </span>            :      * the event loop since there is a busy Lua script running in timeout
<span class="lineNum">    2617 </span>            :      * condition, to avoid mixing the propagation of scripts with the propagation
<span class="lineNum">    2618 </span>            :      * of DELs due to eviction. */
<span class="lineNum">    2619 </span><span class="lineCov">   55429875 :     if (server.maxmemory &amp;&amp; !server.lua_timedout) {</span>
<span class="lineNum">    2620 </span><span class="lineCov">     288006 :         int out_of_memory = freeMemoryIfNeeded() == C_ERR;</span>
<span class="lineNum">    2621 </span>            :         /* freeMemoryIfNeeded may flush slave output buffers. This may result
<span class="lineNum">    2622 </span>            :          * into a slave, that may be the active client, to be freed. */
<span class="lineNum">    2623 </span><span class="lineCov">     288006 :         if (server.current_client == NULL) return C_ERR;</span>
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span>            :         /* It was impossible to free enough memory, and the command the client
<span class="lineNum">    2626 </span>            :          * is trying to execute is denied during OOM conditions or the client
<span class="lineNum">    2627 </span>            :          * is in MULTI/EXEC context? Error. */
<span class="lineNum">    2628 </span><span class="lineCov">     288006 :         if (out_of_memory &amp;&amp;</span>
<span class="lineNum">    2629 </span><span class="lineCov">       5655 :             (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM ||</span>
<span class="lineNum">    2630 </span><span class="lineCov">         20 :              (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp; c-&gt;cmd-&gt;proc != execCommand))) {</span>
<span class="lineNum">    2631 </span><span class="lineCov">       5635 :             flagTransaction(c);</span>
<span class="lineNum">    2632 </span><span class="lineCov">       5635 :             addReply(c, shared.oomerr);</span>
<span class="lineNum">    2633 </span><span class="lineCov">       5635 :             return C_OK;</span>
<span class="lineNum">    2634 </span>            :         }
<span class="lineNum">    2635 </span>            :     }
<span class="lineNum">    2636 </span>            : 
<span class="lineNum">    2637 </span>            :     /* Don't accept write commands if there are problems persisting on disk
<span class="lineNum">    2638 </span>            :      * and if this is a master instance. */
<span class="lineNum">    2639 </span><span class="lineCov">   55424240 :     int deny_write_type = writeCommandsDeniedByDiskError();</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :     if (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :         server.masterhost == NULL &amp;&amp;</span>
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :         (c-&gt;cmd-&gt;flags &amp; CMD_WRITE ||</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :          c-&gt;cmd-&gt;proc == pingCommand))</span>
<span class="lineNum">    2644 </span>            :     {
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :         flagTransaction(c);</span>
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 :         if (deny_write_type == DISK_ERROR_TYPE_RDB)</span>
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :             addReply(c, shared.bgsaveerr);</span>
<span class="lineNum">    2648 </span>            :         else
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :             addReplySds(c,</span>
<span class="lineNum">    2650 </span>            :                 sdscatprintf(sdsempty(),
<span class="lineNum">    2651 </span>            :                 &quot;-MISCONF Errors writing to the AOF file: %s\r\n&quot;,
<span class="lineNum">    2652 </span>            :                 strerror(server.aof_last_write_errno)));
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :         return C_OK;</span>
<span class="lineNum">    2654 </span>            :     }
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span>            :     /* Don't accept write commands if there are not enough good slaves and
<span class="lineNum">    2657 </span>            :      * user configured the min-slaves-to-write option. */
<span class="lineNum">    2658 </span><span class="lineCov">   55424240 :     if (server.masterhost == NULL &amp;&amp;</span>
<span class="lineNum">    2659 </span><span class="lineCov">   39577766 :         server.repl_min_slaves_to_write &amp;&amp;</span>
<span class="lineNum">    2660 </span><span class="lineCov">         72 :         server.repl_min_slaves_max_lag &amp;&amp;</span>
<span class="lineNum">    2661 </span><span class="lineCov">         72 :         c-&gt;cmd-&gt;flags &amp; CMD_WRITE &amp;&amp;</span>
<span class="lineNum">    2662 </span><span class="lineCov">         30 :         server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span>
<span class="lineNum">    2663 </span>            :     {
<span class="lineNum">    2664 </span><span class="lineCov">         12 :         flagTransaction(c);</span>
<span class="lineNum">    2665 </span><span class="lineCov">         12 :         addReply(c, shared.noreplicaserr);</span>
<span class="lineNum">    2666 </span><span class="lineCov">         12 :         return C_OK;</span>
<span class="lineNum">    2667 </span>            :     }
<span class="lineNum">    2668 </span>            : 
<span class="lineNum">    2669 </span>            :     /* Don't accept write commands if this is a read only slave. But
<span class="lineNum">    2670 </span>            :      * accept write commands if this is our master. */
<span class="lineNum">    2671 </span><span class="lineCov">   55424228 :     if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span>
<span class="lineNum">    2672 </span><span class="lineCov">   15846456 :         !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span>
<span class="lineNum">    2673 </span><span class="lineCov">       3208 :         c-&gt;cmd-&gt;flags &amp; CMD_WRITE)</span>
<span class="lineNum">    2674 </span>            :     {
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :         addReply(c, shared.roslaveerr);</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :         return C_OK;</span>
<span class="lineNum">    2677 </span>            :     }
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span>            :     /* Only allow SUBSCRIBE and UNSUBSCRIBE in the context of Pub/Sub */
<span class="lineNum">    2680 </span><span class="lineCov">   55424228 :     if (c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp;</span>
<span class="lineNum">    2681 </span><span class="lineCov">         20 :         c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span>
<span class="lineNum">    2682 </span><span class="lineCov">         16 :         c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span>
<span class="lineNum">    2683 </span><span class="lineCov">          8 :         c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span>
<span class="lineNum">    2684 </span><span class="lineCov">          6 :         c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span>
<span class="lineNum">    2685 </span>            :         c-&gt;cmd-&gt;proc != punsubscribeCommand) {
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 :         addReplyError(c,&quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT allowed in this context&quot;);</span>
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :         return C_OK;</span>
<span class="lineNum">    2688 </span>            :     }
<span class="lineNum">    2689 </span>            : 
<span class="lineNum">    2690 </span>            :     /* Only allow commands with flag &quot;t&quot;, such as INFO, SLAVEOF and so on,
<span class="lineNum">    2691 </span>            :      * when slave-serve-stale-data is no and we are a slave with a broken
<span class="lineNum">    2692 </span>            :      * link with master. */
<span class="lineNum">    2693 </span><span class="lineCov">   55424228 :     if (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span>
<span class="lineNum">    2694 </span><span class="lineCov">       2179 :         server.repl_serve_stale_data == 0 &amp;&amp;</span>
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :         !(c-&gt;cmd-&gt;flags &amp; CMD_STALE))</span>
<span class="lineNum">    2696 </span>            :     {
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :         flagTransaction(c);</span>
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :         addReply(c, shared.masterdownerr);</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :         return C_OK;</span>
<span class="lineNum">    2700 </span>            :     }
<span class="lineNum">    2701 </span>            : 
<span class="lineNum">    2702 </span>            :     /* Loading DB? Return an error if the command has not the
<span class="lineNum">    2703 </span>            :      * CMD_LOADING flag. */
<span class="lineNum">    2704 </span><span class="lineCov">   55424228 :     if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING)) {</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :         addReply(c, shared.loadingerr);</span>
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :         return C_OK;</span>
<span class="lineNum">    2707 </span>            :     }
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span>            :     /* Lua script too slow? Only allow a limited number of commands. */
<span class="lineNum">    2710 </span><span class="lineCov">   55424228 :     if (server.lua_timedout &amp;&amp;</span>
<span class="lineNum">    2711 </span><span class="lineCov">         14 :           c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span>
<span class="lineNum">    2712 </span><span class="lineCov">         14 :           c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span>
<span class="lineNum">    2713 </span><span class="lineCov">          4 :         !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span>
<span class="lineNum">    2714 </span><span class="lineCov">          2 :           c-&gt;argc == 2 &amp;&amp;</span>
<span class="lineNum">    2715 </span><span class="lineCov">         14 :           tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == 'n') &amp;&amp;</span>
<span class="lineNum">    2716 </span><span class="lineCov">          8 :         !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span>
<span class="lineNum">    2717 </span><span class="lineCov">          4 :           c-&gt;argc == 2 &amp;&amp;</span>
<span class="lineNum">    2718 </span><span class="lineCov">          4 :           tolower(((char*)c-&gt;argv[1]-&gt;ptr)[0]) == 'k'))</span>
<span class="lineNum">    2719 </span>            :     {
<span class="lineNum">    2720 </span><span class="lineCov">          8 :         flagTransaction(c);</span>
<span class="lineNum">    2721 </span><span class="lineCov">          8 :         addReply(c, shared.slowscripterr);</span>
<span class="lineNum">    2722 </span><span class="lineCov">          8 :         return C_OK;</span>
<span class="lineNum">    2723 </span>            :     }
<span class="lineNum">    2724 </span>            : 
<span class="lineNum">    2725 </span>            :     /* Exec the command */
<span class="lineNum">    2726 </span><span class="lineCov">   55424220 :     if (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span>
<span class="lineNum">    2727 </span><span class="lineCov">     481641 :         c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span>
<span class="lineNum">    2728 </span><span class="lineCov">     210944 :         c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span>
<span class="lineNum">    2729 </span>            :     {
<span class="lineNum">    2730 </span><span class="lineCov">     210929 :         queueMultiCommand(c);</span>
<span class="lineNum">    2731 </span><span class="lineCov">     210929 :         addReply(c,shared.queued);</span>
<span class="lineNum">    2732 </span>            :     } else {
<span class="lineNum">    2733 </span><span class="lineCov">   55213291 :         call(c,CMD_CALL_FULL);</span>
<span class="lineNum">    2734 </span><span class="lineCov">   55213090 :         c-&gt;woff = server.master_repl_offset;</span>
<span class="lineNum">    2735 </span><span class="lineCov">   55213090 :         if (listLength(server.ready_keys))</span>
<span class="lineNum">    2736 </span><span class="lineCov">        171 :             handleClientsBlockedOnKeys();</span>
<span class="lineNum">    2737 </span>            :     }
<span class="lineNum">    2738 </span>            :     return C_OK;
<span class="lineNum">    2739 </span>            : }
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span>            : /*================================== Shutdown =============================== */
<span class="lineNum">    2742 </span>            : 
<a name="2743"><span class="lineNum">    2743 </span>            : /* Close listening sockets. Also unlink the unix domain socket if</a>
<span class="lineNum">    2744 </span>            :  * unlink_unix_socket is non-zero. */
<span class="lineNum">    2745 </span><span class="lineCov">        641 : void closeListeningSockets(int unlink_unix_socket) {</span>
<span class="lineNum">    2746 </span><span class="lineCov">        641 :     int j;</span>
<span class="lineNum">    2747 </span>            : 
<span class="lineNum">    2748 </span><span class="lineCov">       1282 :     for (j = 0; j &lt; server.ipfd_count; j++) close(server.ipfd[j]);</span>
<span class="lineNum">    2749 </span><span class="lineCov">        641 :     if (server.sofd != -1) close(server.sofd);</span>
<span class="lineNum">    2750 </span><span class="lineCov">        641 :     if (server.cluster_enabled)</span>
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :         for (j = 0; j &lt; server.cfd_count; j++) close(server.cfd[j]);</span>
<span class="lineNum">    2752 </span><span class="lineCov">        641 :     if (unlink_unix_socket &amp;&amp; server.unixsocket) {</span>
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :         serverLog(LL_NOTICE,&quot;Removing the unix socket file.&quot;);</span>
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :         unlink(server.unixsocket); /* don't care if this fails */</span>
<span class="lineNum">    2755 </span>            :     }
<a name="2756"><span class="lineNum">    2756 </span><span class="lineCov">        641 : }</span></a>
<span class="lineNum">    2757 </span>            : 
<span class="lineNum">    2758 </span><span class="lineCov">        411 : int prepareForShutdown(int flags) {</span>
<span class="lineNum">    2759 </span><span class="lineCov">        411 :     int save = flags &amp; SHUTDOWN_SAVE;</span>
<span class="lineNum">    2760 </span><span class="lineCov">        411 :     int nosave = flags &amp; SHUTDOWN_NOSAVE;</span>
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span><span class="lineCov">        411 :     serverLog(LL_WARNING,&quot;User requested shutdown...&quot;);</span>
<span class="lineNum">    2763 </span>            : 
<span class="lineNum">    2764 </span>            :     /* Kill all the Lua debugger forked sessions. */
<span class="lineNum">    2765 </span><span class="lineCov">        411 :     ldbKillForkedSessions();</span>
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span>            :     /* Kill the saving child if there is a background saving in progress.
<span class="lineNum">    2768 </span>            :        We want to avoid race conditions, for instance our saving child may
<span class="lineNum">    2769 </span>            :        overwrite the synchronous saving did by SHUTDOWN. */
<span class="lineNum">    2770 </span><span class="lineCov">        411 :     if (server.rdb_child_pid != -1) {</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;There is a child saving an .rdb. Killing it!&quot;);</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :         kill(server.rdb_child_pid,SIGUSR1);</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :         rdbRemoveTempFile(server.rdb_child_pid);</span>
<span class="lineNum">    2774 </span>            :     }
<span class="lineNum">    2775 </span>            : 
<span class="lineNum">    2776 </span><span class="lineCov">        411 :     if (server.aof_state != AOF_OFF) {</span>
<span class="lineNum">    2777 </span>            :         /* Kill the AOF saving child as the AOF we already have may be longer
<span class="lineNum">    2778 </span>            :          * but contains the full dataset anyway. */
<span class="lineNum">    2779 </span><span class="lineCov">         46 :         if (server.aof_child_pid != -1) {</span>
<span class="lineNum">    2780 </span>            :             /* If we have AOF enabled but haven't written the AOF yet, don't
<span class="lineNum">    2781 </span>            :              * shutdown or else the dataset will be lost. */
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :             if (server.aof_state == AOF_WAIT_REWRITE) {</span>
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING, &quot;Writing initial AOF, can't exit.&quot;);</span>
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :                 return C_ERR;</span>
<span class="lineNum">    2785 </span>            :             }
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,</span>
<span class="lineNum">    2787 </span>            :                 &quot;There is a child rewriting the AOF. Killing it!&quot;);
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :             kill(server.aof_child_pid,SIGUSR1);</span>
<span class="lineNum">    2789 </span>            :         }
<span class="lineNum">    2790 </span>            :         /* Append only file: flush buffers and fsync() the AOF at exit */
<span class="lineNum">    2791 </span><span class="lineCov">         46 :         serverLog(LL_NOTICE,&quot;Calling fsync() on the AOF file.&quot;);</span>
<span class="lineNum">    2792 </span><span class="lineCov">         46 :         flushAppendOnlyFile(1);</span>
<span class="lineNum">    2793 </span><span class="lineCov">         46 :         redis_fsync(server.aof_fd);</span>
<span class="lineNum">    2794 </span>            :     }
<span class="lineNum">    2795 </span>            : 
<span class="lineNum">    2796 </span>            :     /* Create a new RDB file before exiting. */
<span class="lineNum">    2797 </span><span class="lineCov">        411 :     if ((server.saveparamslen &gt; 0 &amp;&amp; !nosave) || save) {</span>
<span class="lineNum">    2798 </span><span class="lineCov">        407 :         serverLog(LL_NOTICE,&quot;Saving the final RDB snapshot before exiting.&quot;);</span>
<span class="lineNum">    2799 </span>            :         /* Snapshotting. Perform a SYNC SAVE and exit */
<span class="lineNum">    2800 </span><span class="lineCov">        407 :         rdbSaveInfo rsi, *rsiptr;</span>
<span class="lineNum">    2801 </span><span class="lineCov">        407 :         rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span>
<span class="lineNum">    2802 </span><span class="lineCov">        407 :         if (rdbSave(server.rdb_filename,rsiptr) != C_OK) {</span>
<span class="lineNum">    2803 </span>            :             /* Ooops.. error saving! The best we can do is to continue
<span class="lineNum">    2804 </span>            :              * operating. Note that if there was a background saving process,
<span class="lineNum">    2805 </span>            :              * in the next cron() Redis will be notified that the background
<span class="lineNum">    2806 </span>            :              * saving aborted, handling special stuff like slaves pending for
<span class="lineNum">    2807 </span>            :              * synchronization... */
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,&quot;Error trying to save the DB, can't exit.&quot;);</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :             return C_ERR;</span>
<span class="lineNum">    2810 </span>            :         }
<span class="lineNum">    2811 </span>            :     }
<span class="lineNum">    2812 </span>            : 
<span class="lineNum">    2813 </span>            :     /* Remove the pid file if possible and needed. */
<span class="lineNum">    2814 </span><span class="lineCov">        411 :     if (server.daemonize || server.pidfile) {</span>
<span class="lineNum">    2815 </span><span class="lineCov">        411 :         serverLog(LL_NOTICE,&quot;Removing the pid file.&quot;);</span>
<span class="lineNum">    2816 </span><span class="lineCov">        411 :         unlink(server.pidfile);</span>
<span class="lineNum">    2817 </span>            :     }
<span class="lineNum">    2818 </span>            : 
<span class="lineNum">    2819 </span>            :     /* Best effort flush of slave output buffers, so that we hopefully
<span class="lineNum">    2820 </span>            :      * send them pending writes. */
<span class="lineNum">    2821 </span><span class="lineCov">        411 :     flushSlavesOutputBuffers();</span>
<span class="lineNum">    2822 </span>            : 
<span class="lineNum">    2823 </span>            :     /* Close the listening sockets. Apparently this allows faster restarts. */
<span class="lineNum">    2824 </span><span class="lineCov">        411 :     closeListeningSockets(1);</span>
<span class="lineNum">    2825 </span><span class="lineCov">       1233 :     serverLog(LL_WARNING,&quot;%s is now ready to exit, bye bye...&quot;,</span>
<span class="lineNum">    2826 </span><span class="lineCov">        411 :         server.sentinel_mode ? &quot;Sentinel&quot; : &quot;Redis&quot;);</span>
<span class="lineNum">    2827 </span><span class="lineCov">        411 :     return C_OK;</span>
<span class="lineNum">    2828 </span>            : }
<span class="lineNum">    2829 </span>            : 
<span class="lineNum">    2830 </span>            : /*================================== Commands =============================== */
<span class="lineNum">    2831 </span>            : 
<span class="lineNum">    2832 </span>            : /* Sometimes Redis cannot accept write commands because there is a perstence
<span class="lineNum">    2833 </span>            :  * error with the RDB or AOF file, and Redis is configured in order to stop
<span class="lineNum">    2834 </span>            :  * accepting writes in such situation. This function returns if such a
<span class="lineNum">    2835 </span>            :  * condition is active, and the type of the condition.
<span class="lineNum">    2836 </span>            :  *
<span class="lineNum">    2837 </span>            :  * Function return values:
<span class="lineNum">    2838 </span>            :  *
<span class="lineNum">    2839 </span>            :  * DISK_ERROR_TYPE_NONE:    No problems, we can accept writes.
<span class="lineNum">    2840 </span>            :  * DISK_ERROR_TYPE_AOF:     Don't accept writes: AOF errors.
<a name="2841"><span class="lineNum">    2841 </span>            :  * DISK_ERROR_TYPE_RDB:     Don't accept writes: RDB errors.</a>
<span class="lineNum">    2842 </span>            :  */
<span class="lineNum">    2843 </span><span class="lineCov">     490211 : int writeCommandsDeniedByDiskError(void) {</span>
<span class="lineNum">    2844 </span><span class="lineCov">   55914451 :     if (server.stop_writes_on_bgsave_err &amp;&amp;</span>
<span class="lineNum">    2845 </span><span class="lineCov">   55914451 :         server.saveparamslen &gt; 0 &amp;&amp;</span>
<span class="lineNum">    2846 </span><span class="lineCov">   54314294 :         server.lastbgsave_status == C_ERR)</span>
<span class="lineNum">    2847 </span>            :     {
<span class="lineNum">    2848 </span>            :         return DISK_ERROR_TYPE_RDB;
<span class="lineNum">    2849 </span><span class="lineCov">   55914451 :     } else if (server.aof_state != AOF_OFF &amp;&amp;</span>
<span class="lineNum">    2850 </span><span class="lineCov">    9016597 :                server.aof_last_write_status == C_ERR)</span>
<span class="lineNum">    2851 </span>            :     {
<span class="lineNum">    2852 </span>            :         return DISK_ERROR_TYPE_AOF;
<span class="lineNum">    2853 </span>            :     } else {
<span class="lineNum">    2854 </span><span class="lineCov">     490211 :         return DISK_ERROR_TYPE_NONE;</span>
<span class="lineNum">    2855 </span>            :     }
<span class="lineNum">    2856 </span>            : }
<span class="lineNum">    2857 </span>            : 
<span class="lineNum">    2858 </span>            : /* Return zero if strings are the same, non-zero if they are not.
<span class="lineNum">    2859 </span>            :  * The comparison is performed in a way that prevents an attacker to obtain
<span class="lineNum">    2860 </span>            :  * information about the nature of the strings just monitoring the execution
<span class="lineNum">    2861 </span>            :  * time of the function.
<span class="lineNum">    2862 </span>            :  *
<span class="lineNum">    2863 </span>            :  * Note that limiting the comparison length to strings up to 512 bytes we
<span class="lineNum">    2864 </span>            :  * can avoid leaking any information about the password length and any
<a name="2865"><span class="lineNum">    2865 </span>            :  * possible branch misprediction related leak.</a>
<span class="lineNum">    2866 </span>            :  */
<span class="lineNum">    2867 </span><span class="lineCov">         15 : int time_independent_strcmp(char *a, char *b) {</span>
<span class="lineNum">    2868 </span><span class="lineCov">         15 :     char bufa[CONFIG_AUTHPASS_MAX_LEN], bufb[CONFIG_AUTHPASS_MAX_LEN];</span>
<span class="lineNum">    2869 </span>            :     /* The above two strlen perform len(a) + len(b) operations where either
<span class="lineNum">    2870 </span>            :      * a or b are fixed (our password) length, and the difference is only
<span class="lineNum">    2871 </span>            :      * relative to the length of the user provided string, so no information
<span class="lineNum">    2872 </span>            :      * leak is possible in the following two lines of code. */
<span class="lineNum">    2873 </span><span class="lineCov">         15 :     unsigned int alen = strlen(a);</span>
<span class="lineNum">    2874 </span><span class="lineCov">         15 :     unsigned int blen = strlen(b);</span>
<span class="lineNum">    2875 </span><span class="lineCov">         15 :     unsigned int j;</span>
<span class="lineNum">    2876 </span><span class="lineCov">         15 :     int diff = 0;</span>
<span class="lineNum">    2877 </span>            : 
<span class="lineNum">    2878 </span>            :     /* We can't compare strings longer than our static buffers.
<span class="lineNum">    2879 </span>            :      * Note that this will never pass the first test in practical circumstances
<span class="lineNum">    2880 </span>            :      * so there is no info leak. */
<span class="lineNum">    2881 </span><span class="lineCov">         15 :     if (alen &gt; sizeof(bufa) || blen &gt; sizeof(bufb)) return 1;</span>
<span class="lineNum">    2882 </span>            : 
<span class="lineNum">    2883 </span><span class="lineCov">         15 :     memset(bufa,0,sizeof(bufa));        /* Constant time. */</span>
<span class="lineNum">    2884 </span><span class="lineCov">         15 :     memset(bufb,0,sizeof(bufb));        /* Constant time. */</span>
<span class="lineNum">    2885 </span>            :     /* Again the time of the following two copies is proportional to
<span class="lineNum">    2886 </span>            :      * len(a) + len(b) so no info is leaked. */
<span class="lineNum">    2887 </span><span class="lineCov">         15 :     memcpy(bufa,a,alen);</span>
<span class="lineNum">    2888 </span><span class="lineCov">         15 :     memcpy(bufb,b,blen);</span>
<span class="lineNum">    2889 </span>            : 
<span class="lineNum">    2890 </span>            :     /* Always compare all the chars in the two buffers without
<span class="lineNum">    2891 </span>            :      * conditional expressions. */
<span class="lineNum">    2892 </span><span class="lineCov">       7695 :     for (j = 0; j &lt; sizeof(bufa); j++) {</span>
<span class="lineNum">    2893 </span><span class="lineCov">       7680 :         diff |= (bufa[j] ^ bufb[j]);</span>
<span class="lineNum">    2894 </span>            :     }
<span class="lineNum">    2895 </span>            :     /* Length must be equal as well. */
<span class="lineNum">    2896 </span><span class="lineCov">         15 :     diff |= alen ^ blen;</span>
<span class="lineNum">    2897 </span><span class="lineCov">         15 :     return diff; /* If zero strings are the same. */</span>
<a name="2898"><span class="lineNum">    2898 </span>            : }</a>
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span><span class="lineCov">         18 : void authCommand(client *c) {</span>
<span class="lineNum">    2901 </span><span class="lineCov">         18 :     if (!server.requirepass) {</span>
<span class="lineNum">    2902 </span><span class="lineCov">          3 :         addReplyError(c,&quot;Client sent AUTH, but no password is set&quot;);</span>
<span class="lineNum">    2903 </span><span class="lineCov">         15 :     } else if (!time_independent_strcmp(c-&gt;argv[1]-&gt;ptr, server.requirepass)) {</span>
<span class="lineNum">    2904 </span><span class="lineCov">          9 :       c-&gt;authenticated = 1;</span>
<span class="lineNum">    2905 </span><span class="lineCov">          9 :       addReply(c,shared.ok);</span>
<span class="lineNum">    2906 </span>            :     } else {
<span class="lineNum">    2907 </span><span class="lineCov">          6 :       c-&gt;authenticated = 0;</span>
<span class="lineNum">    2908 </span><span class="lineCov">          6 :       addReplyError(c,&quot;invalid password&quot;);</span>
<span class="lineNum">    2909 </span>            :     }
<span class="lineNum">    2910 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">    2911 </span>            : 
<a name="2912"><span class="lineNum">    2912 </span>            : /* The PING command. It works in a different way if the client is in</a>
<span class="lineNum">    2913 </span>            :  * in Pub/Sub mode. */
<span class="lineNum">    2914 </span><span class="lineCov">     201601 : void pingCommand(client *c) {</span>
<span class="lineNum">    2915 </span>            :     /* The command takes zero or one arguments. */
<span class="lineNum">    2916 </span><span class="lineCov">     201601 :     if (c-&gt;argc &gt; 2) {</span>
<span class="lineNum">    2917 </span><span class="lineCov">          6 :         addReplyErrorFormat(c,&quot;wrong number of arguments for '%s' command&quot;,</span>
<span class="lineNum">    2918 </span><span class="lineCov">          3 :             c-&gt;cmd-&gt;name);</span>
<span class="lineNum">    2919 </span><span class="lineCov">          3 :         return;</span>
<span class="lineNum">    2920 </span>            :     }
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span><span class="lineCov">     201598 :     if (c-&gt;flags &amp; CLIENT_PUBSUB) {</span>
<span class="lineNum">    2923 </span><span class="lineCov">          4 :         addReply(c,shared.mbulkhdr[2]);</span>
<span class="lineNum">    2924 </span><span class="lineCov">          4 :         addReplyBulkCBuffer(c,&quot;pong&quot;,4);</span>
<span class="lineNum">    2925 </span><span class="lineCov">          4 :         if (c-&gt;argc == 1)</span>
<span class="lineNum">    2926 </span><span class="lineCov">          2 :             addReplyBulkCBuffer(c,&quot;&quot;,0);</span>
<span class="lineNum">    2927 </span>            :         else
<span class="lineNum">    2928 </span><span class="lineCov">          2 :             addReplyBulk(c,c-&gt;argv[1]);</span>
<span class="lineNum">    2929 </span>            :     } else {
<span class="lineNum">    2930 </span><span class="lineCov">     201594 :         if (c-&gt;argc == 1)</span>
<span class="lineNum">    2931 </span><span class="lineCov">     201594 :             addReply(c,shared.pong);</span>
<span class="lineNum">    2932 </span>            :         else
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :             addReplyBulk(c,c-&gt;argv[1]);</span>
<span class="lineNum">    2934 </span>            :     }
<a name="2935"><span class="lineNum">    2935 </span>            : }</a>
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 : void echoCommand(client *c) {</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :     addReplyBulk(c,c-&gt;argv[1]);</span>
<a name="2939"><span class="lineNum">    2939 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2940 </span>            : 
<span class="lineNum">    2941 </span><span class="lineCov">          2 : void timeCommand(client *c) {</span>
<span class="lineNum">    2942 </span><span class="lineCov">          2 :     struct timeval tv;</span>
<span class="lineNum">    2943 </span>            : 
<span class="lineNum">    2944 </span>            :     /* gettimeofday() can only fail if &amp;tv is a bad address so we
<span class="lineNum">    2945 </span>            :      * don't check for errors. */
<span class="lineNum">    2946 </span><span class="lineCov">          2 :     gettimeofday(&amp;tv,NULL);</span>
<span class="lineNum">    2947 </span><span class="lineCov">          2 :     addReplyMultiBulkLen(c,2);</span>
<span class="lineNum">    2948 </span><span class="lineCov">          2 :     addReplyBulkLongLong(c,tv.tv_sec);</span>
<span class="lineNum">    2949 </span><span class="lineCov">          2 :     addReplyBulkLongLong(c,tv.tv_usec);</span>
<span class="lineNum">    2950 </span><span class="lineCov">          2 : }</span>
<a name="2951"><span class="lineNum">    2951 </span>            : </a>
<span class="lineNum">    2952 </span>            : /* Helper function for addReplyCommand() to output flags. */
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 : int addReplyCommandFlag(client *c, struct redisCommand *cmd, int f, char *reply) {</span>
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :     if (cmd-&gt;flags &amp; f) {</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :         addReplyStatus(c, reply);</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    2957 </span>            :     }
<span class="lineNum">    2958 </span>            :     return 0;
<span class="lineNum">    2959 </span>            : }
<a name="2960"><span class="lineNum">    2960 </span>            : </a>
<span class="lineNum">    2961 </span>            : /* Output the representation of a Redis command. Used by the COMMAND command. */
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 : void addReplyCommand(client *c, struct redisCommand *cmd) {</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :     if (!cmd) {</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :         addReply(c, shared.nullbulk);</span>
<span class="lineNum">    2965 </span>            :     } else {
<span class="lineNum">    2966 </span>            :         /* We are adding: command name, arg count, flags, first, last, offset */
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :         addReplyMultiBulkLen(c, 6);</span>
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :         addReplyBulkCString(c, cmd-&gt;name);</span>
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :         addReplyLongLong(c, cmd-&gt;arity);</span>
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 :         int flagcount = 0;</span>
<span class="lineNum">    2972 </span><span class="lineNoCov">          0 :         void *flaglen = addDeferredMultiBulkLength(c);</span>
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_WRITE, &quot;write&quot;);</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_READONLY, &quot;readonly&quot;);</span>
<span class="lineNum">    2975 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_DENYOOM, &quot;denyoom&quot;);</span>
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_ADMIN, &quot;admin&quot;);</span>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_PUBSUB, &quot;pubsub&quot;);</span>
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_NOSCRIPT, &quot;noscript&quot;);</span>
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_RANDOM, &quot;random&quot;);</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,&quot;sort_for_script&quot;);</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, &quot;loading&quot;);</span>
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, &quot;stale&quot;);</span>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, &quot;skip_monitor&quot;);</span>
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, &quot;asking&quot;);</span>
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :         flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, &quot;fast&quot;);</span>
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :         if ((cmd-&gt;getkeys_proc &amp;&amp; !(cmd-&gt;flags &amp; CMD_MODULE)) ||</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :             cmd-&gt;flags &amp; CMD_MODULE_GETKEYS)</span>
<span class="lineNum">    2988 </span>            :         {
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :             addReplyStatus(c, &quot;movablekeys&quot;);</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :             flagcount += 1;</span>
<span class="lineNum">    2991 </span>            :         }
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :         setDeferredMultiBulkLength(c, flaglen, flagcount);</span>
<span class="lineNum">    2993 </span>            : 
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :         addReplyLongLong(c, cmd-&gt;firstkey);</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :         addReplyLongLong(c, cmd-&gt;lastkey);</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :         addReplyLongLong(c, cmd-&gt;keystep);</span>
<span class="lineNum">    2997 </span>            :     }
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 : }</span>
<a name="2999"><span class="lineNum">    2999 </span>            : </a>
<span class="lineNum">    3000 </span>            : /* COMMAND &lt;subcommand&gt; &lt;args&gt; */
<span class="lineNum">    3001 </span><span class="lineCov">          6 : void commandCommand(client *c) {</span>
<span class="lineNum">    3002 </span><span class="lineCov">          6 :     dictIterator *di;</span>
<span class="lineNum">    3003 </span><span class="lineCov">          6 :     dictEntry *de;</span>
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span><span class="lineCov">          6 :     if (c-&gt;argc == 2 &amp;&amp; !strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;help&quot;)) {</span>
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :         const char *help[] = {</span>
<span class="lineNum">    3007 </span>            : &quot;(no subcommand) -- Return details about all Redis commands.&quot;,
<span class="lineNum">    3008 </span>            : &quot;COUNT -- Return the total number of commands in this Redis server.&quot;,
<span class="lineNum">    3009 </span>            : &quot;GETKEYS &lt;full-command&gt; -- Return the keys from a full Redis command.&quot;,
<span class="lineNum">    3010 </span>            : &quot;INFO [command-name ...] -- Return details about multiple Redis commands.&quot;,
<span class="lineNum">    3011 </span>            : NULL
<span class="lineNum">    3012 </span>            :         };
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :         addReplyHelp(c, help);</span>
<span class="lineNum">    3014 </span><span class="lineCov">          6 :     } else if (c-&gt;argc == 1) {</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :         addReplyMultiBulkLen(c, dictSize(server.commands));</span>
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :         di = dictGetIterator(server.commands);</span>
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :         while ((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :             addReplyCommand(c, dictGetVal(de));</span>
<span class="lineNum">    3019 </span>            :         }
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :         dictReleaseIterator(di);</span>
<span class="lineNum">    3021 </span><span class="lineCov">          6 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr, &quot;info&quot;)) {</span>
<span class="lineNum">    3022 </span><span class="lineNoCov">          0 :         int i;</span>
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :         addReplyMultiBulkLen(c, c-&gt;argc-2);</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :         for (i = 2; i &lt; c-&gt;argc; i++) {</span>
<span class="lineNum">    3025 </span><span class="lineNoCov">          0 :             addReplyCommand(c, dictFetchValue(server.commands, c-&gt;argv[i]-&gt;ptr));</span>
<span class="lineNum">    3026 </span>            :         }
<span class="lineNum">    3027 </span><span class="lineCov">          6 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr, &quot;count&quot;) &amp;&amp; c-&gt;argc == 2) {</span>
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 :         addReplyLongLong(c, dictSize(server.commands));</span>
<span class="lineNum">    3029 </span><span class="lineCov">         12 :     } else if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,&quot;getkeys&quot;) &amp;&amp; c-&gt;argc &gt;= 3) {</span>
<span class="lineNum">    3030 </span><span class="lineCov">          6 :         struct redisCommand *cmd = lookupCommand(c-&gt;argv[2]-&gt;ptr);</span>
<span class="lineNum">    3031 </span><span class="lineCov">          6 :         int *keys, numkeys, j;</span>
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineCov">          6 :         if (!cmd) {</span>
<span class="lineNum">    3034 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;Invalid command specified&quot;);</span>
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    3036 </span><span class="lineCov">          6 :         } else if (cmd-&gt;getkeys_proc == NULL &amp;&amp; cmd-&gt;firstkey == 0) {</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;The command has no key arguments&quot;);</span>
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    3039 </span><span class="lineCov">          6 :         } else if ((cmd-&gt;arity &gt; 0 &amp;&amp; cmd-&gt;arity != c-&gt;argc-2) ||</span>
<span class="lineNum">    3040 </span><span class="lineCov">          6 :                    ((c-&gt;argc-2) &lt; -cmd-&gt;arity))</span>
<span class="lineNum">    3041 </span>            :         {
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;Invalid number of arguments specified for command&quot;);</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :             return;</span>
<span class="lineNum">    3044 </span>            :         }
<span class="lineNum">    3045 </span>            : 
<span class="lineNum">    3046 </span><span class="lineCov">          6 :         keys = getKeysFromCommand(cmd,c-&gt;argv+2,c-&gt;argc-2,&amp;numkeys);</span>
<span class="lineNum">    3047 </span><span class="lineCov">          6 :         if (!keys) {</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :             addReplyError(c,&quot;Invalid arguments specified for command&quot;);</span>
<span class="lineNum">    3049 </span>            :         } else {
<span class="lineNum">    3050 </span><span class="lineCov">          6 :             addReplyMultiBulkLen(c,numkeys);</span>
<span class="lineNum">    3051 </span><span class="lineCov">         18 :             for (j = 0; j &lt; numkeys; j++) addReplyBulk(c,c-&gt;argv[keys[j]+2]);</span>
<span class="lineNum">    3052 </span><span class="lineCov">          6 :             getKeysFreeResult(keys);</span>
<span class="lineNum">    3053 </span>            :         }
<span class="lineNum">    3054 </span>            :     } else {
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :         addReplySubcommandSyntaxError(c);</span>
<span class="lineNum">    3056 </span>            :     }
<span class="lineNum">    3057 </span>            : }
<span class="lineNum">    3058 </span>            : 
<a name="3059"><span class="lineNum">    3059 </span>            : /* Convert an amount of bytes into a human readable string in the form</a>
<span class="lineNum">    3060 </span>            :  * of 100B, 2G, 100M, 4K, and so forth. */
<span class="lineNum">    3061 </span><span class="lineCov">     214354 : void bytesToHuman(char *s, unsigned long long n) {</span>
<span class="lineNum">    3062 </span><span class="lineCov">     214354 :     double d;</span>
<span class="lineNum">    3063 </span>            : 
<span class="lineNum">    3064 </span><span class="lineCov">     214354 :     if (n &lt; 1024) {</span>
<span class="lineNum">    3065 </span>            :         /* Bytes */
<span class="lineNum">    3066 </span><span class="lineCov">      33209 :         sprintf(s,&quot;%lluB&quot;,n);</span>
<span class="lineNum">    3067 </span><span class="lineCov">     181145 :     } else if (n &lt; (1024*1024)) {</span>
<span class="lineNum">    3068 </span><span class="lineCov">     117510 :         d = (double)n/(1024);</span>
<span class="lineNum">    3069 </span><span class="lineCov">     117510 :         sprintf(s,&quot;%.2fK&quot;,d);</span>
<span class="lineNum">    3070 </span><span class="lineCov">      63635 :     } else if (n &lt; (1024LL*1024*1024)) {</span>
<span class="lineNum">    3071 </span><span class="lineCov">      33013 :         d = (double)n/(1024*1024);</span>
<span class="lineNum">    3072 </span><span class="lineCov">      33013 :         sprintf(s,&quot;%.2fM&quot;,d);</span>
<span class="lineNum">    3073 </span><span class="lineCov">      30622 :     } else if (n &lt; (1024LL*1024*1024*1024)) {</span>
<span class="lineNum">    3074 </span><span class="lineCov">      30622 :         d = (double)n/(1024LL*1024*1024);</span>
<span class="lineNum">    3075 </span><span class="lineCov">      30622 :         sprintf(s,&quot;%.2fG&quot;,d);</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :     } else if (n &lt; (1024LL*1024*1024*1024*1024)) {</span>
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :         d = (double)n/(1024LL*1024*1024*1024);</span>
<span class="lineNum">    3078 </span><span class="lineNoCov">          0 :         sprintf(s,&quot;%.2fT&quot;,d);</span>
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :     } else if (n &lt; (1024LL*1024*1024*1024*1024*1024)) {</span>
<span class="lineNum">    3080 </span><span class="lineNoCov">          0 :         d = (double)n/(1024LL*1024*1024*1024*1024);</span>
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :         sprintf(s,&quot;%.2fP&quot;,d);</span>
<span class="lineNum">    3082 </span>            :     } else {
<span class="lineNum">    3083 </span>            :         /* Let's hope we never need this */
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :         sprintf(s,&quot;%lluB&quot;,n);</span>
<span class="lineNum">    3085 </span>            :     }
<span class="lineNum">    3086 </span><span class="lineCov">     214354 : }</span>
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span>            : /* Create the string returned by the INFO command. This is decoupled
<a name="3089"><span class="lineNum">    3089 </span>            :  * by the INFO command itself as we need to report the same information</a>
<span class="lineNum">    3090 </span>            :  * on memory corruption problems. */
<span class="lineNum">    3091 </span><span class="lineCov">      30776 : sds genRedisInfoString(char *section) {</span>
<span class="lineNum">    3092 </span><span class="lineCov">      30776 :     sds info = sdsempty();</span>
<span class="lineNum">    3093 </span><span class="lineCov">      30776 :     time_t uptime = server.unixtime-server.stat_starttime;</span>
<span class="lineNum">    3094 </span><span class="lineCov">      30776 :     int j;</span>
<span class="lineNum">    3095 </span><span class="lineCov">      30776 :     struct rusage self_ru, c_ru;</span>
<span class="lineNum">    3096 </span><span class="lineCov">      30776 :     int allsections = 0, defsections = 0;</span>
<span class="lineNum">    3097 </span><span class="lineCov">      30776 :     int sections = 0;</span>
<span class="lineNum">    3098 </span>            : 
<span class="lineNum">    3099 </span><span class="lineCov">      30776 :     if (section == NULL) section = &quot;default&quot;;</span>
<span class="lineNum">    3100 </span><span class="lineCov">      30776 :     allsections = strcasecmp(section,&quot;all&quot;) == 0;</span>
<span class="lineNum">    3101 </span><span class="lineCov">      30776 :     defsections = strcasecmp(section,&quot;default&quot;) == 0;</span>
<span class="lineNum">    3102 </span>            : 
<span class="lineNum">    3103 </span><span class="lineCov">      30776 :     getrusage(RUSAGE_SELF, &amp;self_ru);</span>
<span class="lineNum">    3104 </span><span class="lineCov">      30776 :     getrusage(RUSAGE_CHILDREN, &amp;c_ru);</span>
<span class="lineNum">    3105 </span>            : 
<span class="lineNum">    3106 </span>            :     /* Server */
<span class="lineNum">    3107 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;server&quot;)) {</span>
<span class="lineNum">    3108 </span><span class="lineCov">      30618 :         static int call_uname = 1;</span>
<span class="lineNum">    3109 </span><span class="lineCov">      30618 :         static struct utsname name;</span>
<span class="lineNum">    3110 </span><span class="lineCov">      30618 :         char *mode;</span>
<span class="lineNum">    3111 </span>            : 
<span class="lineNum">    3112 </span><span class="lineCov">      30618 :         if (server.cluster_enabled) mode = &quot;cluster&quot;;</span>
<span class="lineNum">    3113 </span><span class="lineCov">      30618 :         else if (server.sentinel_mode) mode = &quot;sentinel&quot;;</span>
<span class="lineNum">    3114 </span><span class="lineCov">      30618 :         else mode = &quot;standalone&quot;;</span>
<span class="lineNum">    3115 </span>            : 
<span class="lineNum">    3116 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span><span class="lineCov">      30618 :         if (call_uname) {</span>
<span class="lineNum">    3119 </span>            :             /* Uname can be slow and is always the same output. Cache it. */
<span class="lineNum">    3120 </span><span class="lineCov">        193 :             uname(&amp;name);</span>
<span class="lineNum">    3121 </span><span class="lineCov">        193 :             call_uname = 0;</span>
<span class="lineNum">    3122 </span>            :         }
<span class="lineNum">    3123 </span>            : 
<span class="lineNum">    3124 </span><span class="lineCov">      30618 :         unsigned int lruclock;</span>
<span class="lineNum">    3125 </span><span class="lineCov">      30618 :         atomicGet(server.lruclock,lruclock);</span>
<span class="lineNum">    3126 </span><span class="lineCov">      61236 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3127 </span>            :             &quot;# Server\r\n&quot;
<span class="lineNum">    3128 </span>            :             &quot;redis_version:%s\r\n&quot;
<span class="lineNum">    3129 </span>            :             &quot;redis_git_sha1:%s\r\n&quot;
<span class="lineNum">    3130 </span>            :             &quot;redis_git_dirty:%d\r\n&quot;
<span class="lineNum">    3131 </span>            :             &quot;redis_build_id:%llx\r\n&quot;
<span class="lineNum">    3132 </span>            :             &quot;redis_mode:%s\r\n&quot;
<span class="lineNum">    3133 </span>            :             &quot;os:%s %s %s\r\n&quot;
<span class="lineNum">    3134 </span>            :             &quot;arch_bits:%d\r\n&quot;
<span class="lineNum">    3135 </span>            :             &quot;multiplexing_api:%s\r\n&quot;
<span class="lineNum">    3136 </span>            :             &quot;atomicvar_api:%s\r\n&quot;
<span class="lineNum">    3137 </span>            :             &quot;gcc_version:%d.%d.%d\r\n&quot;
<span class="lineNum">    3138 </span>            :             &quot;process_id:%ld\r\n&quot;
<span class="lineNum">    3139 </span>            :             &quot;run_id:%s\r\n&quot;
<span class="lineNum">    3140 </span>            :             &quot;tcp_port:%d\r\n&quot;
<span class="lineNum">    3141 </span>            :             &quot;uptime_in_seconds:%jd\r\n&quot;
<span class="lineNum">    3142 </span>            :             &quot;uptime_in_days:%jd\r\n&quot;
<span class="lineNum">    3143 </span>            :             &quot;hz:%d\r\n&quot;
<span class="lineNum">    3144 </span>            :             &quot;configured_hz:%d\r\n&quot;
<span class="lineNum">    3145 </span>            :             &quot;lru_clock:%ld\r\n&quot;
<span class="lineNum">    3146 </span>            :             &quot;executable:%s\r\n&quot;
<span class="lineNum">    3147 </span>            :             &quot;config_file:%s\r\n&quot;,
<span class="lineNum">    3148 </span>            :             REDIS_VERSION,
<span class="lineNum">    3149 </span>            :             redisGitSHA1(),
<span class="lineNum">    3150 </span><span class="lineCov">      30618 :             strtol(redisGitDirty(),NULL,10) &gt; 0,</span>
<span class="lineNum">    3151 </span><span class="lineCov">      30618 :             (unsigned long long) redisBuildId(),</span>
<span class="lineNum">    3152 </span>            :             mode,
<span class="lineNum">    3153 </span>            :             name.sysname, name.release, name.machine,
<span class="lineNum">    3154 </span>            :             server.arch_bits,
<span class="lineNum">    3155 </span>            :             aeGetApiName(),
<span class="lineNum">    3156 </span>            :             REDIS_ATOMIC_API,
<span class="lineNum">    3157 </span>            : #ifdef __GNUC__
<span class="lineNum">    3158 </span>            :             __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,
<span class="lineNum">    3159 </span>            : #else
<span class="lineNum">    3160 </span>            :             0,0,0,
<span class="lineNum">    3161 </span>            : #endif
<span class="lineNum">    3162 </span><span class="lineCov">      30618 :             (long) getpid(),</span>
<span class="lineNum">    3163 </span>            :             server.runid,
<span class="lineNum">    3164 </span>            :             server.port,
<span class="lineNum">    3165 </span>            :             (intmax_t)uptime,
<span class="lineNum">    3166 </span><span class="lineCov">      30618 :             (intmax_t)(uptime/(3600*24)),</span>
<span class="lineNum">    3167 </span>            :             server.hz,
<span class="lineNum">    3168 </span>            :             server.config_hz,
<span class="lineNum">    3169 </span>            :             (unsigned long) lruclock,
<span class="lineNum">    3170 </span><span class="lineCov">      30618 :             server.executable ? server.executable : &quot;&quot;,</span>
<span class="lineNum">    3171 </span><span class="lineCov">      30618 :             server.configfile ? server.configfile : &quot;&quot;);</span>
<span class="lineNum">    3172 </span>            :     }
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span>            :     /* Clients */
<span class="lineNum">    3175 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;clients&quot;)) {</span>
<span class="lineNum">    3176 </span>            :         size_t maxin, maxout;
<span class="lineNum">    3177 </span><span class="lineCov">      30618 :         getExpansiveClientsInfo(&amp;maxin,&amp;maxout);</span>
<span class="lineNum">    3178 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3179 </span><span class="lineCov">      61236 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3180 </span>            :             &quot;# Clients\r\n&quot;
<span class="lineNum">    3181 </span>            :             &quot;connected_clients:%lu\r\n&quot;
<span class="lineNum">    3182 </span>            :             &quot;client_recent_max_input_buffer:%zu\r\n&quot;
<span class="lineNum">    3183 </span>            :             &quot;client_recent_max_output_buffer:%zu\r\n&quot;
<span class="lineNum">    3184 </span>            :             &quot;blocked_clients:%d\r\n&quot;,
<span class="lineNum">    3185 </span><span class="lineCov">      30618 :             listLength(server.clients)-listLength(server.slaves),</span>
<span class="lineNum">    3186 </span>            :             maxin, maxout,
<span class="lineNum">    3187 </span>            :             server.blocked_clients);
<span class="lineNum">    3188 </span>            :     }
<span class="lineNum">    3189 </span>            : 
<span class="lineNum">    3190 </span>            :     /* Memory */
<span class="lineNum">    3191 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;memory&quot;)) {</span>
<span class="lineNum">    3192 </span><span class="lineCov">      30622 :         char hmem[64];</span>
<span class="lineNum">    3193 </span><span class="lineCov">      30622 :         char peak_hmem[64];</span>
<span class="lineNum">    3194 </span><span class="lineCov">      30622 :         char total_system_hmem[64];</span>
<span class="lineNum">    3195 </span><span class="lineCov">      30622 :         char used_memory_lua_hmem[64];</span>
<span class="lineNum">    3196 </span><span class="lineCov">      30622 :         char used_memory_scripts_hmem[64];</span>
<span class="lineNum">    3197 </span><span class="lineCov">      30622 :         char used_memory_rss_hmem[64];</span>
<span class="lineNum">    3198 </span><span class="lineCov">      30622 :         char maxmemory_hmem[64];</span>
<span class="lineNum">    3199 </span><span class="lineCov">      30622 :         size_t zmalloc_used = zmalloc_used_memory();</span>
<span class="lineNum">    3200 </span><span class="lineCov">      30622 :         size_t total_system_mem = server.system_memory_size;</span>
<span class="lineNum">    3201 </span><span class="lineCov">      30622 :         const char *evict_policy = evictPolicyToString();</span>
<span class="lineNum">    3202 </span><span class="lineCov">      30622 :         long long memory_lua = (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;</span>
<span class="lineNum">    3203 </span><span class="lineCov">      30622 :         struct redisMemOverhead *mh = getMemoryOverheadData();</span>
<span class="lineNum">    3204 </span>            : 
<span class="lineNum">    3205 </span>            :         /* Peak memory is updated from time to time by serverCron() so it
<span class="lineNum">    3206 </span>            :          * may happen that the instantaneous value is slightly bigger than
<span class="lineNum">    3207 </span>            :          * the peak value. This may confuse users, so we update the peak
<span class="lineNum">    3208 </span>            :          * if found smaller than the current memory usage. */
<span class="lineNum">    3209 </span><span class="lineCov">      30622 :         if (zmalloc_used &gt; server.stat_peak_memory)</span>
<span class="lineNum">    3210 </span><span class="lineCov">       2182 :             server.stat_peak_memory = zmalloc_used;</span>
<span class="lineNum">    3211 </span>            : 
<span class="lineNum">    3212 </span><span class="lineCov">      30622 :         bytesToHuman(hmem,zmalloc_used);</span>
<span class="lineNum">    3213 </span><span class="lineCov">      30622 :         bytesToHuman(peak_hmem,server.stat_peak_memory);</span>
<span class="lineNum">    3214 </span><span class="lineCov">      30622 :         bytesToHuman(total_system_hmem,total_system_mem);</span>
<span class="lineNum">    3215 </span><span class="lineCov">      30622 :         bytesToHuman(used_memory_lua_hmem,memory_lua);</span>
<span class="lineNum">    3216 </span><span class="lineCov">      30622 :         bytesToHuman(used_memory_scripts_hmem,mh-&gt;lua_caches);</span>
<span class="lineNum">    3217 </span><span class="lineCov">      30622 :         bytesToHuman(used_memory_rss_hmem,server.cron_malloc_stats.process_rss);</span>
<span class="lineNum">    3218 </span><span class="lineCov">      30622 :         bytesToHuman(maxmemory_hmem,server.maxmemory);</span>
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span><span class="lineCov">      30622 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3221 </span><span class="lineCov">      30622 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3222 </span>            :             &quot;# Memory\r\n&quot;
<span class="lineNum">    3223 </span>            :             &quot;used_memory:%zu\r\n&quot;
<span class="lineNum">    3224 </span>            :             &quot;used_memory_human:%s\r\n&quot;
<span class="lineNum">    3225 </span>            :             &quot;used_memory_rss:%zu\r\n&quot;
<span class="lineNum">    3226 </span>            :             &quot;used_memory_rss_human:%s\r\n&quot;
<span class="lineNum">    3227 </span>            :             &quot;used_memory_peak:%zu\r\n&quot;
<span class="lineNum">    3228 </span>            :             &quot;used_memory_peak_human:%s\r\n&quot;
<span class="lineNum">    3229 </span>            :             &quot;used_memory_peak_perc:%.2f%%\r\n&quot;
<span class="lineNum">    3230 </span>            :             &quot;used_memory_overhead:%zu\r\n&quot;
<span class="lineNum">    3231 </span>            :             &quot;used_memory_startup:%zu\r\n&quot;
<span class="lineNum">    3232 </span>            :             &quot;used_memory_dataset:%zu\r\n&quot;
<span class="lineNum">    3233 </span>            :             &quot;used_memory_dataset_perc:%.2f%%\r\n&quot;
<span class="lineNum">    3234 </span>            :             &quot;allocator_allocated:%zu\r\n&quot;
<span class="lineNum">    3235 </span>            :             &quot;allocator_active:%zu\r\n&quot;
<span class="lineNum">    3236 </span>            :             &quot;allocator_resident:%zu\r\n&quot;
<span class="lineNum">    3237 </span>            :             &quot;total_system_memory:%lu\r\n&quot;
<span class="lineNum">    3238 </span>            :             &quot;total_system_memory_human:%s\r\n&quot;
<span class="lineNum">    3239 </span>            :             &quot;used_memory_lua:%lld\r\n&quot;
<span class="lineNum">    3240 </span>            :             &quot;used_memory_lua_human:%s\r\n&quot;
<span class="lineNum">    3241 </span>            :             &quot;used_memory_scripts:%lld\r\n&quot;
<span class="lineNum">    3242 </span>            :             &quot;used_memory_scripts_human:%s\r\n&quot;
<span class="lineNum">    3243 </span>            :             &quot;number_of_cached_scripts:%lu\r\n&quot;
<span class="lineNum">    3244 </span>            :             &quot;maxmemory:%lld\r\n&quot;
<span class="lineNum">    3245 </span>            :             &quot;maxmemory_human:%s\r\n&quot;
<span class="lineNum">    3246 </span>            :             &quot;maxmemory_policy:%s\r\n&quot;
<span class="lineNum">    3247 </span>            :             &quot;allocator_frag_ratio:%.2f\r\n&quot;
<span class="lineNum">    3248 </span>            :             &quot;allocator_frag_bytes:%zu\r\n&quot;
<span class="lineNum">    3249 </span>            :             &quot;allocator_rss_ratio:%.2f\r\n&quot;
<span class="lineNum">    3250 </span>            :             &quot;allocator_rss_bytes:%zu\r\n&quot;
<span class="lineNum">    3251 </span>            :             &quot;rss_overhead_ratio:%.2f\r\n&quot;
<span class="lineNum">    3252 </span>            :             &quot;rss_overhead_bytes:%zu\r\n&quot;
<span class="lineNum">    3253 </span>            :             &quot;mem_fragmentation_ratio:%.2f\r\n&quot;
<span class="lineNum">    3254 </span>            :             &quot;mem_fragmentation_bytes:%zu\r\n&quot;
<span class="lineNum">    3255 </span>            :             &quot;mem_not_counted_for_evict:%zu\r\n&quot;
<span class="lineNum">    3256 </span>            :             &quot;mem_replication_backlog:%zu\r\n&quot;
<span class="lineNum">    3257 </span>            :             &quot;mem_clients_slaves:%zu\r\n&quot;
<span class="lineNum">    3258 </span>            :             &quot;mem_clients_normal:%zu\r\n&quot;
<span class="lineNum">    3259 </span>            :             &quot;mem_aof_buffer:%zu\r\n&quot;
<span class="lineNum">    3260 </span>            :             &quot;mem_allocator:%s\r\n&quot;
<span class="lineNum">    3261 </span>            :             &quot;active_defrag_running:%d\r\n&quot;
<span class="lineNum">    3262 </span>            :             &quot;lazyfree_pending_objects:%zu\r\n&quot;,
<span class="lineNum">    3263 </span>            :             zmalloc_used,
<span class="lineNum">    3264 </span>            :             hmem,
<span class="lineNum">    3265 </span>            :             server.cron_malloc_stats.process_rss,
<span class="lineNum">    3266 </span>            :             used_memory_rss_hmem,
<span class="lineNum">    3267 </span>            :             server.stat_peak_memory,
<span class="lineNum">    3268 </span>            :             peak_hmem,
<span class="lineNum">    3269 </span><span class="lineCov">      30622 :             mh-&gt;peak_perc,</span>
<span class="lineNum">    3270 </span>            :             mh-&gt;overhead_total,
<span class="lineNum">    3271 </span>            :             mh-&gt;startup_allocated,
<span class="lineNum">    3272 </span>            :             mh-&gt;dataset,
<span class="lineNum">    3273 </span><span class="lineCov">      30622 :             mh-&gt;dataset_perc,</span>
<span class="lineNum">    3274 </span>            :             server.cron_malloc_stats.allocator_allocated,
<span class="lineNum">    3275 </span>            :             server.cron_malloc_stats.allocator_active,
<span class="lineNum">    3276 </span>            :             server.cron_malloc_stats.allocator_resident,
<span class="lineNum">    3277 </span>            :             (unsigned long)total_system_mem,
<span class="lineNum">    3278 </span>            :             total_system_hmem,
<span class="lineNum">    3279 </span>            :             memory_lua,
<span class="lineNum">    3280 </span>            :             used_memory_lua_hmem,
<span class="lineNum">    3281 </span><span class="lineCov">      30622 :             (long long) mh-&gt;lua_caches,</span>
<span class="lineNum">    3282 </span>            :             used_memory_scripts_hmem,
<span class="lineNum">    3283 </span><span class="lineCov">      30622 :             dictSize(server.lua_scripts),</span>
<span class="lineNum">    3284 </span>            :             server.maxmemory,
<span class="lineNum">    3285 </span>            :             maxmemory_hmem,
<span class="lineNum">    3286 </span>            :             evict_policy,
<span class="lineNum">    3287 </span><span class="lineCov">      30622 :             mh-&gt;allocator_frag,</span>
<span class="lineNum">    3288 </span>            :             mh-&gt;allocator_frag_bytes,
<span class="lineNum">    3289 </span><span class="lineCov">      30622 :             mh-&gt;allocator_rss,</span>
<span class="lineNum">    3290 </span>            :             mh-&gt;allocator_rss_bytes,
<span class="lineNum">    3291 </span><span class="lineCov">      30622 :             mh-&gt;rss_extra,</span>
<span class="lineNum">    3292 </span>            :             mh-&gt;rss_extra_bytes,
<span class="lineNum">    3293 </span><span class="lineCov">      30622 :             mh-&gt;total_frag, /* this is the total RSS overhead, including fragmentation, */</span>
<span class="lineNum">    3294 </span>            :             mh-&gt;total_frag_bytes, /* named so for backwards compatibility */
<span class="lineNum">    3295 </span>            :             freeMemoryGetNotCountedMemory(),
<span class="lineNum">    3296 </span>            :             mh-&gt;repl_backlog,
<span class="lineNum">    3297 </span>            :             mh-&gt;clients_slaves,
<span class="lineNum">    3298 </span>            :             mh-&gt;clients_normal,
<span class="lineNum">    3299 </span>            :             mh-&gt;aof_buffer,
<span class="lineNum">    3300 </span>            :             ZMALLOC_LIB,
<span class="lineNum">    3301 </span>            :             server.active_defrag_running,
<span class="lineNum">    3302 </span>            :             lazyfreeGetPendingObjectsCount()
<span class="lineNum">    3303 </span>            :         );
<span class="lineNum">    3304 </span><span class="lineCov">      30622 :         freeMemoryOverheadData(mh);</span>
<span class="lineNum">    3305 </span>            :     }
<span class="lineNum">    3306 </span>            : 
<span class="lineNum">    3307 </span>            :     /* Persistence */
<span class="lineNum">    3308 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;persistence&quot;)) {</span>
<span class="lineNum">    3309 </span><span class="lineCov">      30642 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3310 </span><span class="lineCov">     337729 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3311 </span>            :             &quot;# Persistence\r\n&quot;
<span class="lineNum">    3312 </span>            :             &quot;loading:%d\r\n&quot;
<span class="lineNum">    3313 </span>            :             &quot;rdb_changes_since_last_save:%lld\r\n&quot;
<span class="lineNum">    3314 </span>            :             &quot;rdb_bgsave_in_progress:%d\r\n&quot;
<span class="lineNum">    3315 </span>            :             &quot;rdb_last_save_time:%jd\r\n&quot;
<span class="lineNum">    3316 </span>            :             &quot;rdb_last_bgsave_status:%s\r\n&quot;
<span class="lineNum">    3317 </span>            :             &quot;rdb_last_bgsave_time_sec:%jd\r\n&quot;
<span class="lineNum">    3318 </span>            :             &quot;rdb_current_bgsave_time_sec:%jd\r\n&quot;
<span class="lineNum">    3319 </span>            :             &quot;rdb_last_cow_size:%zu\r\n&quot;
<span class="lineNum">    3320 </span>            :             &quot;aof_enabled:%d\r\n&quot;
<span class="lineNum">    3321 </span>            :             &quot;aof_rewrite_in_progress:%d\r\n&quot;
<span class="lineNum">    3322 </span>            :             &quot;aof_rewrite_scheduled:%d\r\n&quot;
<span class="lineNum">    3323 </span>            :             &quot;aof_last_rewrite_time_sec:%jd\r\n&quot;
<span class="lineNum">    3324 </span>            :             &quot;aof_current_rewrite_time_sec:%jd\r\n&quot;
<span class="lineNum">    3325 </span>            :             &quot;aof_last_bgrewrite_status:%s\r\n&quot;
<span class="lineNum">    3326 </span>            :             &quot;aof_last_write_status:%s\r\n&quot;
<span class="lineNum">    3327 </span>            :             &quot;aof_last_cow_size:%zu\r\n&quot;,
<span class="lineNum">    3328 </span>            :             server.loading,
<span class="lineNum">    3329 </span>            :             server.dirty,
<span class="lineNum">    3330 </span><span class="lineCov">      30642 :             server.rdb_child_pid != -1,</span>
<span class="lineNum">    3331 </span><span class="lineCov">      30642 :             (intmax_t)server.lastsave,</span>
<span class="lineNum">    3332 </span><span class="lineCov">      30642 :             (server.lastbgsave_status == C_OK) ? &quot;ok&quot; : &quot;err&quot;,</span>
<span class="lineNum">    3333 </span><span class="lineCov">      30642 :             (intmax_t)server.rdb_save_time_last,</span>
<span class="lineNum">    3334 </span><span class="lineCov">      30642 :             (intmax_t)((server.rdb_child_pid == -1) ?</span>
<span class="lineNum">    3335 </span><span class="lineCov">        151 :                 -1 : time(NULL)-server.rdb_save_time_start),</span>
<span class="lineNum">    3336 </span>            :             server.stat_rdb_cow_bytes,
<span class="lineNum">    3337 </span><span class="lineCov">      30642 :             server.aof_state != AOF_OFF,</span>
<span class="lineNum">    3338 </span><span class="lineCov">      30642 :             server.aof_child_pid != -1,</span>
<span class="lineNum">    3339 </span>            :             server.aof_rewrite_scheduled,
<span class="lineNum">    3340 </span><span class="lineCov">      30642 :             (intmax_t)server.aof_rewrite_time_last,</span>
<span class="lineNum">    3341 </span><span class="lineCov">      30642 :             (intmax_t)((server.aof_child_pid == -1) ?</span>
<span class="lineNum">    3342 </span><span class="lineCov">        516 :                 -1 : time(NULL)-server.aof_rewrite_time_start),</span>
<span class="lineNum">    3343 </span><span class="lineCov">      30642 :             (server.aof_lastbgrewrite_status == C_OK) ? &quot;ok&quot; : &quot;err&quot;,</span>
<span class="lineNum">    3344 </span><span class="lineCov">      30642 :             (server.aof_last_write_status == C_OK) ? &quot;ok&quot; : &quot;err&quot;,</span>
<span class="lineNum">    3345 </span>            :             server.stat_aof_cow_bytes);
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span><span class="lineCov">      30642 :         if (server.aof_state != AOF_OFF) {</span>
<span class="lineNum">    3348 </span><span class="lineCov">        188 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3349 </span>            :                 &quot;aof_current_size:%lld\r\n&quot;
<span class="lineNum">    3350 </span>            :                 &quot;aof_base_size:%lld\r\n&quot;
<span class="lineNum">    3351 </span>            :                 &quot;aof_pending_rewrite:%d\r\n&quot;
<span class="lineNum">    3352 </span>            :                 &quot;aof_buffer_length:%zu\r\n&quot;
<span class="lineNum">    3353 </span>            :                 &quot;aof_rewrite_buffer_length:%lu\r\n&quot;
<span class="lineNum">    3354 </span>            :                 &quot;aof_pending_bio_fsync:%llu\r\n&quot;
<span class="lineNum">    3355 </span>            :                 &quot;aof_delayed_fsync:%lu\r\n&quot;,
<span class="lineNum">    3356 </span><span class="lineCov">        188 :                 (long long) server.aof_current_size,</span>
<span class="lineNum">    3357 </span><span class="lineCov">        188 :                 (long long) server.aof_rewrite_base_size,</span>
<span class="lineNum">    3358 </span>            :                 server.aof_rewrite_scheduled,
<span class="lineNum">    3359 </span>            :                 sdslen(server.aof_buf),
<span class="lineNum">    3360 </span>            :                 aofRewriteBufferSize(),
<span class="lineNum">    3361 </span>            :                 bioPendingJobsOfType(BIO_AOF_FSYNC),
<span class="lineNum">    3362 </span>            :                 server.aof_delayed_fsync);
<span class="lineNum">    3363 </span>            :         }
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span><span class="lineCov">      30642 :         if (server.loading) {</span>
<span class="lineNum">    3366 </span><span class="lineCov">          3 :             double perc;</span>
<span class="lineNum">    3367 </span><span class="lineCov">          3 :             time_t eta, elapsed;</span>
<span class="lineNum">    3368 </span><span class="lineCov">          6 :             off_t remaining_bytes = server.loading_total_bytes-</span>
<span class="lineNum">    3369 </span><span class="lineCov">          3 :                                     server.loading_loaded_bytes;</span>
<span class="lineNum">    3370 </span>            : 
<span class="lineNum">    3371 </span><span class="lineCov">          6 :             perc = ((double)server.loading_loaded_bytes /</span>
<span class="lineNum">    3372 </span><span class="lineCov">          3 :                    (server.loading_total_bytes+1)) * 100;</span>
<span class="lineNum">    3373 </span>            : 
<span class="lineNum">    3374 </span><span class="lineCov">          3 :             elapsed = time(NULL)-server.loading_start_time;</span>
<span class="lineNum">    3375 </span><span class="lineCov">          3 :             if (elapsed == 0) {</span>
<span class="lineNum">    3376 </span>            :                 eta = 1; /* A fake 1 second figure if we don't have
<span class="lineNum">    3377 </span>            :                             enough info */
<span class="lineNum">    3378 </span>            :             } else {
<span class="lineNum">    3379 </span><span class="lineCov">          1 :                 eta = (elapsed*remaining_bytes)/(server.loading_loaded_bytes+1);</span>
<span class="lineNum">    3380 </span>            :             }
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span><span class="lineCov">          9 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3383 </span>            :                 &quot;loading_start_time:%jd\r\n&quot;
<span class="lineNum">    3384 </span>            :                 &quot;loading_total_bytes:%llu\r\n&quot;
<span class="lineNum">    3385 </span>            :                 &quot;loading_loaded_bytes:%llu\r\n&quot;
<span class="lineNum">    3386 </span>            :                 &quot;loading_loaded_perc:%.2f\r\n&quot;
<span class="lineNum">    3387 </span>            :                 &quot;loading_eta_seconds:%jd\r\n&quot;,
<span class="lineNum">    3388 </span>            :                 (intmax_t) server.loading_start_time,
<span class="lineNum">    3389 </span><span class="lineCov">          3 :                 (unsigned long long) server.loading_total_bytes,</span>
<span class="lineNum">    3390 </span><span class="lineCov">          3 :                 (unsigned long long) server.loading_loaded_bytes,</span>
<span class="lineNum">    3391 </span>            :                 perc,
<span class="lineNum">    3392 </span>            :                 (intmax_t)eta
<span class="lineNum">    3393 </span>            :             );
<span class="lineNum">    3394 </span>            :         }
<span class="lineNum">    3395 </span>            :     }
<span class="lineNum">    3396 </span>            : 
<span class="lineNum">    3397 </span>            :     /* Stats */
<span class="lineNum">    3398 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;stats&quot;)) {</span>
<span class="lineNum">    3399 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3400 </span><span class="lineCov">      61236 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3401 </span>            :             &quot;# Stats\r\n&quot;
<span class="lineNum">    3402 </span>            :             &quot;total_connections_received:%lld\r\n&quot;
<span class="lineNum">    3403 </span>            :             &quot;total_commands_processed:%lld\r\n&quot;
<span class="lineNum">    3404 </span>            :             &quot;instantaneous_ops_per_sec:%lld\r\n&quot;
<span class="lineNum">    3405 </span>            :             &quot;total_net_input_bytes:%lld\r\n&quot;
<span class="lineNum">    3406 </span>            :             &quot;total_net_output_bytes:%lld\r\n&quot;
<span class="lineNum">    3407 </span>            :             &quot;instantaneous_input_kbps:%.2f\r\n&quot;
<span class="lineNum">    3408 </span>            :             &quot;instantaneous_output_kbps:%.2f\r\n&quot;
<span class="lineNum">    3409 </span>            :             &quot;rejected_connections:%lld\r\n&quot;
<span class="lineNum">    3410 </span>            :             &quot;sync_full:%lld\r\n&quot;
<span class="lineNum">    3411 </span>            :             &quot;sync_partial_ok:%lld\r\n&quot;
<span class="lineNum">    3412 </span>            :             &quot;sync_partial_err:%lld\r\n&quot;
<span class="lineNum">    3413 </span>            :             &quot;expired_keys:%lld\r\n&quot;
<span class="lineNum">    3414 </span>            :             &quot;expired_stale_perc:%.2f\r\n&quot;
<span class="lineNum">    3415 </span>            :             &quot;expired_time_cap_reached_count:%lld\r\n&quot;
<span class="lineNum">    3416 </span>            :             &quot;evicted_keys:%lld\r\n&quot;
<span class="lineNum">    3417 </span>            :             &quot;keyspace_hits:%lld\r\n&quot;
<span class="lineNum">    3418 </span>            :             &quot;keyspace_misses:%lld\r\n&quot;
<span class="lineNum">    3419 </span>            :             &quot;pubsub_channels:%ld\r\n&quot;
<span class="lineNum">    3420 </span>            :             &quot;pubsub_patterns:%lu\r\n&quot;
<span class="lineNum">    3421 </span>            :             &quot;latest_fork_usec:%lld\r\n&quot;
<span class="lineNum">    3422 </span>            :             &quot;migrate_cached_sockets:%ld\r\n&quot;
<span class="lineNum">    3423 </span>            :             &quot;slave_expires_tracked_keys:%zu\r\n&quot;
<span class="lineNum">    3424 </span>            :             &quot;active_defrag_hits:%lld\r\n&quot;
<span class="lineNum">    3425 </span>            :             &quot;active_defrag_misses:%lld\r\n&quot;
<span class="lineNum">    3426 </span>            :             &quot;active_defrag_key_hits:%lld\r\n&quot;
<span class="lineNum">    3427 </span>            :             &quot;active_defrag_key_misses:%lld\r\n&quot;,
<span class="lineNum">    3428 </span>            :             server.stat_numconnections,
<span class="lineNum">    3429 </span>            :             server.stat_numcommands,
<span class="lineNum">    3430 </span>            :             getInstantaneousMetric(STATS_METRIC_COMMAND),
<span class="lineNum">    3431 </span>            :             server.stat_net_input_bytes,
<span class="lineNum">    3432 </span>            :             server.stat_net_output_bytes,
<span class="lineNum">    3433 </span><span class="lineCov">      30618 :             (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,</span>
<span class="lineNum">    3434 </span><span class="lineCov">      30618 :             (float)getInstantaneousMetric(STATS_METRIC_NET_OUTPUT)/1024,</span>
<span class="lineNum">    3435 </span>            :             server.stat_rejected_conn,
<span class="lineNum">    3436 </span>            :             server.stat_sync_full,
<span class="lineNum">    3437 </span>            :             server.stat_sync_partial_ok,
<span class="lineNum">    3438 </span>            :             server.stat_sync_partial_err,
<span class="lineNum">    3439 </span>            :             server.stat_expiredkeys,
<span class="lineNum">    3440 </span><span class="lineCov">      30618 :             server.stat_expired_stale_perc*100,</span>
<span class="lineNum">    3441 </span>            :             server.stat_expired_time_cap_reached_count,
<span class="lineNum">    3442 </span>            :             server.stat_evictedkeys,
<span class="lineNum">    3443 </span>            :             server.stat_keyspace_hits,
<span class="lineNum">    3444 </span>            :             server.stat_keyspace_misses,
<span class="lineNum">    3445 </span><span class="lineCov">      30618 :             dictSize(server.pubsub_channels),</span>
<span class="lineNum">    3446 </span><span class="lineCov">      30618 :             listLength(server.pubsub_patterns),</span>
<span class="lineNum">    3447 </span>            :             server.stat_fork_time,
<span class="lineNum">    3448 </span><span class="lineCov">      30618 :             dictSize(server.migrate_cached_sockets),</span>
<span class="lineNum">    3449 </span>            :             getSlaveKeyWithExpireCount(),
<span class="lineNum">    3450 </span>            :             server.stat_active_defrag_hits,
<span class="lineNum">    3451 </span>            :             server.stat_active_defrag_misses,
<span class="lineNum">    3452 </span>            :             server.stat_active_defrag_key_hits,
<span class="lineNum">    3453 </span>            :             server.stat_active_defrag_key_misses);
<span class="lineNum">    3454 </span>            :     }
<span class="lineNum">    3455 </span>            : 
<span class="lineNum">    3456 </span>            :     /* Replication */
<span class="lineNum">    3457 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;replication&quot;)) {</span>
<span class="lineNum">    3458 </span><span class="lineCov">      30718 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3459 </span><span class="lineCov">      30718 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3460 </span>            :             &quot;# Replication\r\n&quot;
<span class="lineNum">    3461 </span>            :             &quot;role:%s\r\n&quot;,
<span class="lineNum">    3462 </span><span class="lineCov">      30718 :             server.masterhost == NULL ? &quot;master&quot; : &quot;slave&quot;);</span>
<span class="lineNum">    3463 </span><span class="lineCov">      30718 :         if (server.masterhost) {</span>
<span class="lineNum">    3464 </span><span class="lineCov">        773 :             long long slave_repl_offset = 1;</span>
<span class="lineNum">    3465 </span>            : 
<span class="lineNum">    3466 </span><span class="lineCov">        773 :             if (server.master)</span>
<span class="lineNum">    3467 </span><span class="lineCov">         75 :                 slave_repl_offset = server.master-&gt;reploff;</span>
<span class="lineNum">    3468 </span><span class="lineCov">        698 :             else if (server.cached_master)</span>
<span class="lineNum">    3469 </span><span class="lineCov">        646 :                 slave_repl_offset = server.cached_master-&gt;reploff;</span>
<span class="lineNum">    3470 </span>            : 
<span class="lineNum">    3471 </span><span class="lineCov">       1471 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3472 </span>            :                 &quot;master_host:%s\r\n&quot;
<span class="lineNum">    3473 </span>            :                 &quot;master_port:%d\r\n&quot;
<span class="lineNum">    3474 </span>            :                 &quot;master_link_status:%s\r\n&quot;
<span class="lineNum">    3475 </span>            :                 &quot;master_last_io_seconds_ago:%d\r\n&quot;
<span class="lineNum">    3476 </span>            :                 &quot;master_sync_in_progress:%d\r\n&quot;
<span class="lineNum">    3477 </span>            :                 &quot;slave_repl_offset:%lld\r\n&quot;
<span class="lineNum">    3478 </span>            :                 ,server.masterhost,
<span class="lineNum">    3479 </span>            :                 server.masterport,
<span class="lineNum">    3480 </span>            :                 (server.repl_state == REPL_STATE_CONNECTED) ?
<span class="lineNum">    3481 </span>            :                     &quot;up&quot; : &quot;down&quot;,
<span class="lineNum">    3482 </span>            :                 server.master ?
<span class="lineNum">    3483 </span><span class="lineCov">         75 :                 ((int)(server.unixtime-server.master-&gt;lastinteraction)) : -1,</span>
<span class="lineNum">    3484 </span><span class="lineCov">        773 :                 server.repl_state == REPL_STATE_TRANSFER,</span>
<span class="lineNum">    3485 </span>            :                 slave_repl_offset
<span class="lineNum">    3486 </span>            :             );
<span class="lineNum">    3487 </span>            : 
<span class="lineNum">    3488 </span><span class="lineCov">        773 :             if (server.repl_state == REPL_STATE_TRANSFER) {</span>
<span class="lineNum">    3489 </span><span class="lineCov">        156 :                 info = sdscatprintf(info,</span>
<span class="lineNum">    3490 </span>            :                     &quot;master_sync_left_bytes:%lld\r\n&quot;
<span class="lineNum">    3491 </span>            :                     &quot;master_sync_last_io_seconds_ago:%d\r\n&quot;
<span class="lineNum">    3492 </span>            :                     , (long long)
<span class="lineNum">    3493 </span><span class="lineCov">         52 :                         (server.repl_transfer_size - server.repl_transfer_read),</span>
<span class="lineNum">    3494 </span><span class="lineCov">         52 :                     (int)(server.unixtime-server.repl_transfer_lastio)</span>
<span class="lineNum">    3495 </span>            :                 );
<span class="lineNum">    3496 </span>            :             }
<span class="lineNum">    3497 </span>            : 
<span class="lineNum">    3498 </span><span class="lineCov">        773 :             if (server.repl_state != REPL_STATE_CONNECTED) {</span>
<span class="lineNum">    3499 </span><span class="lineCov">       1396 :                 info = sdscatprintf(info,</span>
<span class="lineNum">    3500 </span>            :                     &quot;master_link_down_since_seconds:%jd\r\n&quot;,
<span class="lineNum">    3501 </span><span class="lineCov">        698 :                     (intmax_t)server.unixtime-server.repl_down_since);</span>
<span class="lineNum">    3502 </span>            :             }
<span class="lineNum">    3503 </span><span class="lineCov">        773 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3504 </span>            :                 &quot;slave_priority:%d\r\n&quot;
<span class="lineNum">    3505 </span>            :                 &quot;slave_read_only:%d\r\n&quot;,
<span class="lineNum">    3506 </span>            :                 server.slave_priority,
<span class="lineNum">    3507 </span>            :                 server.repl_slave_ro);
<span class="lineNum">    3508 </span>            :         }
<span class="lineNum">    3509 </span>            : 
<span class="lineNum">    3510 </span><span class="lineCov">      92154 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3511 </span>            :             &quot;connected_slaves:%lu\r\n&quot;,
<span class="lineNum">    3512 </span><span class="lineCov">      30718 :             listLength(server.slaves));</span>
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span>            :         /* If min-slaves-to-write is active, write the number of slaves
<span class="lineNum">    3515 </span>            :          * currently considered 'good'. */
<span class="lineNum">    3516 </span><span class="lineCov">      30718 :         if (server.repl_min_slaves_to_write &amp;&amp;</span>
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :             server.repl_min_slaves_max_lag) {</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3519 </span>            :                 &quot;min_slaves_good_slaves:%d\r\n&quot;,
<span class="lineNum">    3520 </span>            :                 server.repl_good_slaves_count);
<span class="lineNum">    3521 </span>            :         }
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineCov">      30718 :         if (listLength(server.slaves)) {</span>
<span class="lineNum">    3524 </span><span class="lineCov">        647 :             int slaveid = 0;</span>
<span class="lineNum">    3525 </span><span class="lineCov">        647 :             listNode *ln;</span>
<span class="lineNum">    3526 </span><span class="lineCov">        647 :             listIter li;</span>
<span class="lineNum">    3527 </span>            : 
<span class="lineNum">    3528 </span><span class="lineCov">        647 :             listRewind(server.slaves,&amp;li);</span>
<span class="lineNum">    3529 </span><span class="lineCov">       2431 :             while((ln = listNext(&amp;li))) {</span>
<span class="lineNum">    3530 </span><span class="lineCov">       1784 :                 client *slave = listNodeValue(ln);</span>
<span class="lineNum">    3531 </span><span class="lineCov">       1784 :                 char *state = NULL;</span>
<span class="lineNum">    3532 </span><span class="lineCov">       1784 :                 char ip[NET_IP_STR_LEN], *slaveip = slave-&gt;slave_ip;</span>
<span class="lineNum">    3533 </span><span class="lineCov">       1784 :                 int port;</span>
<span class="lineNum">    3534 </span><span class="lineCov">       1784 :                 long lag = 0;</span>
<span class="lineNum">    3535 </span>            : 
<span class="lineNum">    3536 </span><span class="lineCov">       1784 :                 if (slaveip[0] == '\0') {</span>
<span class="lineNum">    3537 </span><span class="lineCov">       1784 :                     if (anetPeerToString(slave-&gt;fd,ip,sizeof(ip),&amp;port) == -1)</span>
<span class="lineNum">    3538 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    3539 </span>            :                     slaveip = ip;
<span class="lineNum">    3540 </span>            :                 }
<span class="lineNum">    3541 </span><span class="lineCov">       1784 :                 switch(slave-&gt;replstate) {</span>
<span class="lineNum">    3542 </span>            :                 case SLAVE_STATE_WAIT_BGSAVE_START:
<span class="lineNum">    3543 </span>            :                 case SLAVE_STATE_WAIT_BGSAVE_END:
<span class="lineNum">    3544 </span>            :                     state = &quot;wait_bgsave&quot;;
<span class="lineNum">    3545 </span>            :                     break;
<span class="lineNum">    3546 </span><span class="lineCov">        252 :                 case SLAVE_STATE_SEND_BULK:</span>
<span class="lineNum">    3547 </span><span class="lineCov">        252 :                     state = &quot;send_bulk&quot;;</span>
<span class="lineNum">    3548 </span><span class="lineCov">        252 :                     break;</span>
<span class="lineNum">    3549 </span><span class="lineCov">        176 :                 case SLAVE_STATE_ONLINE:</span>
<span class="lineNum">    3550 </span><span class="lineCov">        176 :                     state = &quot;online&quot;;</span>
<span class="lineNum">    3551 </span><span class="lineCov">        176 :                     break;</span>
<span class="lineNum">    3552 </span>            :                 }
<span class="lineNum">    3553 </span><span class="lineCov">       1784 :                 if (state == NULL) continue;</span>
<span class="lineNum">    3554 </span><span class="lineCov">       1784 :                 if (slave-&gt;replstate == SLAVE_STATE_ONLINE)</span>
<span class="lineNum">    3555 </span><span class="lineCov">        176 :                     lag = time(NULL) - slave-&gt;repl_ack_time;</span>
<span class="lineNum">    3556 </span>            : 
<span class="lineNum">    3557 </span><span class="lineCov">       1784 :                 info = sdscatprintf(info,</span>
<span class="lineNum">    3558 </span>            :                     &quot;slave%d:ip=%s,port=%d,state=%s,&quot;
<span class="lineNum">    3559 </span>            :                     &quot;offset=%lld,lag=%ld\r\n&quot;,
<span class="lineNum">    3560 </span>            :                     slaveid,slaveip,slave-&gt;slave_listening_port,state,
<span class="lineNum">    3561 </span>            :                     slave-&gt;repl_ack_off, lag);
<span class="lineNum">    3562 </span><span class="lineCov">       1784 :                 slaveid++;</span>
<span class="lineNum">    3563 </span>            :             }
<span class="lineNum">    3564 </span>            :         }
<span class="lineNum">    3565 </span><span class="lineCov">      61436 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3566 </span>            :             &quot;master_replid:%s\r\n&quot;
<span class="lineNum">    3567 </span>            :             &quot;master_replid2:%s\r\n&quot;
<span class="lineNum">    3568 </span>            :             &quot;master_repl_offset:%lld\r\n&quot;
<span class="lineNum">    3569 </span>            :             &quot;second_repl_offset:%lld\r\n&quot;
<span class="lineNum">    3570 </span>            :             &quot;repl_backlog_active:%d\r\n&quot;
<span class="lineNum">    3571 </span>            :             &quot;repl_backlog_size:%lld\r\n&quot;
<span class="lineNum">    3572 </span>            :             &quot;repl_backlog_first_byte_offset:%lld\r\n&quot;
<span class="lineNum">    3573 </span>            :             &quot;repl_backlog_histlen:%lld\r\n&quot;,
<span class="lineNum">    3574 </span>            :             server.replid,
<span class="lineNum">    3575 </span>            :             server.replid2,
<span class="lineNum">    3576 </span>            :             server.master_repl_offset,
<span class="lineNum">    3577 </span>            :             server.second_replid_offset,
<span class="lineNum">    3578 </span><span class="lineCov">      30718 :             server.repl_backlog != NULL,</span>
<span class="lineNum">    3579 </span>            :             server.repl_backlog_size,
<span class="lineNum">    3580 </span>            :             server.repl_backlog_off,
<span class="lineNum">    3581 </span>            :             server.repl_backlog_histlen);
<span class="lineNum">    3582 </span>            :     }
<span class="lineNum">    3583 </span>            : 
<span class="lineNum">    3584 </span>            :     /* CPU */
<span class="lineNum">    3585 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;cpu&quot;)) {</span>
<span class="lineNum">    3586 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3587 </span><span class="lineCov">      61236 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3588 </span>            :         &quot;# CPU\r\n&quot;
<span class="lineNum">    3589 </span>            :         &quot;used_cpu_sys:%ld.%06ld\r\n&quot;
<span class="lineNum">    3590 </span>            :         &quot;used_cpu_user:%ld.%06ld\r\n&quot;
<span class="lineNum">    3591 </span>            :         &quot;used_cpu_sys_children:%ld.%06ld\r\n&quot;
<span class="lineNum">    3592 </span>            :         &quot;used_cpu_user_children:%ld.%06ld\r\n&quot;,
<span class="lineNum">    3593 </span><span class="lineCov">      30618 :         (long)self_ru.ru_stime.tv_sec, (long)self_ru.ru_stime.tv_usec,</span>
<span class="lineNum">    3594 </span><span class="lineCov">      30618 :         (long)self_ru.ru_utime.tv_sec, (long)self_ru.ru_utime.tv_usec,</span>
<span class="lineNum">    3595 </span><span class="lineCov">      30618 :         (long)c_ru.ru_stime.tv_sec, (long)c_ru.ru_stime.tv_usec,</span>
<span class="lineNum">    3596 </span><span class="lineCov">      30618 :         (long)c_ru.ru_utime.tv_sec, (long)c_ru.ru_utime.tv_usec);</span>
<span class="lineNum">    3597 </span>            :     }
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span>            :     /* Command statistics */
<span class="lineNum">    3600 </span><span class="lineCov">      30776 :     if (allsections || !strcasecmp(section,&quot;commandstats&quot;)) {</span>
<span class="lineNum">    3601 </span><span class="lineCov">         30 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3602 </span><span class="lineCov">         30 :         info = sdscatprintf(info, &quot;# Commandstats\r\n&quot;);</span>
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span><span class="lineCov">         30 :         struct redisCommand *c;</span>
<span class="lineNum">    3605 </span><span class="lineCov">         30 :         dictEntry *de;</span>
<span class="lineNum">    3606 </span><span class="lineCov">         30 :         dictIterator *di;</span>
<span class="lineNum">    3607 </span><span class="lineCov">         30 :         di = dictGetSafeIterator(server.commands);</span>
<span class="lineNum">    3608 </span><span class="lineCov">       6030 :         while((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">    3609 </span><span class="lineCov">       6000 :             c = (struct redisCommand *) dictGetVal(de);</span>
<span class="lineNum">    3610 </span><span class="lineCov">       6000 :             if (!c-&gt;calls) continue;</span>
<span class="lineNum">    3611 </span><span class="lineCov">        304 :             info = sdscatprintf(info,</span>
<span class="lineNum">    3612 </span>            :                 &quot;cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f\r\n&quot;,
<span class="lineNum">    3613 </span>            :                 c-&gt;name, c-&gt;calls, c-&gt;microseconds,
<span class="lineNum">    3614 </span><span class="lineCov">        152 :                 (c-&gt;calls == 0) ? 0 : ((float)c-&gt;microseconds/c-&gt;calls));</span>
<span class="lineNum">    3615 </span>            :         }
<span class="lineNum">    3616 </span><span class="lineCov">         30 :         dictReleaseIterator(di);</span>
<span class="lineNum">    3617 </span>            :     }
<span class="lineNum">    3618 </span>            : 
<span class="lineNum">    3619 </span>            :     /* Cluster */
<span class="lineNum">    3620 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;cluster&quot;)) {</span>
<span class="lineNum">    3621 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3622 </span><span class="lineCov">      30618 :         info = sdscatprintf(info,</span>
<span class="lineNum">    3623 </span>            :         &quot;# Cluster\r\n&quot;
<span class="lineNum">    3624 </span>            :         &quot;cluster_enabled:%d\r\n&quot;,
<span class="lineNum">    3625 </span>            :         server.cluster_enabled);
<span class="lineNum">    3626 </span>            :     }
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span>            :     /* Key space */
<span class="lineNum">    3629 </span><span class="lineCov">      30776 :     if (allsections || defsections || !strcasecmp(section,&quot;keyspace&quot;)) {</span>
<span class="lineNum">    3630 </span><span class="lineCov">      30618 :         if (sections++) info = sdscat(info,&quot;\r\n&quot;);</span>
<span class="lineNum">    3631 </span><span class="lineCov">      30618 :         info = sdscatprintf(info, &quot;# Keyspace\r\n&quot;);</span>
<span class="lineNum">    3632 </span><span class="lineCov">     520506 :         for (j = 0; j &lt; server.dbnum; j++) {</span>
<span class="lineNum">    3633 </span><span class="lineCov">     489888 :             long long keys, vkeys;</span>
<span class="lineNum">    3634 </span>            : 
<span class="lineNum">    3635 </span><span class="lineCov">     489888 :             keys = dictSize(server.db[j].dict);</span>
<span class="lineNum">    3636 </span><span class="lineCov">     489888 :             vkeys = dictSize(server.db[j].expires);</span>
<span class="lineNum">    3637 </span><span class="lineCov">     489888 :             if (keys || vkeys) {</span>
<span class="lineNum">    3638 </span><span class="lineCov">      29925 :                 info = sdscatprintf(info,</span>
<span class="lineNum">    3639 </span>            :                     &quot;db%d:keys=%lld,expires=%lld,avg_ttl=%lld\r\n&quot;,
<span class="lineNum">    3640 </span>            :                     j, keys, vkeys, server.db[j].avg_ttl);
<span class="lineNum">    3641 </span>            :             }
<span class="lineNum">    3642 </span>            :         }
<span class="lineNum">    3643 </span>            :     }
<span class="lineNum">    3644 </span><span class="lineCov">      30776 :     return info;</span>
<a name="3645"><span class="lineNum">    3645 </span>            : }</a>
<span class="lineNum">    3646 </span>            : 
<span class="lineNum">    3647 </span><span class="lineCov">      30776 : void infoCommand(client *c) {</span>
<span class="lineNum">    3648 </span><span class="lineCov">      30776 :     char *section = c-&gt;argc == 2 ? c-&gt;argv[1]-&gt;ptr : &quot;default&quot;;</span>
<span class="lineNum">    3649 </span>            : 
<span class="lineNum">    3650 </span><span class="lineCov">      30776 :     if (c-&gt;argc &gt; 2) {</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :         addReply(c,shared.syntaxerr);</span>
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 :         return;</span>
<span class="lineNum">    3653 </span>            :     }
<span class="lineNum">    3654 </span><span class="lineCov">      30776 :     addReplyBulkSds(c, genRedisInfoString(section));</span>
<a name="3655"><span class="lineNum">    3655 </span>            : }</a>
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span><span class="lineCov">          4 : void monitorCommand(client *c) {</span>
<span class="lineNum">    3658 </span>            :     /* ignore MONITOR if already slave or in monitor mode */
<span class="lineNum">    3659 </span><span class="lineCov">          4 :     if (c-&gt;flags &amp; CLIENT_SLAVE) return;</span>
<span class="lineNum">    3660 </span>            : 
<span class="lineNum">    3661 </span><span class="lineCov">          4 :     c-&gt;flags |= (CLIENT_SLAVE|CLIENT_MONITOR);</span>
<span class="lineNum">    3662 </span><span class="lineCov">          4 :     listAddNodeTail(server.monitors,c);</span>
<span class="lineNum">    3663 </span><span class="lineCov">          4 :     addReply(c,shared.ok);</span>
<span class="lineNum">    3664 </span>            : }
<span class="lineNum">    3665 </span>            : 
<span class="lineNum">    3666 </span>            : /* =================================== Main! ================================ */
<a name="3667"><span class="lineNum">    3667 </span>            : </a>
<span class="lineNum">    3668 </span>            : #ifdef __linux__
<span class="lineNum">    3669 </span><span class="lineCov">        656 : int linuxOvercommitMemoryValue(void) {</span>
<span class="lineNum">    3670 </span><span class="lineCov">        656 :     FILE *fp = fopen(&quot;/proc/sys/vm/overcommit_memory&quot;,&quot;r&quot;);</span>
<span class="lineNum">    3671 </span><span class="lineCov">        656 :     char buf[64];</span>
<span class="lineNum">    3672 </span>            : 
<span class="lineNum">    3673 </span><span class="lineCov">        656 :     if (!fp) return -1;</span>
<span class="lineNum">    3674 </span><span class="lineCov">        656 :     if (fgets(buf,64,fp) == NULL) {</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :         fclose(fp);</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    3677 </span>            :     }
<span class="lineNum">    3678 </span><span class="lineCov">        656 :     fclose(fp);</span>
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span><span class="lineCov">        656 :     return atoi(buf);</span>
<a name="3681"><span class="lineNum">    3681 </span>            : }</a>
<span class="lineNum">    3682 </span>            : 
<span class="lineNum">    3683 </span><span class="lineCov">        656 : void linuxMemoryWarnings(void) {</span>
<span class="lineNum">    3684 </span><span class="lineCov">        656 :     if (linuxOvercommitMemoryValue() == 0) {</span>
<span class="lineNum">    3685 </span><span class="lineCov">        656 :         serverLog(LL_WARNING,&quot;WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.&quot;);</span>
<span class="lineNum">    3686 </span>            :     }
<span class="lineNum">    3687 </span><span class="lineCov">        656 :     if (THPIsEnabled()) {</span>
<span class="lineNum">    3688 </span><span class="lineCov">        656 :         serverLog(LL_WARNING,&quot;WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.&quot;);</span>
<span class="lineNum">    3689 </span>            :     }
<span class="lineNum">    3690 </span><span class="lineCov">        656 : }</span>
<a name="3691"><span class="lineNum">    3691 </span>            : #endif /* __linux__ */</a>
<span class="lineNum">    3692 </span>            : 
<span class="lineNum">    3693 </span><span class="lineCov">        656 : void createPidFile(void) {</span>
<span class="lineNum">    3694 </span>            :     /* If pidfile requested, but no pidfile defined, use
<span class="lineNum">    3695 </span>            :      * default pidfile path */
<span class="lineNum">    3696 </span><span class="lineCov">        656 :     if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);</span>
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span>            :     /* Try to write the pid file in a best-effort way. */
<span class="lineNum">    3699 </span><span class="lineCov">        656 :     FILE *fp = fopen(server.pidfile,&quot;w&quot;);</span>
<span class="lineNum">    3700 </span><span class="lineCov">        656 :     if (fp) {</span>
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :         fprintf(fp,&quot;%d\n&quot;,(int)getpid());</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :         fclose(fp);</span>
<span class="lineNum">    3703 </span>            :     }
<a name="3704"><span class="lineNum">    3704 </span><span class="lineCov">        656 : }</span></a>
<span class="lineNum">    3705 </span>            : 
<span class="lineNum">    3706 </span><span class="lineNoCov">          0 : void daemonize(void) {</span>
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :     int fd;</span>
<span class="lineNum">    3708 </span>            : 
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :     if (fork() != 0) exit(0); /* parent exits */</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :     setsid(); /* create a new session */</span>
<span class="lineNum">    3711 </span>            : 
<span class="lineNum">    3712 </span>            :     /* Every output goes to /dev/null. If Redis is daemonized but
<span class="lineNum">    3713 </span>            :      * the 'logfile' is set to 'stdout' in the configuration file
<span class="lineNum">    3714 </span>            :      * it will not log at all. */
<span class="lineNum">    3715 </span><span class="lineNoCov">          0 :     if ((fd = open(&quot;/dev/null&quot;, O_RDWR, 0)) != -1) {</span>
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 :         dup2(fd, STDIN_FILENO);</span>
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :         dup2(fd, STDOUT_FILENO);</span>
<span class="lineNum">    3718 </span><span class="lineNoCov">          0 :         dup2(fd, STDERR_FILENO);</span>
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 :         if (fd &gt; STDERR_FILENO) close(fd);</span>
<span class="lineNum">    3720 </span>            :     }
<a name="3721"><span class="lineNum">    3721 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3722 </span>            : 
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 : void version(void) {</span>
<span class="lineNum">    3724 </span><span class="lineNoCov">          0 :     printf(&quot;Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n&quot;,</span>
<span class="lineNum">    3725 </span>            :         REDIS_VERSION,
<span class="lineNum">    3726 </span>            :         redisGitSHA1(),
<span class="lineNum">    3727 </span><span class="lineNoCov">          0 :         atoi(redisGitDirty()) &gt; 0,</span>
<span class="lineNum">    3728 </span>            :         ZMALLOC_LIB,
<span class="lineNum">    3729 </span>            :         sizeof(long) == 4 ? 32 : 64,
<span class="lineNum">    3730 </span><span class="lineNoCov">          0 :         (unsigned long long) redisBuildId());</span>
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :     exit(0);</span>
<a name="3732"><span class="lineNum">    3732 </span>            : }</a>
<span class="lineNum">    3733 </span>            : 
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 : void usage(void) {</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;Usage: ./redis-server [/path/to/redis.conf] [options]\n&quot;);</span>
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server - (read config from stdin)\n&quot;);</span>
<span class="lineNum">    3737 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server -v or --version\n&quot;);</span>
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server -h or --help\n&quot;);</span>
<span class="lineNum">    3739 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server --test-memory &lt;megabytes&gt;\n\n&quot;);</span>
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;Examples:\n&quot;);</span>
<span class="lineNum">    3741 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server (run the server with default conf)\n&quot;);</span>
<span class="lineNum">    3742 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server /etc/redis/6379.conf\n&quot;);</span>
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server --port 7777\n&quot;);</span>
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n&quot;);</span>
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server /etc/myredis.conf --loglevel verbose\n\n&quot;);</span>
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;Sentinel mode:\n&quot;);</span>
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :     fprintf(stderr,&quot;       ./redis-server /etc/sentinel.conf --sentinel\n&quot;);</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :     exit(1);</span>
<a name="3749"><span class="lineNum">    3749 </span>            : }</a>
<span class="lineNum">    3750 </span>            : 
<span class="lineNum">    3751 </span><span class="lineCov">        656 : void redisAsciiArt(void) {</span>
<span class="lineNum">    3752 </span>            : #include &quot;asciilogo.h&quot;
<span class="lineNum">    3753 </span><span class="lineCov">        656 :     char *buf = zmalloc(1024*16);</span>
<span class="lineNum">    3754 </span><span class="lineCov">        656 :     char *mode;</span>
<span class="lineNum">    3755 </span>            : 
<span class="lineNum">    3756 </span><span class="lineCov">        656 :     if (server.cluster_enabled) mode = &quot;cluster&quot;;</span>
<span class="lineNum">    3757 </span><span class="lineCov">        656 :     else if (server.sentinel_mode) mode = &quot;sentinel&quot;;</span>
<span class="lineNum">    3758 </span><span class="lineCov">        656 :     else mode = &quot;standalone&quot;;</span>
<span class="lineNum">    3759 </span>            : 
<span class="lineNum">    3760 </span>            :     /* Show the ASCII logo if: log file is stdout AND stdout is a
<span class="lineNum">    3761 </span>            :      * tty AND syslog logging is disabled. Also show logo if the user
<span class="lineNum">    3762 </span>            :      * forced us to do so via redis.conf. */
<span class="lineNum">    3763 </span><span class="lineCov">       1968 :     int show_logo = ((!server.syslog_enabled &amp;&amp;</span>
<span class="lineNum">    3764 </span><span class="lineCov">       1312 :                       server.logfile[0] == '\0' &amp;&amp;</span>
<span class="lineNum">    3765 </span><span class="lineCov">       1312 :                       isatty(fileno(stdout))) ||</span>
<span class="lineNum">    3766 </span><span class="lineCov">        656 :                      server.always_show_logo);</span>
<span class="lineNum">    3767 </span>            : 
<span class="lineNum">    3768 </span><span class="lineCov">        656 :     if (!show_logo) {</span>
<span class="lineNum">    3769 </span><span class="lineNoCov">          0 :         serverLog(LL_NOTICE,</span>
<span class="lineNum">    3770 </span>            :             &quot;Running mode=%s, port=%d.&quot;,
<span class="lineNum">    3771 </span>            :             mode, server.port
<span class="lineNum">    3772 </span>            :         );
<span class="lineNum">    3773 </span>            :     } else {
<span class="lineNum">    3774 </span><span class="lineCov">        656 :         snprintf(buf,1024*16,ascii_logo,</span>
<span class="lineNum">    3775 </span>            :             REDIS_VERSION,
<span class="lineNum">    3776 </span>            :             redisGitSHA1(),
<span class="lineNum">    3777 </span><span class="lineCov">        656 :             strtol(redisGitDirty(),NULL,10) &gt; 0,</span>
<span class="lineNum">    3778 </span>            :             (sizeof(long) == 8) ? &quot;64&quot; : &quot;32&quot;,
<span class="lineNum">    3779 </span>            :             mode, server.port,
<span class="lineNum">    3780 </span><span class="lineCov">        656 :             (long) getpid()</span>
<span class="lineNum">    3781 </span>            :         );
<span class="lineNum">    3782 </span><span class="lineCov">        656 :         serverLogRaw(LL_NOTICE|LL_RAW,buf);</span>
<span class="lineNum">    3783 </span>            :     }
<span class="lineNum">    3784 </span><span class="lineCov">        656 :     zfree(buf);</span>
<a name="3785"><span class="lineNum">    3785 </span><span class="lineCov">        656 : }</span></a>
<span class="lineNum">    3786 </span>            : 
<span class="lineNum">    3787 </span><span class="lineCov">        409 : static void sigShutdownHandler(int sig) {</span>
<span class="lineNum">    3788 </span><span class="lineCov">        409 :     char *msg;</span>
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span><span class="lineCov">        409 :     switch (sig) {</span>
<span class="lineNum">    3791 </span>            :     case SIGINT:
<span class="lineNum">    3792 </span>            :         msg = &quot;Received SIGINT scheduling shutdown...&quot;;
<span class="lineNum">    3793 </span>            :         break;
<span class="lineNum">    3794 </span><span class="lineCov">        409 :     case SIGTERM:</span>
<span class="lineNum">    3795 </span><span class="lineCov">        409 :         msg = &quot;Received SIGTERM scheduling shutdown...&quot;;</span>
<span class="lineNum">    3796 </span><span class="lineCov">        409 :         break;</span>
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :         msg = &quot;Received shutdown signal, scheduling shutdown...&quot;;</span>
<span class="lineNum">    3799 </span><span class="lineCov">        409 :     };</span>
<span class="lineNum">    3800 </span>            : 
<span class="lineNum">    3801 </span>            :     /* SIGINT is often delivered via Ctrl+C in an interactive session.
<span class="lineNum">    3802 </span>            :      * If we receive the signal the second time, we interpret this as
<span class="lineNum">    3803 </span>            :      * the user really wanting to quit ASAP without waiting to persist
<span class="lineNum">    3804 </span>            :      * on disk. */
<span class="lineNum">    3805 </span><span class="lineCov">        409 :     if (server.shutdown_asap &amp;&amp; sig == SIGINT) {</span>
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :         serverLogFromHandler(LL_WARNING, &quot;You insist... exiting now.&quot;);</span>
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :         rdbRemoveTempFile(getpid());</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :         exit(1); /* Exit with an error since this was not a clean shutdown. */</span>
<span class="lineNum">    3809 </span><span class="lineCov">        409 :     } else if (server.loading) {</span>
<span class="lineNum">    3810 </span><span class="lineNoCov">          0 :         exit(0);</span>
<span class="lineNum">    3811 </span>            :     }
<span class="lineNum">    3812 </span>            : 
<span class="lineNum">    3813 </span><span class="lineCov">        409 :     serverLogFromHandler(LL_WARNING, msg);</span>
<span class="lineNum">    3814 </span><span class="lineCov">        409 :     server.shutdown_asap = 1;</span>
<a name="3815"><span class="lineNum">    3815 </span><span class="lineCov">        409 : }</span></a>
<span class="lineNum">    3816 </span>            : 
<span class="lineNum">    3817 </span><span class="lineCov">        656 : void setupSignalHandlers(void) {</span>
<span class="lineNum">    3818 </span><span class="lineCov">        656 :     struct sigaction act;</span>
<span class="lineNum">    3819 </span>            : 
<span class="lineNum">    3820 </span>            :     /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
<span class="lineNum">    3821 </span>            :      * Otherwise, sa_handler is used. */
<span class="lineNum">    3822 </span><span class="lineCov">        656 :     sigemptyset(&amp;act.sa_mask);</span>
<span class="lineNum">    3823 </span><span class="lineCov">        656 :     act.sa_flags = 0;</span>
<span class="lineNum">    3824 </span><span class="lineCov">        656 :     act.sa_handler = sigShutdownHandler;</span>
<span class="lineNum">    3825 </span><span class="lineCov">        656 :     sigaction(SIGTERM, &amp;act, NULL);</span>
<span class="lineNum">    3826 </span><span class="lineCov">        656 :     sigaction(SIGINT, &amp;act, NULL);</span>
<span class="lineNum">    3827 </span>            : 
<span class="lineNum">    3828 </span>            : #ifdef HAVE_BACKTRACE
<span class="lineNum">    3829 </span><span class="lineCov">        656 :     sigemptyset(&amp;act.sa_mask);</span>
<span class="lineNum">    3830 </span><span class="lineCov">        656 :     act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;</span>
<span class="lineNum">    3831 </span><span class="lineCov">        656 :     act.sa_sigaction = sigsegvHandler;</span>
<span class="lineNum">    3832 </span><span class="lineCov">        656 :     sigaction(SIGSEGV, &amp;act, NULL);</span>
<span class="lineNum">    3833 </span><span class="lineCov">        656 :     sigaction(SIGBUS, &amp;act, NULL);</span>
<span class="lineNum">    3834 </span><span class="lineCov">        656 :     sigaction(SIGFPE, &amp;act, NULL);</span>
<span class="lineNum">    3835 </span><span class="lineCov">        656 :     sigaction(SIGILL, &amp;act, NULL);</span>
<span class="lineNum">    3836 </span>            : #endif
<span class="lineNum">    3837 </span><span class="lineCov">        656 :     return;</span>
<span class="lineNum">    3838 </span>            : }
<span class="lineNum">    3839 </span>            : 
<span class="lineNum">    3840 </span>            : void memtest(size_t megabytes, int passes);
<span class="lineNum">    3841 </span>            : 
<a name="3842"><span class="lineNum">    3842 </span>            : /* Returns 1 if there is --sentinel among the arguments or if</a>
<span class="lineNum">    3843 </span>            :  * argv[0] contains &quot;redis-sentinel&quot;. */
<span class="lineNum">    3844 </span><span class="lineCov">        662 : int checkForSentinelMode(int argc, char **argv) {</span>
<span class="lineNum">    3845 </span><span class="lineCov">        662 :     int j;</span>
<span class="lineNum">    3846 </span>            : 
<span class="lineNum">    3847 </span><span class="lineCov">        662 :     if (strstr(argv[0],&quot;redis-sentinel&quot;) != NULL) return 1;</span>
<span class="lineNum">    3848 </span><span class="lineCov">       1327 :     for (j = 1; j &lt; argc; j++)</span>
<span class="lineNum">    3849 </span><span class="lineCov">        665 :         if (!strcmp(argv[j],&quot;--sentinel&quot;)) return 1;</span>
<span class="lineNum">    3850 </span>            :     return 0;
<span class="lineNum">    3851 </span>            : }
<a name="3852"><span class="lineNum">    3852 </span>            : </a>
<span class="lineNum">    3853 </span>            : /* Function called at startup to load RDB or AOF file in memory. */
<span class="lineNum">    3854 </span><span class="lineCov">        656 : void loadDataFromDisk(void) {</span>
<span class="lineNum">    3855 </span><span class="lineCov">        656 :     long long start = ustime();</span>
<span class="lineNum">    3856 </span><span class="lineCov">        656 :     if (server.aof_state == AOF_ON) {</span>
<span class="lineNum">    3857 </span><span class="lineCov">         55 :         if (loadAppendOnlyFile(server.aof_filename) == C_OK)</span>
<span class="lineNum">    3858 </span><span class="lineCov">         21 :             serverLog(LL_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</span>
<span class="lineNum">    3859 </span>            :     } else {
<span class="lineNum">    3860 </span><span class="lineCov">        601 :         rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span>
<span class="lineNum">    3861 </span><span class="lineCov">        601 :         if (rdbLoad(server.rdb_filename,&amp;rsi) == C_OK) {</span>
<span class="lineNum">    3862 </span><span class="lineCov">         42 :             serverLog(LL_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</span>
<span class="lineNum">    3863 </span><span class="lineCov">         21 :                 (float)(ustime()-start)/1000000);</span>
<span class="lineNum">    3864 </span>            : 
<span class="lineNum">    3865 </span>            :             /* Restore the replication ID / offset from the RDB file. */
<span class="lineNum">    3866 </span><span class="lineCov">         21 :             if (server.masterhost &amp;&amp;</span>
<span class="lineNum">    3867 </span><span class="lineCov">          3 :                 rsi.repl_id_is_set &amp;&amp;</span>
<span class="lineNum">    3868 </span><span class="lineCov">          3 :                 rsi.repl_offset != -1 &amp;&amp;</span>
<span class="lineNum">    3869 </span>            :                 /* Note that older implementations may save a repl_stream_db
<span class="lineNum">    3870 </span>            :                  * of -1 inside the RDB file in a wrong way, see more information
<span class="lineNum">    3871 </span>            :                  * in function rdbPopulateSaveInfo. */
<span class="lineNum">    3872 </span><span class="lineCov">          3 :                 rsi.repl_stream_db != -1)</span>
<span class="lineNum">    3873 </span>            :             {
<span class="lineNum">    3874 </span><span class="lineCov">          3 :                 memcpy(server.replid,rsi.repl_id,sizeof(server.replid));</span>
<span class="lineNum">    3875 </span><span class="lineCov">          3 :                 server.master_repl_offset = rsi.repl_offset;</span>
<span class="lineNum">    3876 </span>            :                 /* If we are a slave, create a cached master from this
<span class="lineNum">    3877 </span>            :                  * information, in order to allow partial resynchronizations
<span class="lineNum">    3878 </span>            :                  * with masters. */
<span class="lineNum">    3879 </span><span class="lineCov">          3 :                 replicationCacheMasterUsingMyself();</span>
<span class="lineNum">    3880 </span><span class="lineCov">          3 :                 selectDb(server.cached_master,rsi.repl_stream_db);</span>
<span class="lineNum">    3881 </span>            :             }
<span class="lineNum">    3882 </span><span class="lineCov">        577 :         } else if (errno != ENOENT) {</span>
<span class="lineNum">    3883 </span><span class="lineCov">          3 :             serverLog(LL_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</span>
<span class="lineNum">    3884 </span><span class="lineCov">          3 :             exit(1);</span>
<span class="lineNum">    3885 </span>            :         }
<span class="lineNum">    3886 </span>            :     }
<a name="3887"><span class="lineNum">    3887 </span><span class="lineCov">        641 : }</span></a>
<span class="lineNum">    3888 </span>            : 
<span class="lineNum">    3889 </span><span class="lineNoCov">          0 : void redisOutOfMemoryHandler(size_t allocation_size) {</span>
<span class="lineNum">    3890 </span><span class="lineNoCov">          0 :     serverLog(LL_WARNING,&quot;Out Of Memory allocating %zu bytes!&quot;,</span>
<span class="lineNum">    3891 </span>            :         allocation_size);
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :     serverPanic(&quot;Redis aborting for OUT OF MEMORY&quot;);</span>
<a name="3893"><span class="lineNum">    3893 </span>            : }</a>
<span class="lineNum">    3894 </span>            : 
<span class="lineNum">    3895 </span><span class="lineCov">        886 : void redisSetProcTitle(char *title) {</span>
<span class="lineNum">    3896 </span>            : #ifdef USE_SETPROCTITLE
<span class="lineNum">    3897 </span><span class="lineCov">        886 :     char *server_mode = &quot;&quot;;</span>
<span class="lineNum">    3898 </span><span class="lineCov">        886 :     if (server.cluster_enabled) server_mode = &quot; [cluster]&quot;;</span>
<span class="lineNum">    3899 </span><span class="lineCov">        886 :     else if (server.sentinel_mode) server_mode = &quot; [sentinel]&quot;;</span>
<span class="lineNum">    3900 </span>            : 
<span class="lineNum">    3901 </span><span class="lineCov">        886 :     setproctitle(&quot;%s %s:%d%s&quot;,</span>
<span class="lineNum">    3902 </span>            :         title,
<span class="lineNum">    3903 </span><span class="lineCov">        886 :         server.bindaddr_count ? server.bindaddr[0] : &quot;*&quot;,</span>
<span class="lineNum">    3904 </span>            :         server.port,
<span class="lineNum">    3905 </span>            :         server_mode);
<span class="lineNum">    3906 </span>            : #else
<span class="lineNum">    3907 </span>            :     UNUSED(title);
<span class="lineNum">    3908 </span>            : #endif
<span class="lineNum">    3909 </span><span class="lineCov">        886 : }</span>
<span class="lineNum">    3910 </span>            : 
<span class="lineNum">    3911 </span>            : /*
<span class="lineNum">    3912 </span>            :  * Check whether systemd or upstart have been used to start redis.
<a name="3913"><span class="lineNum">    3913 </span>            :  */</a>
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 : int redisSupervisedUpstart(void) {</span>
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :     const char *upstart_job = getenv(&quot;UPSTART_JOB&quot;);</span>
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :     if (!upstart_job) {</span>
<span class="lineNum">    3919 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    3920 </span>            :                 &quot;upstart supervision requested, but UPSTART_JOB not found&quot;);
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    3922 </span>            :     }
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :     serverLog(LL_NOTICE, &quot;supervised by upstart, will stop to signal readiness&quot;);</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :     raise(SIGSTOP);</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :     unsetenv(&quot;UPSTART_JOB&quot;);</span>
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :     return 1;</span>
<a name="3928"><span class="lineNum">    3928 </span>            : }</a>
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 : int redisSupervisedSystemd(void) {</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :     const char *notify_socket = getenv(&quot;NOTIFY_SOCKET&quot;);</span>
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :     int fd = 1;</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :     struct sockaddr_un su;</span>
<span class="lineNum">    3934 </span><span class="lineNoCov">          0 :     struct iovec iov;</span>
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :     struct msghdr hdr;</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :     int sendto_flags = 0;</span>
<span class="lineNum">    3937 </span>            : 
<span class="lineNum">    3938 </span><span class="lineNoCov">          0 :     if (!notify_socket) {</span>
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    3940 </span>            :                 &quot;systemd supervision requested, but NOTIFY_SOCKET not found&quot;);
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    3942 </span>            :     }
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :     if ((strchr(&quot;@/&quot;, notify_socket[0])) == NULL || strlen(notify_socket) &lt; 2) {</span>
<span class="lineNum">    3945 </span>            :         return 0;
<span class="lineNum">    3946 </span>            :     }
<span class="lineNum">    3947 </span>            : 
<span class="lineNum">    3948 </span><span class="lineNoCov">          0 :     serverLog(LL_NOTICE, &quot;supervised by systemd, will signal readiness&quot;);</span>
<span class="lineNum">    3949 </span><span class="lineNoCov">          0 :     if ((fd = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1) {</span>
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,</span>
<span class="lineNum">    3951 </span>            :                 &quot;Can't connect to systemd socket %s&quot;, notify_socket);
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    3953 </span>            :     }
<span class="lineNum">    3954 </span>            : 
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :     memset(&amp;su, 0, sizeof(su));</span>
<span class="lineNum">    3956 </span><span class="lineNoCov">          0 :     su.sun_family = AF_UNIX;</span>
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :     strncpy (su.sun_path, notify_socket, sizeof(su.sun_path) -1);</span>
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 :     su.sun_path[sizeof(su.sun_path) - 1] = '\0';</span>
<span class="lineNum">    3959 </span>            : 
<span class="lineNum">    3960 </span><span class="lineNoCov">          0 :     if (notify_socket[0] == '@')</span>
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :         su.sun_path[0] = '\0';</span>
<span class="lineNum">    3962 </span>            : 
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :     memset(&amp;iov, 0, sizeof(iov));</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :     iov.iov_base = &quot;READY=1&quot;;</span>
<span class="lineNum">    3965 </span><span class="lineNoCov">          0 :     iov.iov_len = strlen(&quot;READY=1&quot;);</span>
<span class="lineNum">    3966 </span>            : 
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :     memset(&amp;hdr, 0, sizeof(hdr));</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :     hdr.msg_name = &amp;su;</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :     hdr.msg_namelen = offsetof(struct sockaddr_un, sun_path) +</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :         strlen(notify_socket);</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :     hdr.msg_iov = &amp;iov;</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :     hdr.msg_iovlen = 1;</span>
<span class="lineNum">    3973 </span>            : 
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :     unsetenv(&quot;NOTIFY_SOCKET&quot;);</span>
<span class="lineNum">    3975 </span>            : #ifdef HAVE_MSG_NOSIGNAL
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :     sendto_flags |= MSG_NOSIGNAL;</span>
<span class="lineNum">    3977 </span>            : #endif
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :     if (sendmsg(fd, &amp;hdr, sendto_flags) &lt; 0) {</span>
<span class="lineNum">    3979 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING, &quot;Can't send notification to systemd&quot;);</span>
<span class="lineNum">    3980 </span><span class="lineNoCov">          0 :         close(fd);</span>
<span class="lineNum">    3981 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    3982 </span>            :     }
<span class="lineNum">    3983 </span><span class="lineNoCov">          0 :     close(fd);</span>
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :     return 1;</span>
<a name="3985"><span class="lineNum">    3985 </span>            : }</a>
<span class="lineNum">    3986 </span>            : 
<span class="lineNum">    3987 </span><span class="lineCov">        656 : int redisIsSupervised(int mode) {</span>
<span class="lineNum">    3988 </span><span class="lineCov">        656 :     if (mode == SUPERVISED_AUTODETECT) {</span>
<span class="lineNum">    3989 </span><span class="lineNoCov">          0 :         const char *upstart_job = getenv(&quot;UPSTART_JOB&quot;);</span>
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :         const char *notify_socket = getenv(&quot;NOTIFY_SOCKET&quot;);</span>
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :         if (upstart_job) {</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :             redisSupervisedUpstart();</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :         } else if (notify_socket) {</span>
<span class="lineNum">    3995 </span><span class="lineNoCov">          0 :             redisSupervisedSystemd();</span>
<span class="lineNum">    3996 </span>            :         }
<span class="lineNum">    3997 </span><span class="lineCov">        656 :     } else if (mode == SUPERVISED_UPSTART) {</span>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 :         return redisSupervisedUpstart();</span>
<span class="lineNum">    3999 </span><span class="lineCov">        656 :     } else if (mode == SUPERVISED_SYSTEMD) {</span>
<span class="lineNum">    4000 </span><span class="lineNoCov">          0 :         return redisSupervisedSystemd();</span>
<span class="lineNum">    4001 </span>            :     }
<span class="lineNum">    4002 </span>            : 
<span class="lineNum">    4003 </span>            :     return 0;
<span class="lineNum">    4004 </span>            : }
<a name="4005"><span class="lineNum">    4005 </span>            : </a>
<span class="lineNum">    4006 </span>            : 
<span class="lineNum">    4007 </span><span class="lineCov">        662 : int main(int argc, char **argv) {</span>
<span class="lineNum">    4008 </span><span class="lineCov">        662 :     struct timeval tv;</span>
<span class="lineNum">    4009 </span><span class="lineCov">        662 :     int j;</span>
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span>            : #ifdef REDIS_TEST
<span class="lineNum">    4012 </span>            :     if (argc == 3 &amp;&amp; !strcasecmp(argv[1], &quot;test&quot;)) {
<span class="lineNum">    4013 </span>            :         if (!strcasecmp(argv[2], &quot;ziplist&quot;)) {
<span class="lineNum">    4014 </span>            :             return ziplistTest(argc, argv);
<span class="lineNum">    4015 </span>            :         } else if (!strcasecmp(argv[2], &quot;quicklist&quot;)) {
<span class="lineNum">    4016 </span>            :             quicklistTest(argc, argv);
<span class="lineNum">    4017 </span>            :         } else if (!strcasecmp(argv[2], &quot;intset&quot;)) {
<span class="lineNum">    4018 </span>            :             return intsetTest(argc, argv);
<span class="lineNum">    4019 </span>            :         } else if (!strcasecmp(argv[2], &quot;zipmap&quot;)) {
<span class="lineNum">    4020 </span>            :             return zipmapTest(argc, argv);
<span class="lineNum">    4021 </span>            :         } else if (!strcasecmp(argv[2], &quot;sha1test&quot;)) {
<span class="lineNum">    4022 </span>            :             return sha1Test(argc, argv);
<span class="lineNum">    4023 </span>            :         } else if (!strcasecmp(argv[2], &quot;util&quot;)) {
<span class="lineNum">    4024 </span>            :             return utilTest(argc, argv);
<span class="lineNum">    4025 </span>            :         } else if (!strcasecmp(argv[2], &quot;sds&quot;)) {
<span class="lineNum">    4026 </span>            :             return sdsTest(argc, argv);
<span class="lineNum">    4027 </span>            :         } else if (!strcasecmp(argv[2], &quot;endianconv&quot;)) {
<span class="lineNum">    4028 </span>            :             return endianconvTest(argc, argv);
<span class="lineNum">    4029 </span>            :         } else if (!strcasecmp(argv[2], &quot;crc64&quot;)) {
<span class="lineNum">    4030 </span>            :             return crc64Test(argc, argv);
<span class="lineNum">    4031 </span>            :         } else if (!strcasecmp(argv[2], &quot;zmalloc&quot;)) {
<span class="lineNum">    4032 </span>            :             return zmalloc_test(argc, argv);
<span class="lineNum">    4033 </span>            :         }
<span class="lineNum">    4034 </span>            : 
<span class="lineNum">    4035 </span>            :         return -1; /* test not found */
<span class="lineNum">    4036 </span>            :     }
<span class="lineNum">    4037 </span>            : #endif
<span class="lineNum">    4038 </span>            : 
<span class="lineNum">    4039 </span>            :     /* We need to initialize our libraries, and the server configuration. */
<span class="lineNum">    4040 </span>            : #ifdef INIT_SETPROCTITLE_REPLACEMENT
<span class="lineNum">    4041 </span><span class="lineCov">        662 :     spt_init(argc, argv);</span>
<span class="lineNum">    4042 </span>            : #endif
<span class="lineNum">    4043 </span><span class="lineCov">        662 :     setlocale(LC_COLLATE,&quot;&quot;);</span>
<span class="lineNum">    4044 </span><span class="lineCov">        662 :     tzset(); /* Populates 'timezone' global. */</span>
<span class="lineNum">    4045 </span><span class="lineCov">        662 :     zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span>
<span class="lineNum">    4046 </span><span class="lineCov">        662 :     srand(time(NULL)^getpid());</span>
<span class="lineNum">    4047 </span><span class="lineCov">        662 :     gettimeofday(&amp;tv,NULL);</span>
<span class="lineNum">    4048 </span>            : 
<span class="lineNum">    4049 </span><span class="lineCov">        662 :     char hashseed[16];</span>
<span class="lineNum">    4050 </span><span class="lineCov">        662 :     getRandomHexChars(hashseed,sizeof(hashseed));</span>
<span class="lineNum">    4051 </span><span class="lineCov">        662 :     dictSetHashFunctionSeed((uint8_t*)hashseed);</span>
<span class="lineNum">    4052 </span><span class="lineCov">        662 :     server.sentinel_mode = checkForSentinelMode(argc,argv);</span>
<span class="lineNum">    4053 </span><span class="lineCov">        662 :     initServerConfig();</span>
<span class="lineNum">    4054 </span><span class="lineCov">        662 :     moduleInitModulesSystem();</span>
<span class="lineNum">    4055 </span>            : 
<span class="lineNum">    4056 </span>            :     /* Store the executable path and arguments in a safe place in order
<span class="lineNum">    4057 </span>            :      * to be able to restart the server later. */
<span class="lineNum">    4058 </span><span class="lineCov">        662 :     server.executable = getAbsolutePath(argv[0]);</span>
<span class="lineNum">    4059 </span><span class="lineCov">        662 :     server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span>
<span class="lineNum">    4060 </span><span class="lineCov">        662 :     server.exec_argv[argc] = NULL;</span>
<span class="lineNum">    4061 </span><span class="lineCov">       1989 :     for (j = 0; j &lt; argc; j++) server.exec_argv[j] = zstrdup(argv[j]);</span>
<span class="lineNum">    4062 </span>            : 
<span class="lineNum">    4063 </span>            :     /* We need to init sentinel right now as parsing the configuration file
<span class="lineNum">    4064 </span>            :      * in sentinel mode will have the effect of populating the sentinel
<span class="lineNum">    4065 </span>            :      * data structures with master nodes to monitor. */
<span class="lineNum">    4066 </span><span class="lineCov">        662 :     if (server.sentinel_mode) {</span>
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :         initSentinelConfig();</span>
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :         initSentinel();</span>
<span class="lineNum">    4069 </span>            :     }
<span class="lineNum">    4070 </span>            : 
<span class="lineNum">    4071 </span>            :     /* Check if we need to start in redis-check-rdb/aof mode. We just execute
<span class="lineNum">    4072 </span>            :      * the program main. However the program is part of the Redis executable
<span class="lineNum">    4073 </span>            :      * so that we can easily execute an RDB check on loading errors. */
<span class="lineNum">    4074 </span><span class="lineCov">        662 :     if (strstr(argv[0],&quot;redis-check-rdb&quot;) != NULL)</span>
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :         redis_check_rdb_main(argc,argv,NULL);</span>
<span class="lineNum">    4076 </span><span class="lineCov">        662 :     else if (strstr(argv[0],&quot;redis-check-aof&quot;) != NULL)</span>
<span class="lineNum">    4077 </span><span class="lineCov">          6 :         redis_check_aof_main(argc,argv);</span>
<span class="lineNum">    4078 </span>            : 
<span class="lineNum">    4079 </span><span class="lineCov">        656 :     if (argc &gt;= 2) {</span>
<span class="lineNum">    4080 </span><span class="lineCov">        656 :         j = 1; /* First option to parse in argv[] */</span>
<span class="lineNum">    4081 </span><span class="lineCov">        656 :         sds options = sdsempty();</span>
<span class="lineNum">    4082 </span><span class="lineCov">        656 :         char *configfile = NULL;</span>
<span class="lineNum">    4083 </span>            : 
<span class="lineNum">    4084 </span>            :         /* Handle special options --help and --version */
<span class="lineNum">    4085 </span><span class="lineCov">        656 :         if (strcmp(argv[1], &quot;-v&quot;) == 0 ||</span>
<span class="lineNum">    4086 </span><span class="lineCov">        656 :             strcmp(argv[1], &quot;--version&quot;) == 0) version();</span>
<span class="lineNum">    4087 </span><span class="lineCov">        656 :         if (strcmp(argv[1], &quot;--help&quot;) == 0 ||</span>
<span class="lineNum">    4088 </span><span class="lineCov">        656 :             strcmp(argv[1], &quot;-h&quot;) == 0) usage();</span>
<span class="lineNum">    4089 </span><span class="lineCov">        656 :         if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) {</span>
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 :             if (argc == 3) {</span>
<span class="lineNum">    4091 </span><span class="lineNoCov">          0 :                 memtest(atoi(argv[2]),50);</span>
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 :                 exit(0);</span>
<span class="lineNum">    4093 </span>            :             } else {
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :                 fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);</span>
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :                 fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);</span>
<span class="lineNum">    4096 </span><span class="lineNoCov">          0 :                 exit(1);</span>
<span class="lineNum">    4097 </span>            :             }
<span class="lineNum">    4098 </span>            :         }
<span class="lineNum">    4099 </span>            : 
<span class="lineNum">    4100 </span>            :         /* First argument is the config file name? */
<span class="lineNum">    4101 </span><span class="lineCov">        656 :         if (argv[j][0] != '-' || argv[j][1] != '-') {</span>
<span class="lineNum">    4102 </span><span class="lineCov">        656 :             configfile = argv[j];</span>
<span class="lineNum">    4103 </span><span class="lineCov">        656 :             server.configfile = getAbsolutePath(configfile);</span>
<span class="lineNum">    4104 </span>            :             /* Replace the config file in server.exec_argv with
<span class="lineNum">    4105 </span>            :              * its absolute path. */
<span class="lineNum">    4106 </span><span class="lineCov">        656 :             zfree(server.exec_argv[j]);</span>
<span class="lineNum">    4107 </span><span class="lineCov">        656 :             server.exec_argv[j] = zstrdup(server.configfile);</span>
<span class="lineNum">    4108 </span><span class="lineCov">        656 :             j++;</span>
<span class="lineNum">    4109 </span>            :         }
<span class="lineNum">    4110 </span>            : 
<span class="lineNum">    4111 </span>            :         /* All the other options are parsed and conceptually appended to the
<span class="lineNum">    4112 </span>            :          * configuration file. For instance --port 6380 will generate the
<span class="lineNum">    4113 </span>            :          * string &quot;port 6380\n&quot; to be parsed after the actual file name
<span class="lineNum">    4114 </span>            :          * is parsed, if any. */
<span class="lineNum">    4115 </span><span class="lineCov">        656 :         while(j != argc) {</span>
<span class="lineNum">    4116 </span><span class="lineNoCov">          0 :             if (argv[j][0] == '-' &amp;&amp; argv[j][1] == '-') {</span>
<span class="lineNum">    4117 </span>            :                 /* Option name */
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :                 if (!strcmp(argv[j], &quot;--check-rdb&quot;)) {</span>
<span class="lineNum">    4119 </span>            :                     /* Argument has no options, need to skip for parsing. */
<span class="lineNum">    4120 </span><span class="lineNoCov">          0 :                     j++;</span>
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    4122 </span>            :                 }
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 :                 if (sdslen(options)) options = sdscat(options,&quot;\n&quot;);</span>
<span class="lineNum">    4124 </span><span class="lineNoCov">          0 :                 options = sdscat(options,argv[j]+2);</span>
<span class="lineNum">    4125 </span><span class="lineNoCov">          0 :                 options = sdscat(options,&quot; &quot;);</span>
<span class="lineNum">    4126 </span>            :             } else {
<span class="lineNum">    4127 </span>            :                 /* Option argument */
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :                 options = sdscatrepr(options,argv[j],strlen(argv[j]));</span>
<span class="lineNum">    4129 </span><span class="lineNoCov">          0 :                 options = sdscat(options,&quot; &quot;);</span>
<span class="lineNum">    4130 </span>            :             }
<span class="lineNum">    4131 </span><span class="lineNoCov">          0 :             j++;</span>
<span class="lineNum">    4132 </span>            :         }
<span class="lineNum">    4133 </span><span class="lineCov">        656 :         if (server.sentinel_mode &amp;&amp; configfile &amp;&amp; *configfile == '-') {</span>
<span class="lineNum">    4134 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,</span>
<span class="lineNum">    4135 </span>            :                 &quot;Sentinel config from STDIN not allowed.&quot;);
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :             serverLog(LL_WARNING,</span>
<span class="lineNum">    4137 </span>            :                 &quot;Sentinel needs config file on disk to save state.  Exiting...&quot;);
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :             exit(1);</span>
<span class="lineNum">    4139 </span>            :         }
<span class="lineNum">    4140 </span><span class="lineCov">        656 :         resetServerSaveParams();</span>
<span class="lineNum">    4141 </span><span class="lineCov">        656 :         loadServerConfig(configfile,options);</span>
<span class="lineNum">    4142 </span><span class="lineCov">        656 :         sdsfree(options);</span>
<span class="lineNum">    4143 </span>            :     }
<span class="lineNum">    4144 </span>            : 
<span class="lineNum">    4145 </span><span class="lineCov">        656 :     serverLog(LL_WARNING, &quot;oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo&quot;);</span>
<span class="lineNum">    4146 </span><span class="lineCov">        656 :     serverLog(LL_WARNING,</span>
<span class="lineNum">    4147 </span>            :         &quot;Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started&quot;,
<span class="lineNum">    4148 </span>            :             REDIS_VERSION,
<span class="lineNum">    4149 </span>            :             (sizeof(long) == 8) ? 64 : 32,
<span class="lineNum">    4150 </span>            :             redisGitSHA1(),
<span class="lineNum">    4151 </span><span class="lineCov">        656 :             strtol(redisGitDirty(),NULL,10) &gt; 0,</span>
<span class="lineNum">    4152 </span><span class="lineCov">        656 :             (int)getpid());</span>
<span class="lineNum">    4153 </span>            : 
<span class="lineNum">    4154 </span><span class="lineCov">        656 :     if (argc == 1) {</span>
<span class="lineNum">    4155 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING, &quot;Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf&quot;, argv[0], server.sentinel_mode ? &quot;sentinel&quot; : &quot;redis&quot;);</span>
<span class="lineNum">    4156 </span>            :     } else {
<span class="lineNum">    4157 </span><span class="lineCov">        656 :         serverLog(LL_WARNING, &quot;Configuration loaded&quot;);</span>
<span class="lineNum">    4158 </span>            :     }
<span class="lineNum">    4159 </span>            : 
<span class="lineNum">    4160 </span><span class="lineCov">        656 :     server.supervised = redisIsSupervised(server.supervised_mode);</span>
<span class="lineNum">    4161 </span><span class="lineCov">        656 :     int background = server.daemonize &amp;&amp; !server.supervised;</span>
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :     if (background) daemonize();</span>
<span class="lineNum">    4163 </span>            : 
<span class="lineNum">    4164 </span><span class="lineCov">        656 :     initServer();</span>
<span class="lineNum">    4165 </span><span class="lineCov">        656 :     if (background || server.pidfile) createPidFile();</span>
<span class="lineNum">    4166 </span><span class="lineCov">        656 :     redisSetProcTitle(argv[0]);</span>
<span class="lineNum">    4167 </span><span class="lineCov">        656 :     redisAsciiArt();</span>
<span class="lineNum">    4168 </span><span class="lineCov">        656 :     checkTcpBacklogSettings();</span>
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineCov">        656 :     if (!server.sentinel_mode) {</span>
<span class="lineNum">    4171 </span>            :         /* Things not needed when running in Sentinel mode. */
<span class="lineNum">    4172 </span><span class="lineCov">        656 :         serverLog(LL_WARNING,&quot;Server initialized&quot;);</span>
<span class="lineNum">    4173 </span>            :     #ifdef __linux__
<span class="lineNum">    4174 </span><span class="lineCov">        656 :         linuxMemoryWarnings();</span>
<span class="lineNum">    4175 </span>            :     #endif
<span class="lineNum">    4176 </span><span class="lineCov">        656 :         moduleLoadFromQueue();</span>
<span class="lineNum">    4177 </span><span class="lineCov">        656 :         loadDataFromDisk();</span>
<span class="lineNum">    4178 </span><span class="lineCov">        641 :         if (server.cluster_enabled) {</span>
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :             if (verifyClusterConfigWithData() == C_ERR) {</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :                 serverLog(LL_WARNING,</span>
<span class="lineNum">    4181 </span>            :                     &quot;You can't have keys in a DB different than DB 0 when in &quot;
<span class="lineNum">    4182 </span>            :                     &quot;Cluster mode. Exiting.&quot;);
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :                 exit(1);</span>
<span class="lineNum">    4184 </span>            :             }
<span class="lineNum">    4185 </span>            :         }
<span class="lineNum">    4186 </span><span class="lineCov">        641 :         if (server.ipfd_count &gt; 0)</span>
<span class="lineNum">    4187 </span><span class="lineCov">        641 :             serverLog(LL_NOTICE,&quot;Ready to accept connections&quot;);</span>
<span class="lineNum">    4188 </span><span class="lineCov">        641 :         if (server.sofd &gt; 0)</span>
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :             serverLog(LL_NOTICE,&quot;The server is now ready to accept connections at %s&quot;, server.unixsocket);</span>
<span class="lineNum">    4190 </span>            :     } else {
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :         sentinelIsRunning();</span>
<span class="lineNum">    4192 </span>            :     }
<span class="lineNum">    4193 </span>            : 
<span class="lineNum">    4194 </span>            :     /* Warning the user about suspicious maxmemory setting. */
<span class="lineNum">    4195 </span><span class="lineCov">        641 :     if (server.maxmemory &gt; 0 &amp;&amp; server.maxmemory &lt; 1024*1024) {</span>
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :         serverLog(LL_WARNING,&quot;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&quot;, server.maxmemory);</span>
<span class="lineNum">    4197 </span>            :     }
<span class="lineNum">    4198 </span>            : 
<span class="lineNum">    4199 </span><span class="lineCov">        641 :     aeSetBeforeSleepProc(server.el,beforeSleep);</span>
<span class="lineNum">    4200 </span><span class="lineCov">        641 :     aeSetAfterSleepProc(server.el,afterSleep);</span>
<span class="lineNum">    4201 </span><span class="lineCov">        641 :     aeMain(server.el);</span>
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :     aeDeleteEventLoop(server.el);</span>
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    4204 </span>            : }
<span class="lineNum">    4205 </span>            : 
<span class="lineNum">    4206 </span>            : /* The End */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
