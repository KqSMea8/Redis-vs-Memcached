<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - redis.info - src/defrag.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - defrag.c<span style="font-size: 80%;"> (source / <a href="defrag.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">redis.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">488</td>
            <td class="headerCovTableEntry">664</td>
            <td class="headerCovTableEntryLo">73.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-11-29 23:16:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">36</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntryMed">87.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* </a>
<span class="lineNum">       2 </span>            :  * Active memory defragmentation
<span class="lineNum">       3 </span>            :  * Try to find key / value allocations that need to be re-allocated in order 
<span class="lineNum">       4 </span>            :  * to reduce external fragmentation.
<span class="lineNum">       5 </span>            :  * We do that by scanning the keyspace and for each pointer we have, we can try to
<span class="lineNum">       6 </span>            :  * ask the allocator if moving it to a new address will help reduce fragmentation.
<span class="lineNum">       7 </span>            :  *
<span class="lineNum">       8 </span>            :  * Copyright (c) 2017, Oran Agra
<span class="lineNum">       9 </span>            :  * Copyright (c) 2017, Redis Labs, Inc
<span class="lineNum">      10 </span>            :  * All rights reserved.
<span class="lineNum">      11 </span>            :  *
<span class="lineNum">      12 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">      13 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">      14 </span>            :  *
<span class="lineNum">      15 </span>            :  *   * Redistributions of source code must retain the above copyright notice,
<span class="lineNum">      16 </span>            :  *     this list of conditions and the following disclaimer.
<span class="lineNum">      17 </span>            :  *   * Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      18 </span>            :  *     notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      19 </span>            :  *     documentation and/or other materials provided with the distribution.
<span class="lineNum">      20 </span>            :  *   * Neither the name of Redis nor the names of its contributors may be used
<span class="lineNum">      21 </span>            :  *     to endorse or promote products derived from this software without
<span class="lineNum">      22 </span>            :  *     specific prior written permission.
<span class="lineNum">      23 </span>            :  *
<span class="lineNum">      24 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
<span class="lineNum">      25 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      26 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
<span class="lineNum">      27 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
<span class="lineNum">      28 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
<span class="lineNum">      29 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
<span class="lineNum">      30 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
<span class="lineNum">      31 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
<span class="lineNum">      32 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
<span class="lineNum">      33 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
<span class="lineNum">      34 </span>            :  * POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      35 </span>            :  */
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #include &quot;server.h&quot;
<span class="lineNum">      38 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;stddef.h&gt;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #ifdef HAVE_DEFRAG
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /* this method was added to jemalloc in order to help us understand which
<span class="lineNum">      45 </span>            :  * pointers are worthwhile moving and which aren't */
<span class="lineNum">      46 </span>            : int je_get_defrag_hint(void* ptr, int *bin_util, int *run_util);
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : /* forward declarations*/
<span class="lineNum">      49 </span>            : void defragDictBucketCallback(void *privdata, dictEntry **bucketref);
<span class="lineNum">      50 </span>            : dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, unsigned int hash, long *defragged);
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            : /* Defrag helper for generic allocations.
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * returns NULL in case the allocatoin wasn't moved.
<a name="55"><span class="lineNum">      55 </span>            :  * when it returns a non-null value, the old pointer was already released</a>
<span class="lineNum">      56 </span>            :  * and should NOT be accessed. */
<span class="lineNum">      57 </span><span class="lineCov">    9300474 : void* activeDefragAlloc(void *ptr) {</span>
<span class="lineNum">      58 </span><span class="lineCov">    9300474 :     int bin_util, run_util;</span>
<span class="lineNum">      59 </span><span class="lineCov">    9300474 :     size_t size;</span>
<span class="lineNum">      60 </span><span class="lineCov">    9300474 :     void *newptr;</span>
<span class="lineNum">      61 </span><span class="lineCov">    9300474 :     if(!je_get_defrag_hint(ptr, &amp;bin_util, &amp;run_util)) {</span>
<span class="lineNum">      62 </span><span class="lineCov">       8969 :         server.stat_active_defrag_misses++;</span>
<span class="lineNum">      63 </span><span class="lineCov">       8969 :         return NULL;</span>
<span class="lineNum">      64 </span>            :     }
<span class="lineNum">      65 </span>            :     /* if this run is more utilized than the average utilization in this bin
<span class="lineNum">      66 </span>            :      * (or it is full), skip it. This will eventually move all the allocations
<span class="lineNum">      67 </span>            :      * from relatively empty runs into relatively full runs. */
<span class="lineNum">      68 </span><span class="lineCov">    9291505 :     if (run_util &gt; bin_util || run_util == 1&lt;&lt;16) {</span>
<span class="lineNum">      69 </span><span class="lineCov">    6463751 :         server.stat_active_defrag_misses++;</span>
<span class="lineNum">      70 </span><span class="lineCov">    6463751 :         return NULL;</span>
<span class="lineNum">      71 </span>            :     }
<span class="lineNum">      72 </span>            :     /* move this allocation to a new allocation.
<span class="lineNum">      73 </span>            :      * make sure not to use the thread cache. so that we don't get back the same
<span class="lineNum">      74 </span>            :      * pointers we try to free */
<span class="lineNum">      75 </span><span class="lineCov">    2827754 :     size = zmalloc_size(ptr);</span>
<span class="lineNum">      76 </span><span class="lineCov">    2827754 :     newptr = zmalloc_no_tcache(size);</span>
<span class="lineNum">      77 </span><span class="lineCov">    2827754 :     memcpy(newptr, ptr, size);</span>
<span class="lineNum">      78 </span><span class="lineCov">    2827754 :     zfree_no_tcache(ptr);</span>
<span class="lineNum">      79 </span><span class="lineCov">    2827754 :     return newptr;</span>
<span class="lineNum">      80 </span>            : }
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : /*Defrag helper for sds strings
<span class="lineNum">      83 </span>            :  *
<span class="lineNum">      84 </span>            :  * returns NULL in case the allocatoin wasn't moved.
<a name="85"><span class="lineNum">      85 </span>            :  * when it returns a non-null value, the old pointer was already released</a>
<span class="lineNum">      86 </span>            :  * and should NOT be accessed. */
<span class="lineNum">      87 </span><span class="lineCov">    4632716 : sds activeDefragSds(sds sdsptr) {</span>
<span class="lineNum">      88 </span><span class="lineCov">    4632716 :     void* ptr = sdsAllocPtr(sdsptr);</span>
<span class="lineNum">      89 </span><span class="lineCov">    4632716 :     void* newptr = activeDefragAlloc(ptr);</span>
<span class="lineNum">      90 </span><span class="lineCov">    4632716 :     if (newptr) {</span>
<span class="lineNum">      91 </span><span class="lineCov">    1419321 :         size_t offset = sdsptr - (char*)ptr;</span>
<span class="lineNum">      92 </span><span class="lineCov">    1419321 :         sdsptr = (char*)newptr + offset;</span>
<span class="lineNum">      93 </span><span class="lineCov">    1419321 :         return sdsptr;</span>
<span class="lineNum">      94 </span>            :     }
<span class="lineNum">      95 </span>            :     return NULL;
<span class="lineNum">      96 </span>            : }
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* Defrag helper for robj and/or string objects
<span class="lineNum">      99 </span>            :  *
<span class="lineNum">     100 </span>            :  * returns NULL in case the allocatoin wasn't moved.
<a name="101"><span class="lineNum">     101 </span>            :  * when it returns a non-null value, the old pointer was already released</a>
<span class="lineNum">     102 </span>            :  * and should NOT be accessed. */
<span class="lineNum">     103 </span><span class="lineCov">    2236368 : robj *activeDefragStringOb(robj* ob, long *defragged) {</span>
<span class="lineNum">     104 </span><span class="lineCov">    2236368 :     robj *ret = NULL;</span>
<span class="lineNum">     105 </span><span class="lineCov">    2236368 :     if (ob-&gt;refcount!=1)</span>
<span class="lineNum">     106 </span>            :         return NULL;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :     /* try to defrag robj (only if not an EMBSTR type (handled below). */
<span class="lineNum">     109 </span><span class="lineCov">    2236368 :     if (ob-&gt;type!=OBJ_STRING || ob-&gt;encoding!=OBJ_ENCODING_EMBSTR) {</span>
<span class="lineNum">     110 </span><span class="lineCov">    2236368 :         if ((ret = activeDefragAlloc(ob))) {</span>
<span class="lineNum">     111 </span><span class="lineCov">     700771 :             ob = ret;</span>
<span class="lineNum">     112 </span><span class="lineCov">     700771 :             (*defragged)++;</span>
<span class="lineNum">     113 </span>            :         }
<span class="lineNum">     114 </span>            :     }
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :     /* try to defrag string object */
<span class="lineNum">     117 </span><span class="lineCov">    2236368 :     if (ob-&gt;type == OBJ_STRING) {</span>
<span class="lineNum">     118 </span><span class="lineCov">    2236328 :         if(ob-&gt;encoding==OBJ_ENCODING_RAW) {</span>
<span class="lineNum">     119 </span><span class="lineCov">    2236328 :             sds newsds = activeDefragSds((sds)ob-&gt;ptr);</span>
<span class="lineNum">     120 </span><span class="lineCov">    2236328 :             if (newsds) {</span>
<span class="lineNum">     121 </span><span class="lineCov">     718038 :                 ob-&gt;ptr = newsds;</span>
<span class="lineNum">     122 </span><span class="lineCov">     718038 :                 (*defragged)++;</span>
<span class="lineNum">     123 </span>            :             }
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         } else if (ob-&gt;encoding==OBJ_ENCODING_EMBSTR) {</span>
<span class="lineNum">     125 </span>            :             /* The sds is embedded in the object allocation, calculate the
<span class="lineNum">     126 </span>            :              * offset and update the pointer in the new allocation. */
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :             long ofs = (intptr_t)ob-&gt;ptr - (intptr_t)ob;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :             if ((ret = activeDefragAlloc(ob))) {</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :                 ret-&gt;ptr = (void*)((intptr_t)ret + ofs);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :                 (*defragged)++;</span>
<span class="lineNum">     131 </span>            :             }
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :         } else if (ob-&gt;encoding!=OBJ_ENCODING_INT) {</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown string encoding&quot;);</span>
<span class="lineNum">     134 </span>            :         }
<span class="lineNum">     135 </span>            :     }
<span class="lineNum">     136 </span>            :     return ret;
<span class="lineNum">     137 </span>            : }
<span class="lineNum">     138 </span>            : 
<a name="139"><span class="lineNum">     139 </span>            : /* Defrag helper for dictEntries to be used during dict iteration (called on</a>
<span class="lineNum">     140 </span>            :  * each step). Teturns a stat of how many pointers were moved. */
<span class="lineNum">     141 </span><span class="lineCov">         16 : long dictIterDefragEntry(dictIterator *iter) {</span>
<span class="lineNum">     142 </span>            :     /* This function is a little bit dirty since it messes with the internals
<span class="lineNum">     143 </span>            :      * of the dict and it's iterator, but the benefit is that it is very easy
<span class="lineNum">     144 </span>            :      * to use, and require no other chagnes in the dict. */
<span class="lineNum">     145 </span><span class="lineCov">         16 :     long defragged = 0;</span>
<span class="lineNum">     146 </span><span class="lineCov">         16 :     dictht *ht;</span>
<span class="lineNum">     147 </span>            :     /* Handle the next entry (if there is one), and update the pointer in the
<span class="lineNum">     148 </span>            :      * current entry. */
<span class="lineNum">     149 </span><span class="lineCov">         16 :     if (iter-&gt;nextEntry) {</span>
<span class="lineNum">     150 </span><span class="lineCov">          4 :         dictEntry *newde = activeDefragAlloc(iter-&gt;nextEntry);</span>
<span class="lineNum">     151 </span><span class="lineCov">          4 :         if (newde) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :             iter-&gt;nextEntry = newde;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :             iter-&gt;entry-&gt;next = newde;</span>
<span class="lineNum">     155 </span>            :         }
<span class="lineNum">     156 </span>            :     }
<span class="lineNum">     157 </span>            :     /* handle the case of the first entry in the hash bucket. */
<span class="lineNum">     158 </span><span class="lineCov">         16 :     ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span>
<span class="lineNum">     159 </span><span class="lineCov">         16 :     if (ht-&gt;table[iter-&gt;index] == iter-&gt;entry) {</span>
<span class="lineNum">     160 </span><span class="lineCov">         12 :         dictEntry *newde = activeDefragAlloc(iter-&gt;entry);</span>
<span class="lineNum">     161 </span><span class="lineCov">         12 :         if (newde) {</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :             iter-&gt;entry = newde;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :             ht-&gt;table[iter-&gt;index] = newde;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     165 </span>            :         }
<span class="lineNum">     166 </span>            :     }
<span class="lineNum">     167 </span><span class="lineCov">         16 :     return defragged;</span>
<span class="lineNum">     168 </span>            : }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : /* Defrag helper for dict main allocations (dict struct, and hash tables).
<a name="171"><span class="lineNum">     171 </span>            :  * receives a pointer to the dict* and implicitly updates it when the dict</a>
<span class="lineNum">     172 </span>            :  * struct itself was moved. Returns a stat of how many pointers were moved. */
<span class="lineNum">     173 </span><span class="lineCov">         16 : long dictDefragTables(dict* d) {</span>
<span class="lineNum">     174 </span><span class="lineCov">         16 :     dictEntry **newtable;</span>
<span class="lineNum">     175 </span><span class="lineCov">         16 :     long defragged = 0;</span>
<span class="lineNum">     176 </span>            :     /* handle the first hash table */
<span class="lineNum">     177 </span><span class="lineCov">         16 :     newtable = activeDefragAlloc(d-&gt;ht[0].table);</span>
<span class="lineNum">     178 </span><span class="lineCov">         16 :     if (newtable)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :         defragged++, d-&gt;ht[0].table = newtable;</span>
<span class="lineNum">     180 </span>            :     /* handle the second hash table */
<span class="lineNum">     181 </span><span class="lineCov">         16 :     if (d-&gt;ht[1].table) {</span>
<span class="lineNum">     182 </span><span class="lineCov">         12 :         newtable = activeDefragAlloc(d-&gt;ht[1].table);</span>
<span class="lineNum">     183 </span><span class="lineCov">         12 :         if (newtable)</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :             defragged++, d-&gt;ht[1].table = newtable;</span>
<span class="lineNum">     185 </span>            :     }
<span class="lineNum">     186 </span><span class="lineCov">         16 :     return defragged;</span>
<span class="lineNum">     187 </span>            : }
<a name="188"><span class="lineNum">     188 </span>            : </a>
<span class="lineNum">     189 </span>            : /* Internal function used by zslDefrag */
<span class="lineNum">     190 </span><span class="lineNoCov">          0 : void zslUpdateNode(zskiplist *zsl, zskiplistNode *oldnode, zskiplistNode *newnode, zskiplistNode **update) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :     int i;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :     for (i = 0; i &lt; zsl-&gt;level; i++) {</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         if (update[i]-&gt;level[i].forward == oldnode)</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :             update[i]-&gt;level[i].forward = newnode;</span>
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     serverAssert(zsl-&gt;header!=oldnode);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     if (newnode-&gt;level[0].forward) {</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :         serverAssert(newnode-&gt;level[0].forward-&gt;backward==oldnode);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :         newnode-&gt;level[0].forward-&gt;backward = newnode;</span>
<span class="lineNum">     200 </span>            :     } else {
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         serverAssert(zsl-&gt;tail==oldnode);</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         zsl-&gt;tail = newnode;</span>
<span class="lineNum">     203 </span>            :     }
<span class="lineNum">     204 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : /* Defrag helper for sorted set.
<span class="lineNum">     207 </span>            :  * Update the robj pointer, defrag the skiplist struct and return the new score
<span class="lineNum">     208 </span>            :  * reference. We may not access oldele pointer (not even the pointer stored in
<span class="lineNum">     209 </span>            :  * the skiplist), as it was already freed. Newele may be null, in which case we
<span class="lineNum">     210 </span>            :  * only need to defrag the skiplist, but not update the obj pointer.
<a name="211"><span class="lineNum">     211 </span>            :  * When return value is non-NULL, it is the score reference that must be updated</a>
<span class="lineNum">     212 </span>            :  * in the dict record. */
<span class="lineNum">     213 </span><span class="lineCov">      40000 : double *zslDefrag(zskiplist *zsl, double score, sds oldele, sds newele) {</span>
<span class="lineNum">     214 </span><span class="lineCov">      40000 :     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x, *newx;</span>
<span class="lineNum">     215 </span><span class="lineCov">      40000 :     int i;</span>
<span class="lineNum">     216 </span><span class="lineCov">      40000 :     sds ele = newele? newele: oldele;</span>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :     /* find the skiplist node referring to the object that was moved,
<span class="lineNum">     219 </span>            :      * and all pointers that need to be updated if we'll end up moving the skiplist node. */
<span class="lineNum">     220 </span><span class="lineCov">      40000 :     x = zsl-&gt;header;</span>
<span class="lineNum">     221 </span><span class="lineCov">     320000 :     for (i = zsl-&gt;level-1; i &gt;= 0; i--) {</span>
<span class="lineNum">     222 </span><span class="lineCov">     948128 :         while (x-&gt;level[i].forward &amp;&amp;</span>
<span class="lineNum">     223 </span><span class="lineCov">     926592 :             x-&gt;level[i].forward-&gt;ele != oldele &amp;&amp; /* make sure not to access the</span>
<span class="lineNum">     224 </span>            :                                                      -&gt;obj pointer if it matches
<span class="lineNum">     225 </span>            :                                                      oldele */
<span class="lineNum">     226 </span><span class="lineCov">     873340 :             (x-&gt;level[i].forward-&gt;score &lt; score ||</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :                 sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</span>
<span class="lineNum">     229 </span><span class="lineCov">     668128 :             x = x-&gt;level[i].forward;</span>
<span class="lineNum">     230 </span><span class="lineCov">     280000 :         update[i] = x;</span>
<span class="lineNum">     231 </span>            :     }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :     /* update the robj pointer inside the skip list record. */
<span class="lineNum">     234 </span><span class="lineCov">      40000 :     x = x-&gt;level[0].forward;</span>
<span class="lineNum">     235 </span><span class="lineCov">      40000 :     serverAssert(x &amp;&amp; score == x-&gt;score &amp;&amp; x-&gt;ele==oldele);</span>
<span class="lineNum">     236 </span><span class="lineCov">      40000 :     if (newele)</span>
<span class="lineNum">     237 </span><span class="lineCov">         79 :         x-&gt;ele = newele;</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :     /* try to defrag the skiplist record itself */
<span class="lineNum">     240 </span><span class="lineCov">      40000 :     newx = activeDefragAlloc(x);</span>
<span class="lineNum">     241 </span><span class="lineCov">      40000 :     if (newx) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         zslUpdateNode(zsl, x, newx, update);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :         return &amp;newx-&gt;score;</span>
<span class="lineNum">     244 </span>            :     }
<span class="lineNum">     245 </span>            :     return NULL;
<span class="lineNum">     246 </span>            : }
<span class="lineNum">     247 </span>            : 
<a name="248"><span class="lineNum">     248 </span>            : /* Defrag helpler for sorted set.</a>
<span class="lineNum">     249 </span>            :  * Defrag a single dict entry key name, and corresponding skiplist struct */
<span class="lineNum">     250 </span><span class="lineCov">      40000 : long activeDefragZsetEntry(zset *zs, dictEntry *de) {</span>
<span class="lineNum">     251 </span><span class="lineCov">      40000 :     sds newsds;</span>
<span class="lineNum">     252 </span><span class="lineCov">      40000 :     double* newscore;</span>
<span class="lineNum">     253 </span><span class="lineCov">      40000 :     long defragged = 0;</span>
<span class="lineNum">     254 </span><span class="lineCov">      40000 :     sds sdsele = dictGetKey(de);</span>
<span class="lineNum">     255 </span><span class="lineCov">      40000 :     if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     256 </span><span class="lineCov">         79 :         defragged++, de-&gt;key = newsds;</span>
<span class="lineNum">     257 </span><span class="lineCov">      40000 :     newscore = zslDefrag(zs-&gt;zsl, *(double*)dictGetVal(de), sdsele, newsds);</span>
<span class="lineNum">     258 </span><span class="lineCov">      40000 :     if (newscore) {</span>
<span class="lineNum">     259 </span><span class="lineNoCov">          0 :         dictSetVal(zs-&gt;dict, de, newscore);</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :         defragged++;</span>
<span class="lineNum">     261 </span>            :     }
<span class="lineNum">     262 </span><span class="lineCov">      40000 :     return defragged;</span>
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : #define DEFRAG_SDS_DICT_NO_VAL 0
<span class="lineNum">     266 </span>            : #define DEFRAG_SDS_DICT_VAL_IS_SDS 1
<span class="lineNum">     267 </span>            : #define DEFRAG_SDS_DICT_VAL_IS_STROB 2
<span class="lineNum">     268 </span>            : #define DEFRAG_SDS_DICT_VAL_VOID_PTR 3
<a name="269"><span class="lineNum">     269 </span>            : </a>
<span class="lineNum">     270 </span>            : /* Defrag a dict with sds key and optional value (either ptr, sds or robj string) */
<span class="lineNum">     271 </span><span class="lineCov">         11 : long activeDefragSdsDict(dict* d, int val_type) {</span>
<span class="lineNum">     272 </span><span class="lineCov">         11 :     dictIterator *di;</span>
<span class="lineNum">     273 </span><span class="lineCov">         11 :     dictEntry *de;</span>
<span class="lineNum">     274 </span><span class="lineCov">         11 :     long defragged = 0;</span>
<span class="lineNum">     275 </span><span class="lineCov">         11 :     di = dictGetIterator(d);</span>
<span class="lineNum">     276 </span><span class="lineCov">         27 :     while((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">     277 </span><span class="lineCov">         16 :         sds sdsele = dictGetKey(de), newsds;</span>
<span class="lineNum">     278 </span><span class="lineCov">         16 :         if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :             de-&gt;key = newsds, defragged++;</span>
<span class="lineNum">     280 </span>            :         /* defrag the value */
<span class="lineNum">     281 </span><span class="lineCov">         16 :         if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             sdsele = dictGetVal(de);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :             if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                 de-&gt;v.val = newsds, defragged++;</span>
<span class="lineNum">     285 </span><span class="lineCov">         16 :         } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :             robj *newele, *ele = dictGetVal(de);</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :             if ((newele = activeDefragStringOb(ele, &amp;defragged)))</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :                 de-&gt;v.val = newele;</span>
<span class="lineNum">     289 </span><span class="lineCov">         16 :         } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :             void *newptr, *ptr = dictGetVal(de);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :             if ((newptr = activeDefragAlloc(ptr)))</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :                 de-&gt;v.val = newptr, defragged++;</span>
<span class="lineNum">     293 </span>            :         }
<span class="lineNum">     294 </span><span class="lineCov">         16 :         defragged += dictIterDefragEntry(di);</span>
<span class="lineNum">     295 </span>            :     }
<span class="lineNum">     296 </span><span class="lineCov">         11 :     dictReleaseIterator(di);</span>
<span class="lineNum">     297 </span><span class="lineCov">         11 :     return defragged;</span>
<span class="lineNum">     298 </span>            : }
<a name="299"><span class="lineNum">     299 </span>            : </a>
<span class="lineNum">     300 </span>            : /* Defrag a list of ptr, sds or robj string values */
<span class="lineNum">     301 </span><span class="lineNoCov">          0 : long activeDefragList(list *l, int val_type) {</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     long defragged = 0;</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     listNode *ln, *newln;</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     for (ln = l-&gt;head; ln; ln = ln-&gt;next) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         if ((newln = activeDefragAlloc(ln))) {</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :             if (newln-&gt;prev)</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                 newln-&gt;prev-&gt;next = newln;</span>
<span class="lineNum">     308 </span>            :             else
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                 l-&gt;head = newln;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :             if (newln-&gt;next)</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                 newln-&gt;next-&gt;prev = newln;</span>
<span class="lineNum">     312 </span>            :             else
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                 l-&gt;tail = newln;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :             ln = newln;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     316 </span>            :         }
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :         if (val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :             sds newsds, sdsele = ln-&gt;value;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                 ln-&gt;value = newsds, defragged++;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         } else if (val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :             robj *newele, *ele = ln-&gt;value;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :             if ((newele = activeDefragStringOb(ele, &amp;defragged)))</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :                 ln-&gt;value = newele;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         } else if (val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :             void *newptr, *ptr = ln-&gt;value;</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :             if ((newptr = activeDefragAlloc(ptr)))</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :                 ln-&gt;value = newptr, defragged++;</span>
<span class="lineNum">     329 </span>            :         }
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     return defragged;</span>
<span class="lineNum">     332 </span>            : }
<a name="333"><span class="lineNum">     333 </span>            : </a>
<span class="lineNum">     334 </span>            : /* Defrag a list of sds values and a dict with the same sds keys */
<span class="lineNum">     335 </span><span class="lineCov">          7 : long activeDefragSdsListAndDict(list *l, dict *d, int dict_val_type) {</span>
<span class="lineNum">     336 </span><span class="lineCov">          7 :     long defragged = 0;</span>
<span class="lineNum">     337 </span><span class="lineCov">          7 :     sds newsds, sdsele;</span>
<span class="lineNum">     338 </span><span class="lineCov">          7 :     listNode *ln, *newln;</span>
<span class="lineNum">     339 </span><span class="lineCov">          7 :     dictIterator *di;</span>
<span class="lineNum">     340 </span><span class="lineCov">          7 :     dictEntry *de;</span>
<span class="lineNum">     341 </span>            :     /* Defrag the list and it's sds values */
<span class="lineNum">     342 </span><span class="lineCov">          7 :     for (ln = l-&gt;head; ln; ln = ln-&gt;next) {</span>
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         if ((newln = activeDefragAlloc(ln))) {</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :             if (newln-&gt;prev)</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :                 newln-&gt;prev-&gt;next = newln;</span>
<span class="lineNum">     346 </span>            :             else
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                 l-&gt;head = newln;</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :             if (newln-&gt;next)</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                 newln-&gt;next-&gt;prev = newln;</span>
<span class="lineNum">     350 </span>            :             else
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                 l-&gt;tail = newln;</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :             ln = newln;</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     354 </span>            :         }
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         sdsele = ln-&gt;value;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         if ((newsds = activeDefragSds(sdsele))) {</span>
<span class="lineNum">     357 </span>            :             /* When defragging an sds value, we need to update the dict key */
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :             unsigned int hash = dictGetHash(d, sdsele);</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             replaceSateliteDictKeyPtrAndOrDefragDictEntry(d, sdsele, newsds, hash, &amp;defragged);</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :             ln-&gt;value = newsds;</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     362 </span>            :         }
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :     /* Defrag the dict values (keys were already handled) */
<span class="lineNum">     366 </span><span class="lineCov">          7 :     di = dictGetIterator(d);</span>
<span class="lineNum">     367 </span><span class="lineCov">          7 :     while((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_SDS) {</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :             sds newsds, sdsele = dictGetVal(de);</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :             if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :                 de-&gt;v.val = newsds, defragged++;</span>
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :         } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_IS_STROB) {</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :             robj *newele, *ele = dictGetVal(de);</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :             if ((newele = activeDefragStringOb(ele, &amp;defragged)))</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :                 de-&gt;v.val = newele, defragged++;</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :         } else if (dict_val_type == DEFRAG_SDS_DICT_VAL_VOID_PTR) {</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :             void *newptr, *ptr = ln-&gt;value;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :             if ((newptr = activeDefragAlloc(ptr)))</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 ln-&gt;value = newptr, defragged++;</span>
<span class="lineNum">     380 </span>            :         }
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         defragged += dictIterDefragEntry(di);</span>
<span class="lineNum">     382 </span>            :     }
<span class="lineNum">     383 </span><span class="lineCov">          7 :     dictReleaseIterator(di);</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span><span class="lineCov">          7 :     return defragged;</span>
<span class="lineNum">     386 </span>            : }
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /* Utility function that replaces an old key pointer in the dictionary with a
<span class="lineNum">     389 </span>            :  * new pointer. Additionally, we try to defrag the dictEntry in that dict.
<span class="lineNum">     390 </span>            :  * Oldkey mey be a dead pointer and should not be accessed (we get a
<span class="lineNum">     391 </span>            :  * pre-calculated hash value). Newkey may be null if the key pointer wasn't
<span class="lineNum">     392 </span>            :  * moved. Return value is the the dictEntry if found, or NULL if not found.
<a name="393"><span class="lineNum">     393 </span>            :  * NOTE: this is very ugly code, but it let's us avoid the complication of</a>
<span class="lineNum">     394 </span>            :  * doing a scan on another dict. */
<span class="lineNum">     395 </span><span class="lineNoCov">          0 : dictEntry* replaceSateliteDictKeyPtrAndOrDefragDictEntry(dict *d, sds oldkey, sds newkey, unsigned int hash, long *defragged) {</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :     dictEntry **deref = dictFindEntryRefByPtrAndHash(d, oldkey, hash);</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     if (deref) {</span>
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :         dictEntry *de = *deref;</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         dictEntry *newde = activeDefragAlloc(de);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :         if (newde) {</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :             de = *deref = newde;</span>
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :             (*defragged)++;</span>
<span class="lineNum">     403 </span>            :         }
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :         if (newkey)</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :             de-&gt;key = newkey;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :         return de;</span>
<span class="lineNum">     407 </span>            :     }
<span class="lineNum">     408 </span>            :     return NULL;
<a name="409"><span class="lineNum">     409 </span>            : }</a>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineCov">          8 : long activeDefragQuickListNodes(quicklist *ql) {</span>
<span class="lineNum">     412 </span><span class="lineCov">          8 :     quicklistNode *node = ql-&gt;head, *newnode;</span>
<span class="lineNum">     413 </span><span class="lineCov">          8 :     long defragged = 0;</span>
<span class="lineNum">     414 </span><span class="lineCov">          8 :     unsigned char *newzl;</span>
<span class="lineNum">     415 </span><span class="lineCov">       8012 :     while (node) {</span>
<span class="lineNum">     416 </span><span class="lineCov">       8004 :         if ((newnode = activeDefragAlloc(node))) {</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :             if (newnode-&gt;prev)</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 newnode-&gt;prev-&gt;next = newnode;</span>
<span class="lineNum">     419 </span>            :             else
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :                 ql-&gt;head = newnode;</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :             if (newnode-&gt;next)</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                 newnode-&gt;next-&gt;prev = newnode;</span>
<span class="lineNum">     423 </span>            :             else
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                 ql-&gt;tail = newnode;</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :             node = newnode;</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :             defragged++;</span>
<span class="lineNum">     427 </span>            :         }
<span class="lineNum">     428 </span><span class="lineCov">       8004 :         if ((newzl = activeDefragAlloc(node-&gt;zl)))</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :             defragged++, node-&gt;zl = newzl;</span>
<span class="lineNum">     430 </span><span class="lineCov">       8004 :         node = node-&gt;next;</span>
<span class="lineNum">     431 </span>            :     }
<span class="lineNum">     432 </span><span class="lineCov">          8 :     return defragged;</span>
<span class="lineNum">     433 </span>            : }
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : /* when the value has lots of elements, we want to handle it later and not as
<a name="436"><span class="lineNum">     436 </span>            :  * oart of the main dictionary scan. this is needed in order to prevent latency</a>
<span class="lineNum">     437 </span>            :  * spikes when handling large items */
<span class="lineNum">     438 </span><span class="lineNoCov">          0 : void defragLater(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :     sds key = sdsdup(dictGetKey(kde));</span>
<span class="lineNum">     440 </span><span class="lineCov">         20 :     listAddNodeTail(db-&gt;defrag_later, key);</span>
<a name="441"><span class="lineNum">     441 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span><span class="lineNoCov">          0 : long scanLaterList(robj *ob) {</span>
<span class="lineNum">     444 </span><span class="lineCov">          4 :     quicklist *ql = ob-&gt;ptr;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :     if (ob-&gt;type != OBJ_LIST || ob-&gt;encoding != OBJ_ENCODING_QUICKLIST)</span>
<span class="lineNum">     446 </span>            :         return 0;
<span class="lineNum">     447 </span><span class="lineCov">          4 :     server.stat_active_defrag_scanned+=ql-&gt;len;</span>
<span class="lineNum">     448 </span><span class="lineCov">          4 :     return activeDefragQuickListNodes(ql);</span>
<span class="lineNum">     449 </span>            : }
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : typedef struct {
<span class="lineNum">     452 </span>            :     zset *zs;
<span class="lineNum">     453 </span>            :     long defragged;
<a name="454"><span class="lineNum">     454 </span>            : } scanLaterZsetData;</a>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span><span class="lineCov">      40000 : void scanLaterZsetCallback(void *privdata, const dictEntry *_de) {</span>
<span class="lineNum">     457 </span><span class="lineCov">      40000 :     dictEntry *de = (dictEntry*)_de;</span>
<span class="lineNum">     458 </span><span class="lineCov">      40000 :     scanLaterZsetData *data = privdata;</span>
<span class="lineNum">     459 </span><span class="lineCov">      40000 :     data-&gt;defragged += activeDefragZsetEntry(data-&gt;zs, de);</span>
<span class="lineNum">     460 </span><span class="lineCov">      40000 :     server.stat_active_defrag_scanned++;</span>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">      40000 : }</span></a>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span><span class="lineCov">      32768 : long scanLaterZset(robj *ob, unsigned long *cursor) {</span>
<span class="lineNum">     464 </span><span class="lineCov">      32768 :     if (ob-&gt;type != OBJ_ZSET || ob-&gt;encoding != OBJ_ENCODING_SKIPLIST)</span>
<span class="lineNum">     465 </span>            :         return 0;
<span class="lineNum">     466 </span><span class="lineCov">      32768 :     zset *zs = (zset*)ob-&gt;ptr;</span>
<span class="lineNum">     467 </span><span class="lineCov">      32768 :     dict *d = zs-&gt;dict;</span>
<span class="lineNum">     468 </span><span class="lineCov">      32768 :     scanLaterZsetData data = {zs, 0};</span>
<span class="lineNum">     469 </span><span class="lineCov">      32768 :     *cursor = dictScan(d, *cursor, scanLaterZsetCallback, defragDictBucketCallback, &amp;data);</span>
<span class="lineNum">     470 </span><span class="lineCov">      32768 :     return data.defragged;</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">      40000 : void scanLaterSetCallback(void *privdata, const dictEntry *_de) {</span>
<span class="lineNum">     474 </span><span class="lineCov">      40000 :     dictEntry *de = (dictEntry*)_de;</span>
<span class="lineNum">     475 </span><span class="lineCov">      40000 :     long *defragged = privdata;</span>
<span class="lineNum">     476 </span><span class="lineCov">      40000 :     sds sdsele = dictGetKey(de), newsds;</span>
<span class="lineNum">     477 </span><span class="lineCov">      40000 :     if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     478 </span><span class="lineCov">        327 :         (*defragged)++, de-&gt;key = newsds;</span>
<span class="lineNum">     479 </span><span class="lineCov">      40000 :     server.stat_active_defrag_scanned++;</span>
<a name="480"><span class="lineNum">     480 </span><span class="lineCov">      40000 : }</span></a>
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span><span class="lineCov">      32768 : long scanLaterSet(robj *ob, unsigned long *cursor) {</span>
<span class="lineNum">     483 </span><span class="lineCov">      32768 :     long defragged = 0;</span>
<span class="lineNum">     484 </span><span class="lineCov">      32768 :     if (ob-&gt;type != OBJ_SET || ob-&gt;encoding != OBJ_ENCODING_HT)</span>
<span class="lineNum">     485 </span>            :         return 0;
<span class="lineNum">     486 </span><span class="lineCov">      32768 :     dict *d = ob-&gt;ptr;</span>
<span class="lineNum">     487 </span><span class="lineCov">      32768 :     *cursor = dictScan(d, *cursor, scanLaterSetCallback, defragDictBucketCallback, &amp;defragged);</span>
<span class="lineNum">     488 </span><span class="lineCov">      32768 :     return defragged;</span>
<a name="489"><span class="lineNum">     489 </span>            : }</a>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">      40000 : void scanLaterHashCallback(void *privdata, const dictEntry *_de) {</span>
<span class="lineNum">     492 </span><span class="lineCov">      40000 :     dictEntry *de = (dictEntry*)_de;</span>
<span class="lineNum">     493 </span><span class="lineCov">      40000 :     long *defragged = privdata;</span>
<span class="lineNum">     494 </span><span class="lineCov">      40000 :     sds sdsele = dictGetKey(de), newsds;</span>
<span class="lineNum">     495 </span><span class="lineCov">      40000 :     if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :         (*defragged)++, de-&gt;key = newsds;</span>
<span class="lineNum">     497 </span><span class="lineCov">      40000 :     sdsele = dictGetVal(de);</span>
<span class="lineNum">     498 </span><span class="lineCov">      40000 :     if ((newsds = activeDefragSds(sdsele)))</span>
<span class="lineNum">     499 </span><span class="lineCov">        157 :         (*defragged)++, de-&gt;v.val = newsds;</span>
<span class="lineNum">     500 </span><span class="lineCov">      40000 :     server.stat_active_defrag_scanned++;</span>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">      40000 : }</span></a>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span><span class="lineCov">      32768 : long scanLaterHash(robj *ob, unsigned long *cursor) {</span>
<span class="lineNum">     504 </span><span class="lineCov">      32768 :     long defragged = 0;</span>
<span class="lineNum">     505 </span><span class="lineCov">      32768 :     if (ob-&gt;type != OBJ_HASH || ob-&gt;encoding != OBJ_ENCODING_HT)</span>
<span class="lineNum">     506 </span>            :         return 0;
<span class="lineNum">     507 </span><span class="lineCov">      32768 :     dict *d = ob-&gt;ptr;</span>
<span class="lineNum">     508 </span><span class="lineCov">      32768 :     *cursor = dictScan(d, *cursor, scanLaterHashCallback, defragDictBucketCallback, &amp;defragged);</span>
<span class="lineNum">     509 </span><span class="lineCov">      32768 :     return defragged;</span>
<a name="510"><span class="lineNum">     510 </span>            : }</a>
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span><span class="lineCov">          8 : long defragQuicklist(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     513 </span><span class="lineCov">          8 :     robj *ob = dictGetVal(kde);</span>
<span class="lineNum">     514 </span><span class="lineCov">          8 :     long defragged = 0;</span>
<span class="lineNum">     515 </span><span class="lineCov">          8 :     quicklist *ql = ob-&gt;ptr, *newql;</span>
<span class="lineNum">     516 </span><span class="lineCov">          8 :     serverAssert(ob-&gt;type == OBJ_LIST &amp;&amp; ob-&gt;encoding == OBJ_ENCODING_QUICKLIST);</span>
<span class="lineNum">     517 </span><span class="lineCov">          8 :     if ((newql = activeDefragAlloc(ql)))</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :         defragged++, ob-&gt;ptr = ql = newql;</span>
<span class="lineNum">     519 </span><span class="lineCov">          8 :     if (ql-&gt;len &gt; server.active_defrag_max_scan_fields)</span>
<span class="lineNum">     520 </span><span class="lineCov">          4 :         defragLater(db, kde);</span>
<span class="lineNum">     521 </span>            :     else
<span class="lineNum">     522 </span><span class="lineCov">          4 :         defragged += activeDefragQuickListNodes(ql);</span>
<span class="lineNum">     523 </span><span class="lineCov">          8 :     return defragged;</span>
<a name="524"><span class="lineNum">     524 </span>            : }</a>
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">          4 : long defragZsetSkiplist(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     527 </span><span class="lineCov">          4 :     robj *ob = dictGetVal(kde);</span>
<span class="lineNum">     528 </span><span class="lineCov">          4 :     long defragged = 0;</span>
<span class="lineNum">     529 </span><span class="lineCov">          4 :     zset *zs = (zset*)ob-&gt;ptr;</span>
<span class="lineNum">     530 </span><span class="lineCov">          4 :     zset *newzs;</span>
<span class="lineNum">     531 </span><span class="lineCov">          4 :     zskiplist *newzsl;</span>
<span class="lineNum">     532 </span><span class="lineCov">          4 :     dict *newdict;</span>
<span class="lineNum">     533 </span><span class="lineCov">          4 :     dictEntry *de;</span>
<span class="lineNum">     534 </span><span class="lineCov">          4 :     struct zskiplistNode *newheader;</span>
<span class="lineNum">     535 </span><span class="lineCov">          4 :     serverAssert(ob-&gt;type == OBJ_ZSET &amp;&amp; ob-&gt;encoding == OBJ_ENCODING_SKIPLIST);</span>
<span class="lineNum">     536 </span><span class="lineCov">          4 :     if ((newzs = activeDefragAlloc(zs)))</span>
<span class="lineNum">     537 </span><span class="lineCov">          1 :         defragged++, ob-&gt;ptr = zs = newzs;</span>
<span class="lineNum">     538 </span><span class="lineCov">          4 :     if ((newzsl = activeDefragAlloc(zs-&gt;zsl)))</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :         defragged++, zs-&gt;zsl = newzsl;</span>
<span class="lineNum">     540 </span><span class="lineCov">          4 :     if ((newheader = activeDefragAlloc(zs-&gt;zsl-&gt;header)))</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         defragged++, zs-&gt;zsl-&gt;header = newheader;</span>
<span class="lineNum">     542 </span><span class="lineCov">          4 :     if (dictSize(zs-&gt;dict) &gt; server.active_defrag_max_scan_fields)</span>
<span class="lineNum">     543 </span><span class="lineCov">          4 :         defragLater(db, kde);</span>
<span class="lineNum">     544 </span>            :     else {
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :         dictIterator *di = dictGetIterator(zs-&gt;dict);</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         while((de = dictNext(di)) != NULL) {</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :             defragged += activeDefragZsetEntry(zs, de);</span>
<span class="lineNum">     548 </span>            :         }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         dictReleaseIterator(di);</span>
<span class="lineNum">     550 </span>            :     }
<span class="lineNum">     551 </span>            :     /* handle the dict struct */
<span class="lineNum">     552 </span><span class="lineCov">          4 :     if ((newdict = activeDefragAlloc(zs-&gt;dict)))</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :         defragged++, zs-&gt;dict = newdict;</span>
<span class="lineNum">     554 </span>            :     /* defrag the dict tables */
<span class="lineNum">     555 </span><span class="lineCov">          4 :     defragged += dictDefragTables(zs-&gt;dict);</span>
<span class="lineNum">     556 </span><span class="lineCov">          4 :     return defragged;</span>
<a name="557"><span class="lineNum">     557 </span>            : }</a>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineCov">          4 : long defragHash(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     560 </span><span class="lineCov">          4 :     long defragged = 0;</span>
<span class="lineNum">     561 </span><span class="lineCov">          4 :     robj *ob = dictGetVal(kde);</span>
<span class="lineNum">     562 </span><span class="lineCov">          4 :     dict *d, *newd;</span>
<span class="lineNum">     563 </span><span class="lineCov">          4 :     serverAssert(ob-&gt;type == OBJ_HASH &amp;&amp; ob-&gt;encoding == OBJ_ENCODING_HT);</span>
<span class="lineNum">     564 </span><span class="lineCov">          4 :     d = ob-&gt;ptr;</span>
<span class="lineNum">     565 </span><span class="lineCov">          4 :     if (dictSize(d) &gt; server.active_defrag_max_scan_fields)</span>
<span class="lineNum">     566 </span><span class="lineCov">          4 :         defragLater(db, kde);</span>
<span class="lineNum">     567 </span>            :     else
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_VAL_IS_SDS);</span>
<span class="lineNum">     569 </span>            :     /* handle the dict struct */
<span class="lineNum">     570 </span><span class="lineCov">          4 :     if ((newd = activeDefragAlloc(ob-&gt;ptr)))</span>
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         defragged++, ob-&gt;ptr = newd;</span>
<span class="lineNum">     572 </span>            :     /* defrag the dict tables */
<span class="lineNum">     573 </span><span class="lineCov">          4 :     defragged += dictDefragTables(ob-&gt;ptr);</span>
<span class="lineNum">     574 </span><span class="lineCov">          4 :     return defragged;</span>
<a name="575"><span class="lineNum">     575 </span>            : }</a>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">          8 : long defragSet(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     578 </span><span class="lineCov">          8 :     long defragged = 0;</span>
<span class="lineNum">     579 </span><span class="lineCov">          8 :     robj *ob = dictGetVal(kde);</span>
<span class="lineNum">     580 </span><span class="lineCov">          8 :     dict *d, *newd;</span>
<span class="lineNum">     581 </span><span class="lineCov">          8 :     serverAssert(ob-&gt;type == OBJ_SET &amp;&amp; ob-&gt;encoding == OBJ_ENCODING_HT);</span>
<span class="lineNum">     582 </span><span class="lineCov">          8 :     d = ob-&gt;ptr;</span>
<span class="lineNum">     583 </span><span class="lineCov">          8 :     if (dictSize(d) &gt; server.active_defrag_max_scan_fields)</span>
<span class="lineNum">     584 </span><span class="lineCov">          4 :         defragLater(db, kde);</span>
<span class="lineNum">     585 </span>            :     else
<span class="lineNum">     586 </span><span class="lineCov">          4 :         defragged += activeDefragSdsDict(d, DEFRAG_SDS_DICT_NO_VAL);</span>
<span class="lineNum">     587 </span>            :     /* handle the dict struct */
<span class="lineNum">     588 </span><span class="lineCov">          8 :     if ((newd = activeDefragAlloc(ob-&gt;ptr)))</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :         defragged++, ob-&gt;ptr = newd;</span>
<span class="lineNum">     590 </span>            :     /* defrag the dict tables */
<span class="lineNum">     591 </span><span class="lineCov">          8 :     defragged += dictDefragTables(ob-&gt;ptr);</span>
<span class="lineNum">     592 </span><span class="lineCov">          8 :     return defragged;</span>
<span class="lineNum">     593 </span>            : }
<span class="lineNum">     594 </span>            : 
<a name="595"><span class="lineNum">     595 </span>            : /* Defrag callback for radix tree iterator, called for each node,</a>
<span class="lineNum">     596 </span>            :  * used in order to defrag the nodes allocations. */
<span class="lineNum">     597 </span><span class="lineCov">      12186 : int defragRaxNode(raxNode **noderef) {</span>
<span class="lineNum">     598 </span><span class="lineCov">      12186 :     raxNode *newnode = activeDefragAlloc(*noderef);</span>
<span class="lineNum">     599 </span><span class="lineCov">      12210 :     if (newnode) {</span>
<span class="lineNum">     600 </span><span class="lineCov">         78 :         *noderef = newnode;</span>
<span class="lineNum">     601 </span><span class="lineCov">         78 :         return 1;</span>
<span class="lineNum">     602 </span>            :     }
<span class="lineNum">     603 </span>            :     return 0;
<span class="lineNum">     604 </span>            : }
<a name="605"><span class="lineNum">     605 </span>            : </a>
<span class="lineNum">     606 </span>            : /* returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed. */
<span class="lineNum">     607 </span><span class="lineCov">          4 : int scanLaterStraemListpacks(robj *ob, unsigned long *cursor, long long endtime, long long *defragged) {</span>
<span class="lineNum">     608 </span><span class="lineCov">          4 :     static unsigned char last[sizeof(streamID)];</span>
<span class="lineNum">     609 </span><span class="lineCov">          4 :     raxIterator ri;</span>
<span class="lineNum">     610 </span><span class="lineCov">          4 :     long iterations = 0;</span>
<span class="lineNum">     611 </span><span class="lineCov">          4 :     if (ob-&gt;type != OBJ_STREAM || ob-&gt;encoding != OBJ_ENCODING_STREAM) {</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :         *cursor = 0;</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     614 </span>            :     }
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">          4 :     stream *s = ob-&gt;ptr;</span>
<span class="lineNum">     617 </span><span class="lineCov">          4 :     raxStart(&amp;ri,s-&gt;rax);</span>
<span class="lineNum">     618 </span><span class="lineCov">          4 :     if (*cursor == 0) {</span>
<span class="lineNum">     619 </span>            :         /* if cursor is 0, we start new iteration */
<span class="lineNum">     620 </span><span class="lineCov">          4 :         defragRaxNode(&amp;s-&gt;rax-&gt;head);</span>
<span class="lineNum">     621 </span>            :         /* assign the iterator node callback before the seek, so that the
<span class="lineNum">     622 </span>            :          * initial nodes that are processed till the first item are covered */
<span class="lineNum">     623 </span><span class="lineCov">          4 :         ri.node_cb = defragRaxNode;</span>
<span class="lineNum">     624 </span><span class="lineCov">          4 :         raxSeek(&amp;ri,&quot;^&quot;,NULL,0);</span>
<span class="lineNum">     625 </span>            :     } else {
<span class="lineNum">     626 </span>            :         /* if cursor is non-zero, we seek to the static 'last' */
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :         if (!raxSeek(&amp;ri,&quot;&gt;&quot;, last, sizeof(last))) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :             *cursor = 0;</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :             return 0;</span>
<span class="lineNum">     630 </span>            :         }
<span class="lineNum">     631 </span>            :         /* assign the iterator node callback after the seek, so that the
<span class="lineNum">     632 </span>            :          * initial nodes that are processed till now aren't covered */
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         ri.node_cb = defragRaxNode;</span>
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineCov">          4 :     (*cursor)++;</span>
<span class="lineNum">     637 </span><span class="lineCov">       6676 :     while (raxNext(&amp;ri)) {</span>
<span class="lineNum">     638 </span><span class="lineCov">       6668 :         void *newdata = activeDefragAlloc(ri.data);</span>
<span class="lineNum">     639 </span><span class="lineCov">       6668 :         if (newdata)</span>
<span class="lineNum">     640 </span><span class="lineCov">          1 :             raxSetData(ri.node, ri.data=newdata), (*defragged)++;</span>
<span class="lineNum">     641 </span><span class="lineCov">       6668 :         if (++iterations &gt; 16) {</span>
<span class="lineNum">     642 </span><span class="lineCov">        392 :             if (ustime() &gt; endtime) {</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :                 serverAssert(ri.key_len==sizeof(last));</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                 memcpy(last,ri.key,ri.key_len);</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :                 raxStop(&amp;ri);</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">     647 </span>            :             }
<span class="lineNum">     648 </span>            :             iterations = 0;
<span class="lineNum">     649 </span>            :         }
<span class="lineNum">     650 </span>            :     }
<span class="lineNum">     651 </span><span class="lineCov">          4 :     raxStop(&amp;ri);</span>
<span class="lineNum">     652 </span><span class="lineCov">          4 :     *cursor = 0;</span>
<span class="lineNum">     653 </span><span class="lineCov">          4 :     return 0;</span>
<span class="lineNum">     654 </span>            : }
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            : /* optional callback used defrag each rax element (not including the element pointer itself) */
<span class="lineNum">     657 </span>            : typedef void *(raxDefragFunction)(raxIterator *ri, void *privdata, long *defragged);
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : /* defrag radix tree including:
<span class="lineNum">     660 </span>            :  * 1) rax struct
<span class="lineNum">     661 </span>            :  * 2) rax nodes
<a name="662"><span class="lineNum">     662 </span>            :  * 3) rax entry data (only if defrag_data is specified)</a>
<span class="lineNum">     663 </span>            :  * 4) call a callback per element, and allow the callback to return a new pointer for the element */
<span class="lineNum">     664 </span><span class="lineCov">         20 : long defragRadixTree(rax **raxref, int defrag_data, raxDefragFunction *element_cb, void *element_cb_data) {</span>
<span class="lineNum">     665 </span><span class="lineCov">         20 :     long defragged = 0;</span>
<span class="lineNum">     666 </span><span class="lineCov">         20 :     raxIterator ri;</span>
<span class="lineNum">     667 </span><span class="lineCov">         20 :     rax* rax;</span>
<span class="lineNum">     668 </span><span class="lineCov">         20 :     if ((rax = activeDefragAlloc(*raxref)))</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :         defragged++, *raxref = rax;</span>
<span class="lineNum">     670 </span><span class="lineCov">         20 :     rax = *raxref;</span>
<span class="lineNum">     671 </span><span class="lineCov">         20 :     raxStart(&amp;ri,rax);</span>
<span class="lineNum">     672 </span><span class="lineCov">         20 :     ri.node_cb = defragRaxNode;</span>
<span class="lineNum">     673 </span><span class="lineCov">         20 :     defragRaxNode(&amp;rax-&gt;head);</span>
<span class="lineNum">     674 </span><span class="lineCov">         20 :     raxSeek(&amp;ri,&quot;^&quot;,NULL,0);</span>
<span class="lineNum">     675 </span><span class="lineCov">         60 :     while (raxNext(&amp;ri)) {</span>
<span class="lineNum">     676 </span><span class="lineCov">         20 :         void *newdata = NULL;</span>
<span class="lineNum">     677 </span><span class="lineCov">         20 :         if (element_cb)</span>
<span class="lineNum">     678 </span><span class="lineCov">         12 :             newdata = element_cb(&amp;ri, element_cb_data, &amp;defragged);</span>
<span class="lineNum">     679 </span><span class="lineCov">         20 :         if (defrag_data &amp;&amp; !newdata)</span>
<span class="lineNum">     680 </span><span class="lineCov">          8 :             newdata = activeDefragAlloc(ri.data);</span>
<span class="lineNum">     681 </span><span class="lineCov">         20 :         if (newdata)</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :             raxSetData(ri.node, ri.data=newdata), defragged++;</span>
<span class="lineNum">     683 </span>            :     }
<span class="lineNum">     684 </span><span class="lineCov">         20 :     raxStop(&amp;ri);</span>
<span class="lineNum">     685 </span><span class="lineCov">         20 :     return defragged;</span>
<span class="lineNum">     686 </span>            : }
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span>            : typedef struct {
<span class="lineNum">     689 </span>            :     streamCG *cg;
<span class="lineNum">     690 </span>            :     streamConsumer *c;
<a name="691"><span class="lineNum">     691 </span>            : } PendingEntryContext;</a>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineCov">          4 : void* defragStreamConsumerPendingEntry(raxIterator *ri, void *privdata, long *defragged) {</span>
<span class="lineNum">     694 </span><span class="lineCov">          4 :     UNUSED(defragged);</span>
<span class="lineNum">     695 </span><span class="lineCov">          4 :     PendingEntryContext *ctx = privdata;</span>
<span class="lineNum">     696 </span><span class="lineCov">          4 :     streamNACK *nack = ri-&gt;data, *newnack;</span>
<span class="lineNum">     697 </span><span class="lineCov">          4 :     nack-&gt;consumer = ctx-&gt;c; /* update nack pointer to consumer */</span>
<span class="lineNum">     698 </span><span class="lineCov">          4 :     newnack = activeDefragAlloc(nack);</span>
<span class="lineNum">     699 </span><span class="lineCov">          4 :     if (newnack) {</span>
<span class="lineNum">     700 </span>            :         /* update consumer group pointer to the nack */
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         void *prev;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :         raxInsert(ctx-&gt;cg-&gt;pel, ri-&gt;key, ri-&gt;key_len, newnack, &amp;prev);</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         serverAssert(prev==nack);</span>
<span class="lineNum">     704 </span>            :         /* note: we don't increment 'defragged' that's done by the caller */
<span class="lineNum">     705 </span>            :     }
<span class="lineNum">     706 </span><span class="lineCov">          4 :     return newnack;</span>
<a name="707"><span class="lineNum">     707 </span>            : }</a>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">          4 : void* defragStreamConsumer(raxIterator *ri, void *privdata, long *defragged) {</span>
<span class="lineNum">     710 </span><span class="lineCov">          4 :     streamConsumer *c = ri-&gt;data;</span>
<span class="lineNum">     711 </span><span class="lineCov">          4 :     streamCG *cg = privdata;</span>
<span class="lineNum">     712 </span><span class="lineCov">          4 :     void *newc = activeDefragAlloc(c);</span>
<span class="lineNum">     713 </span><span class="lineCov">          4 :     if (newc) {</span>
<span class="lineNum">     714 </span>            :         /* note: we don't increment 'defragged' that's done by the caller */
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :         c = newc;</span>
<span class="lineNum">     716 </span>            :     }
<span class="lineNum">     717 </span><span class="lineCov">          4 :     sds newsds = activeDefragSds(c-&gt;name);</span>
<span class="lineNum">     718 </span><span class="lineCov">          4 :     if (newsds)</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :         (*defragged)++, c-&gt;name = newsds;</span>
<span class="lineNum">     720 </span><span class="lineCov">          4 :     if (c-&gt;pel) {</span>
<span class="lineNum">     721 </span><span class="lineCov">          4 :         PendingEntryContext pel_ctx = {cg, c};</span>
<span class="lineNum">     722 </span><span class="lineCov">          4 :         *defragged += defragRadixTree(&amp;c-&gt;pel, 0, defragStreamConsumerPendingEntry, &amp;pel_ctx);</span>
<span class="lineNum">     723 </span>            :     }
<span class="lineNum">     724 </span><span class="lineCov">          4 :     return newc; /* returns NULL if c was not defragged */</span>
<a name="725"><span class="lineNum">     725 </span>            : }</a>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">          4 : void* defragStreamConsumerGroup(raxIterator *ri, void *privdata, long *defragged) {</span>
<span class="lineNum">     728 </span><span class="lineCov">          4 :     streamCG *cg = ri-&gt;data;</span>
<span class="lineNum">     729 </span><span class="lineCov">          4 :     UNUSED(privdata);</span>
<span class="lineNum">     730 </span><span class="lineCov">          4 :     if (cg-&gt;consumers)</span>
<span class="lineNum">     731 </span><span class="lineCov">          4 :         *defragged += defragRadixTree(&amp;cg-&gt;consumers, 0, defragStreamConsumer, cg);</span>
<span class="lineNum">     732 </span><span class="lineCov">          4 :     if (cg-&gt;pel)</span>
<span class="lineNum">     733 </span><span class="lineCov">          4 :         *defragged += defragRadixTree(&amp;cg-&gt;pel, 0, NULL, NULL);</span>
<span class="lineNum">     734 </span><span class="lineCov">          4 :     return NULL;</span>
<a name="735"><span class="lineNum">     735 </span>            : }</a>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">          8 : long defragStream(redisDb *db, dictEntry *kde) {</span>
<span class="lineNum">     738 </span><span class="lineCov">          8 :     long defragged = 0;</span>
<span class="lineNum">     739 </span><span class="lineCov">          8 :     robj *ob = dictGetVal(kde);</span>
<span class="lineNum">     740 </span><span class="lineCov">          8 :     serverAssert(ob-&gt;type == OBJ_STREAM &amp;&amp; ob-&gt;encoding == OBJ_ENCODING_STREAM);</span>
<span class="lineNum">     741 </span><span class="lineCov">          8 :     stream *s = ob-&gt;ptr, *news;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :     /* handle the main struct */
<span class="lineNum">     744 </span><span class="lineCov">          8 :     if ((news = activeDefragAlloc(s)))</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :         defragged++, ob-&gt;ptr = s = news;</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">          8 :     if (raxSize(s-&gt;rax) &gt; server.active_defrag_max_scan_fields) {</span>
<span class="lineNum">     748 </span><span class="lineCov">          4 :         rax *newrax = activeDefragAlloc(s-&gt;rax);</span>
<span class="lineNum">     749 </span><span class="lineCov">          4 :         if (newrax)</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :             defragged++, s-&gt;rax = newrax;</span>
<span class="lineNum">     751 </span><span class="lineCov">          4 :         defragLater(db, kde);</span>
<span class="lineNum">     752 </span>            :     } else
<span class="lineNum">     753 </span><span class="lineCov">          4 :         defragged += defragRadixTree(&amp;s-&gt;rax, 1, NULL, NULL);</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span><span class="lineCov">          8 :     if (s-&gt;cgroups)</span>
<span class="lineNum">     756 </span><span class="lineCov">          4 :         defragged += defragRadixTree(&amp;s-&gt;cgroups, 1, defragStreamConsumerGroup, NULL);</span>
<span class="lineNum">     757 </span><span class="lineCov">          8 :     return defragged;</span>
<span class="lineNum">     758 </span>            : }
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span>            : /* for each key we scan in the main dict, this function will attempt to defrag
<a name="761"><span class="lineNum">     761 </span>            :  * all the various pointers it has. Returns a stat of how many pointers were</a>
<span class="lineNum">     762 </span>            :  * moved. */
<span class="lineNum">     763 </span><span class="lineCov">    2236368 : long defragKey(redisDb *db, dictEntry *de) {</span>
<span class="lineNum">     764 </span><span class="lineCov">    2236368 :     sds keysds = dictGetKey(de);</span>
<span class="lineNum">     765 </span><span class="lineCov">    2236368 :     robj *newob, *ob;</span>
<span class="lineNum">     766 </span><span class="lineCov">    2236368 :     unsigned char *newzl;</span>
<span class="lineNum">     767 </span><span class="lineCov">    2236368 :     long defragged = 0;</span>
<span class="lineNum">     768 </span><span class="lineCov">    2236368 :     sds newsds;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     /* Try to defrag the key name. */
<span class="lineNum">     771 </span><span class="lineCov">    2236368 :     newsds = activeDefragSds(keysds);</span>
<span class="lineNum">     772 </span><span class="lineCov">    2236368 :     if (newsds)</span>
<span class="lineNum">     773 </span><span class="lineCov">     700720 :         defragged++, de-&gt;key = newsds;</span>
<span class="lineNum">     774 </span><span class="lineCov">    2236368 :     if (dictSize(db-&gt;expires)) {</span>
<span class="lineNum">     775 </span>            :          /* Dirty code:
<span class="lineNum">     776 </span>            :           * I can't search in db-&gt;expires for that key after i already released
<span class="lineNum">     777 </span>            :           * the pointer it holds it won't be able to do the string compare */
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         uint64_t hash = dictGetHash(db-&gt;dict, de-&gt;key);</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         replaceSateliteDictKeyPtrAndOrDefragDictEntry(db-&gt;expires, keysds, newsds, hash, &amp;defragged);</span>
<span class="lineNum">     780 </span>            :     }
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            :     /* Try to defrag robj and / or string value. */
<span class="lineNum">     783 </span><span class="lineCov">    2236368 :     ob = dictGetVal(de);</span>
<span class="lineNum">     784 </span><span class="lineCov">    2236368 :     if ((newob = activeDefragStringOb(ob, &amp;defragged))) {</span>
<span class="lineNum">     785 </span><span class="lineCov">     700771 :         de-&gt;v.val = newob;</span>
<span class="lineNum">     786 </span><span class="lineCov">     700771 :         ob = newob;</span>
<span class="lineNum">     787 </span>            :     }
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineCov">    2236368 :     if (ob-&gt;type == OBJ_STRING) {</span>
<span class="lineNum">     790 </span>            :         /* Already handled in activeDefragStringOb. */
<span class="lineNum">     791 </span><span class="lineCov">         40 :     } else if (ob-&gt;type == OBJ_LIST) {</span>
<span class="lineNum">     792 </span><span class="lineCov">          8 :         if (ob-&gt;encoding == OBJ_ENCODING_QUICKLIST) {</span>
<span class="lineNum">     793 </span><span class="lineCov">          8 :             defragged += defragQuicklist(db, de);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         } else if (ob-&gt;encoding == OBJ_ENCODING_ZIPLIST) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :             if ((newzl = activeDefragAlloc(ob-&gt;ptr)))</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :                 defragged++, ob-&gt;ptr = newzl;</span>
<span class="lineNum">     797 </span>            :         } else {
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown list encoding&quot;);</span>
<span class="lineNum">     799 </span>            :         }
<span class="lineNum">     800 </span><span class="lineCov">         32 :     } else if (ob-&gt;type == OBJ_SET) {</span>
<span class="lineNum">     801 </span><span class="lineCov">          8 :         if (ob-&gt;encoding == OBJ_ENCODING_HT) {</span>
<span class="lineNum">     802 </span><span class="lineCov">          8 :             defragged += defragSet(db, de);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         } else if (ob-&gt;encoding == OBJ_ENCODING_INTSET) {</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :             intset *newis, *is = ob-&gt;ptr;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :             if ((newis = activeDefragAlloc(is)))</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :                 defragged++, ob-&gt;ptr = newis;</span>
<span class="lineNum">     807 </span>            :         } else {
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown set encoding&quot;);</span>
<span class="lineNum">     809 </span>            :         }
<span class="lineNum">     810 </span><span class="lineCov">         24 :     } else if (ob-&gt;type == OBJ_ZSET) {</span>
<span class="lineNum">     811 </span><span class="lineCov">          8 :         if (ob-&gt;encoding == OBJ_ENCODING_ZIPLIST) {</span>
<span class="lineNum">     812 </span><span class="lineCov">          4 :             if ((newzl = activeDefragAlloc(ob-&gt;ptr)))</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :                 defragged++, ob-&gt;ptr = newzl;</span>
<span class="lineNum">     814 </span><span class="lineCov">          4 :         } else if (ob-&gt;encoding == OBJ_ENCODING_SKIPLIST) {</span>
<span class="lineNum">     815 </span><span class="lineCov">          4 :             defragged += defragZsetSkiplist(db, de);</span>
<span class="lineNum">     816 </span>            :         } else {
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown sorted set encoding&quot;);</span>
<span class="lineNum">     818 </span>            :         }
<span class="lineNum">     819 </span><span class="lineCov">         16 :     } else if (ob-&gt;type == OBJ_HASH) {</span>
<span class="lineNum">     820 </span><span class="lineCov">          8 :         if (ob-&gt;encoding == OBJ_ENCODING_ZIPLIST) {</span>
<span class="lineNum">     821 </span><span class="lineCov">          4 :             if ((newzl = activeDefragAlloc(ob-&gt;ptr)))</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :                 defragged++, ob-&gt;ptr = newzl;</span>
<span class="lineNum">     823 </span><span class="lineCov">          4 :         } else if (ob-&gt;encoding == OBJ_ENCODING_HT) {</span>
<span class="lineNum">     824 </span><span class="lineCov">          4 :             defragged += defragHash(db, de);</span>
<span class="lineNum">     825 </span>            :         } else {
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :             serverPanic(&quot;Unknown hash encoding&quot;);</span>
<span class="lineNum">     827 </span>            :         }
<span class="lineNum">     828 </span><span class="lineCov">          8 :     } else if (ob-&gt;type == OBJ_STREAM) {</span>
<span class="lineNum">     829 </span><span class="lineCov">          8 :         defragged += defragStream(db, de);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :     } else if (ob-&gt;type == OBJ_MODULE) {</span>
<span class="lineNum">     831 </span>            :         /* Currently defragmenting modules private data types
<span class="lineNum">     832 </span>            :          * is not supported. */
<span class="lineNum">     833 </span>            :     } else {
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :         serverPanic(&quot;Unknown object type&quot;);</span>
<span class="lineNum">     835 </span>            :     }
<span class="lineNum">     836 </span><span class="lineCov">    2236368 :     return defragged;</span>
<span class="lineNum">     837 </span>            : }
<a name="838"><span class="lineNum">     838 </span>            : </a>
<span class="lineNum">     839 </span>            : /* Defrag scan callback for the main db dictionary. */
<span class="lineNum">     840 </span><span class="lineCov">    2236368 : void defragScanCallback(void *privdata, const dictEntry *de) {</span>
<span class="lineNum">     841 </span><span class="lineCov">    2236368 :     long defragged = defragKey((redisDb*)privdata, (dictEntry*)de);</span>
<span class="lineNum">     842 </span><span class="lineCov">    2236368 :     server.stat_active_defrag_hits += defragged;</span>
<span class="lineNum">     843 </span><span class="lineCov">    2236368 :     if(defragged)</span>
<span class="lineNum">     844 </span><span class="lineCov">    1134119 :         server.stat_active_defrag_key_hits++;</span>
<span class="lineNum">     845 </span>            :     else
<span class="lineNum">     846 </span><span class="lineCov">    1102249 :         server.stat_active_defrag_key_misses++;</span>
<span class="lineNum">     847 </span><span class="lineCov">    2236368 :     server.stat_active_defrag_scanned++;</span>
<span class="lineNum">     848 </span><span class="lineCov">    2236368 : }</span>
<span class="lineNum">     849 </span>            : 
<a name="850"><span class="lineNum">     850 </span>            : /* Defrag scan callback for each hash table bicket,</a>
<span class="lineNum">     851 </span>            :  * used in order to defrag the dictEntry allocations. */
<span class="lineNum">     852 </span><span class="lineCov">    5537792 : void defragDictBucketCallback(void *privdata, dictEntry **bucketref) {</span>
<span class="lineNum">     853 </span><span class="lineCov">    5537792 :     UNUSED(privdata); /* NOTE: this function is also used by both activeDefragCycle and scanLaterHash, etc. don't use privdata */</span>
<span class="lineNum">     854 </span><span class="lineCov">    7894160 :     while(*bucketref) {</span>
<span class="lineNum">     855 </span><span class="lineCov">    2356368 :         dictEntry *de = *bucketref, *newde;</span>
<span class="lineNum">     856 </span><span class="lineCov">    2356368 :         if ((newde = activeDefragAlloc(de))) {</span>
<span class="lineNum">     857 </span><span class="lineCov">     707582 :             *bucketref = newde;</span>
<span class="lineNum">     858 </span>            :         }
<span class="lineNum">     859 </span><span class="lineCov">    2356368 :         bucketref = &amp;(*bucketref)-&gt;next;</span>
<span class="lineNum">     860 </span>            :     }
<span class="lineNum">     861 </span><span class="lineCov">    5537792 : }</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : /* Utility function to get the fragmentation ratio from jemalloc.
<span class="lineNum">     864 </span>            :  * It is critical to do that by comparing only heap maps that belong to
<span class="lineNum">     865 </span>            :  * jemalloc, and skip ones the jemalloc keeps as spare. Since we use this
<span class="lineNum">     866 </span>            :  * fragmentation ratio in order to decide if a defrag action should be taken
<a name="867"><span class="lineNum">     867 </span>            :  * or not, a false detection can cause the defragmenter to waste a lot of CPU</a>
<span class="lineNum">     868 </span>            :  * without the possibility of getting any results. */
<span class="lineNum">     869 </span><span class="lineCov">         34 : float getAllocatorFragmentation(size_t *out_frag_bytes) {</span>
<span class="lineNum">     870 </span><span class="lineCov">         34 :     size_t resident, active, allocated;</span>
<span class="lineNum">     871 </span><span class="lineCov">         34 :     zmalloc_get_allocator_info(&amp;allocated, &amp;active, &amp;resident);</span>
<span class="lineNum">     872 </span><span class="lineCov">         34 :     float frag_pct = ((float)active / allocated)*100 - 100;</span>
<span class="lineNum">     873 </span><span class="lineCov">         34 :     size_t frag_bytes = active - allocated;</span>
<span class="lineNum">     874 </span><span class="lineCov">         34 :     float rss_pct = ((float)resident / allocated)*100 - 100;</span>
<span class="lineNum">     875 </span><span class="lineCov">         34 :     size_t rss_bytes = resident - allocated;</span>
<span class="lineNum">     876 </span><span class="lineCov">         34 :     if(out_frag_bytes)</span>
<span class="lineNum">     877 </span><span class="lineCov">         34 :         *out_frag_bytes = frag_bytes;</span>
<span class="lineNum">     878 </span><span class="lineCov">         34 :     serverLog(LL_DEBUG,</span>
<span class="lineNum">     879 </span>            :         &quot;allocated=%zu, active=%zu, resident=%zu, frag=%.0f%% (%.0f%% rss), frag_bytes=%zu (%zu rss)&quot;,
<span class="lineNum">     880 </span>            :         allocated, active, resident, frag_pct, rss_pct, frag_bytes, rss_bytes);
<span class="lineNum">     881 </span><span class="lineCov">         34 :     return frag_pct;</span>
<span class="lineNum">     882 </span>            : }
<span class="lineNum">     883 </span>            : 
<a name="884"><span class="lineNum">     884 </span>            : /* We may need to defrag other globals, one small allcation can hold a full allocator run.</a>
<span class="lineNum">     885 </span>            :  * so although small, it is still important to defrag these */
<span class="lineNum">     886 </span><span class="lineCov">          7 : long defragOtherGlobals() {</span>
<span class="lineNum">     887 </span><span class="lineCov">          7 :     long defragged = 0;</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            :     /* there are many more pointers to defrag (e.g. client argv, output / aof buffers, etc.
<span class="lineNum">     890 </span>            :      * but we assume most of these are short lived, we only need to defrag allocations
<span class="lineNum">     891 </span>            :      * that remain static for a long time */
<span class="lineNum">     892 </span><span class="lineCov">          7 :     defragged += activeDefragSdsDict(server.lua_scripts, DEFRAG_SDS_DICT_VAL_IS_STROB);</span>
<span class="lineNum">     893 </span><span class="lineCov">          7 :     defragged += activeDefragSdsListAndDict(server.repl_scriptcache_fifo, server.repl_scriptcache_dict, DEFRAG_SDS_DICT_NO_VAL);</span>
<span class="lineNum">     894 </span><span class="lineCov">          7 :     return defragged;</span>
<span class="lineNum">     895 </span>            : }
<span class="lineNum">     896 </span>            : 
<a name="897"><span class="lineNum">     897 </span>            : /* returns 0 more work may or may not be needed (see non-zero cursor),</a>
<span class="lineNum">     898 </span>            :  * and 1 if time is up and more work is needed. */
<span class="lineNum">     899 </span><span class="lineCov">      98312 : int defragLaterItem(dictEntry *de, unsigned long *cursor, long long endtime) {</span>
<span class="lineNum">     900 </span><span class="lineCov">      98312 :     if (de) {</span>
<span class="lineNum">     901 </span><span class="lineCov">      98312 :         robj *ob = dictGetVal(de);</span>
<span class="lineNum">     902 </span><span class="lineCov">      98312 :         if (ob-&gt;type == OBJ_LIST) {</span>
<span class="lineNum">     903 </span><span class="lineCov">          4 :             server.stat_active_defrag_hits += scanLaterList(ob);</span>
<span class="lineNum">     904 </span><span class="lineCov">          4 :             *cursor = 0; /* list has no scan, we must finish it in one go */</span>
<span class="lineNum">     905 </span><span class="lineCov">      98308 :         } else if (ob-&gt;type == OBJ_SET) {</span>
<span class="lineNum">     906 </span><span class="lineCov">      32768 :             server.stat_active_defrag_hits += scanLaterSet(ob, cursor);</span>
<span class="lineNum">     907 </span><span class="lineCov">      65540 :         } else if (ob-&gt;type == OBJ_ZSET) {</span>
<span class="lineNum">     908 </span><span class="lineCov">      32768 :             server.stat_active_defrag_hits += scanLaterZset(ob, cursor);</span>
<span class="lineNum">     909 </span><span class="lineCov">      32772 :         } else if (ob-&gt;type == OBJ_HASH) {</span>
<span class="lineNum">     910 </span><span class="lineCov">      32768 :             server.stat_active_defrag_hits += scanLaterHash(ob, cursor);</span>
<span class="lineNum">     911 </span><span class="lineCov">          4 :         } else if (ob-&gt;type == OBJ_STREAM) {</span>
<span class="lineNum">     912 </span><span class="lineCov">          4 :             return scanLaterStraemListpacks(ob, cursor, endtime, &amp;server.stat_active_defrag_hits);</span>
<span class="lineNum">     913 </span>            :         } else {
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :             *cursor = 0; /* object type may have changed since we schedule it for later */</span>
<span class="lineNum">     915 </span>            :         }
<span class="lineNum">     916 </span>            :     } else {
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :         *cursor = 0; /* object may have been deleted already */</span>
<span class="lineNum">     918 </span>            :     }
<span class="lineNum">     919 </span>            :     return 0;
<span class="lineNum">     920 </span>            : }
<a name="921"><span class="lineNum">     921 </span>            : </a>
<span class="lineNum">     922 </span>            : /* returns 0 if no more work needs to be been done, and 1 if time is up and more work is needed. */
<span class="lineNum">     923 </span><span class="lineCov">    5243118 : int defragLaterStep(redisDb *db, long long endtime) {</span>
<span class="lineNum">     924 </span><span class="lineCov">    5243118 :     static sds current_key = NULL;</span>
<span class="lineNum">     925 </span><span class="lineCov">    5243118 :     static unsigned long cursor = 0;</span>
<span class="lineNum">     926 </span><span class="lineCov">    5243118 :     unsigned int iterations = 0;</span>
<span class="lineNum">     927 </span><span class="lineCov">    5243118 :     unsigned long long prev_defragged = server.stat_active_defrag_hits;</span>
<span class="lineNum">     928 </span><span class="lineCov">    5243118 :     unsigned long long prev_scanned = server.stat_active_defrag_scanned;</span>
<span class="lineNum">     929 </span><span class="lineCov">    5243118 :     long long key_defragged;</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">    5243118 :     do {</span>
<span class="lineNum">     932 </span>            :         /* if we're not continuing a scan from the last call or loop, start a new one */
<span class="lineNum">     933 </span><span class="lineCov">    5243118 :         if (!cursor) {</span>
<span class="lineNum">     934 </span><span class="lineCov">    5243117 :             listNode *head = listFirst(db-&gt;defrag_later);</span>
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            :             /* Move on to next key */
<span class="lineNum">     937 </span><span class="lineCov">    5243117 :             if (current_key) {</span>
<span class="lineNum">     938 </span><span class="lineCov">         20 :                 serverAssert(current_key == head-&gt;value);</span>
<span class="lineNum">     939 </span><span class="lineCov">         20 :                 sdsfree(head-&gt;value);</span>
<span class="lineNum">     940 </span><span class="lineCov">         20 :                 listDelNode(db-&gt;defrag_later, head);</span>
<span class="lineNum">     941 </span><span class="lineCov">         20 :                 cursor = 0;</span>
<span class="lineNum">     942 </span><span class="lineCov">         20 :                 current_key = NULL;</span>
<span class="lineNum">     943 </span>            :             }
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            :             /* stop if we reached the last one. */
<span class="lineNum">     946 </span><span class="lineCov">    5243117 :             head = listFirst(db-&gt;defrag_later);</span>
<span class="lineNum">     947 </span><span class="lineCov">    5243117 :             if (!head)</span>
<span class="lineNum">     948 </span>            :                 return 0;
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :             /* start a new key */
<span class="lineNum">     951 </span><span class="lineCov">         20 :             current_key = head-&gt;value;</span>
<span class="lineNum">     952 </span><span class="lineCov">         20 :             cursor = 0;</span>
<span class="lineNum">     953 </span>            :         }
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :         /* each time we enter this function we need to fetch the key from the dict again (if it still exists) */
<span class="lineNum">     956 </span><span class="lineCov">         21 :         dictEntry *de = dictFind(db-&gt;dict, current_key);</span>
<span class="lineNum">     957 </span><span class="lineCov">         21 :         key_defragged = server.stat_active_defrag_hits;</span>
<span class="lineNum">     958 </span><span class="lineCov">      98312 :         do {</span>
<span class="lineNum">     959 </span><span class="lineCov">      98312 :             int quit = 0;</span>
<span class="lineNum">     960 </span><span class="lineCov">      98312 :             if (defragLaterItem(de, &amp;cursor, endtime))</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                 quit = 1; /* time is up, we didn't finish all the work */</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            :             /* Don't start a new BIG key in this loop, this is because the
<span class="lineNum">     964 </span>            :              * next key can be a list, and scanLaterList must be done in once cycle */
<span class="lineNum">     965 </span><span class="lineCov">      98312 :             if (!cursor)</span>
<span class="lineNum">     966 </span>            :                 quit = 1;
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :             /* Once in 16 scan iterations, 512 pointer reallocations, or 64 fields
<span class="lineNum">     969 </span>            :              * (if we have a lot of pointers in one hash bucket, or rehashing),
<span class="lineNum">     970 </span>            :              * check if we reached the time limit. */
<span class="lineNum">     971 </span><span class="lineCov">      98292 :             if (quit || (++iterations &gt; 16 ||</span>
<span class="lineNum">     972 </span><span class="lineCov">      92520 :                             server.stat_active_defrag_hits - prev_defragged &gt; 512 ||</span>
<span class="lineNum">     973 </span><span class="lineCov">      92520 :                             server.stat_active_defrag_scanned - prev_scanned &gt; 64)) {</span>
<span class="lineNum">     974 </span><span class="lineCov">       5792 :                 if (quit || ustime() &gt; endtime) {</span>
<span class="lineNum">     975 </span><span class="lineCov">         21 :                     if(key_defragged != server.stat_active_defrag_hits)</span>
<span class="lineNum">     976 </span><span class="lineCov">         12 :                         server.stat_active_defrag_key_hits++;</span>
<span class="lineNum">     977 </span>            :                     else
<span class="lineNum">     978 </span><span class="lineCov">          9 :                         server.stat_active_defrag_key_misses++;</span>
<span class="lineNum">     979 </span><span class="lineCov">         21 :                     return 1;</span>
<span class="lineNum">     980 </span>            :                 }
<span class="lineNum">     981 </span><span class="lineCov">       5771 :                 iterations = 0;</span>
<span class="lineNum">     982 </span><span class="lineCov">       5771 :                 prev_defragged = server.stat_active_defrag_hits;</span>
<span class="lineNum">     983 </span><span class="lineCov">       5771 :                 prev_scanned = server.stat_active_defrag_scanned;</span>
<span class="lineNum">     984 </span>            :             }
<span class="lineNum">     985 </span><span class="lineCov">      98291 :         } while(cursor);</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         if(key_defragged != server.stat_active_defrag_hits)</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :             server.stat_active_defrag_key_hits++;</span>
<span class="lineNum">     988 </span>            :         else
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :             server.stat_active_defrag_key_misses++;</span>
<span class="lineNum">     990 </span>            :     } while(1);
<span class="lineNum">     991 </span>            : }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            : #define INTERPOLATE(x, x1, x2, y1, y2) ( (y1) + ((x)-(x1)) * ((y2)-(y1)) / ((x2)-(x1)) )
<span class="lineNum">     994 </span>            : #define LIMIT(y, min, max) ((y)&lt;(min)? min: ((y)&gt;(max)? max: (y)))
<a name="995"><span class="lineNum">     995 </span>            : </a>
<span class="lineNum">     996 </span>            : /* decide if defrag is needed, and at what CPU effort to invest in it */
<span class="lineNum">     997 </span><span class="lineCov">         27 : void computeDefragCycles() {</span>
<span class="lineNum">     998 </span><span class="lineCov">         27 :     size_t frag_bytes;</span>
<span class="lineNum">     999 </span><span class="lineCov">         27 :     float frag_pct = getAllocatorFragmentation(&amp;frag_bytes);</span>
<span class="lineNum">    1000 </span>            :     /* If we're not already running, and below the threshold, exit. */
<span class="lineNum">    1001 </span><span class="lineCov">         27 :     if (!server.active_defrag_running) {</span>
<span class="lineNum">    1002 </span><span class="lineCov">         13 :         if(frag_pct &lt; server.active_defrag_threshold_lower || frag_bytes &lt; server.active_defrag_ignore_bytes)</span>
<span class="lineNum">    1003 </span><span class="lineCov">          6 :             return;</span>
<span class="lineNum">    1004 </span>            :     }
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :     /* Calculate the adaptive aggressiveness of the defrag */
<span class="lineNum">    1007 </span><span class="lineCov">         21 :     int cpu_pct = INTERPOLATE(frag_pct,</span>
<span class="lineNum">    1008 </span>            :             server.active_defrag_threshold_lower,
<span class="lineNum">    1009 </span>            :             server.active_defrag_threshold_upper,
<span class="lineNum">    1010 </span>            :             server.active_defrag_cycle_min,
<span class="lineNum">    1011 </span>            :             server.active_defrag_cycle_max);
<span class="lineNum">    1012 </span><span class="lineCov">         21 :     cpu_pct = LIMIT(cpu_pct,</span>
<span class="lineNum">    1013 </span>            :             server.active_defrag_cycle_min,
<span class="lineNum">    1014 </span>            :             server.active_defrag_cycle_max);
<span class="lineNum">    1015 </span>            :      /* We allow increasing the aggressiveness during a scan, but don't
<span class="lineNum">    1016 </span>            :       * reduce it. */
<span class="lineNum">    1017 </span><span class="lineCov">         21 :     if (!server.active_defrag_running ||</span>
<span class="lineNum">    1018 </span>            :         cpu_pct &gt; server.active_defrag_running)
<span class="lineNum">    1019 </span>            :     {
<span class="lineNum">    1020 </span><span class="lineCov">          7 :         server.active_defrag_running = cpu_pct;</span>
<span class="lineNum">    1021 </span><span class="lineCov">          7 :         serverLog(LL_VERBOSE,</span>
<span class="lineNum">    1022 </span>            :             &quot;Starting active defrag, frag=%.0f%%, frag_bytes=%zu, cpu=%d%%&quot;,
<span class="lineNum">    1023 </span>            :             frag_pct, frag_bytes, cpu_pct);
<span class="lineNum">    1024 </span>            :     }
<span class="lineNum">    1025 </span>            : }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            : /* Perform incremental defragmentation work from the serverCron.
<a name="1028"><span class="lineNum">    1028 </span>            :  * This works in a similar way to activeExpireCycle, in the sense that</a>
<span class="lineNum">    1029 </span>            :  * we do incremental work across calls. */
<span class="lineNum">    1030 </span><span class="lineCov">        188 : void activeDefragCycle(void) {</span>
<span class="lineNum">    1031 </span><span class="lineCov">        188 :     static int current_db = -1;</span>
<span class="lineNum">    1032 </span><span class="lineCov">        188 :     static unsigned long cursor = 0;</span>
<span class="lineNum">    1033 </span><span class="lineCov">        188 :     static redisDb *db = NULL;</span>
<span class="lineNum">    1034 </span><span class="lineCov">        188 :     static long long start_scan, start_stat;</span>
<span class="lineNum">    1035 </span><span class="lineCov">        188 :     unsigned int iterations = 0;</span>
<span class="lineNum">    1036 </span><span class="lineCov">        188 :     unsigned long long prev_defragged = server.stat_active_defrag_hits;</span>
<span class="lineNum">    1037 </span><span class="lineCov">        188 :     unsigned long long prev_scanned = server.stat_active_defrag_scanned;</span>
<span class="lineNum">    1038 </span><span class="lineCov">        188 :     long long start, timelimit, endtime;</span>
<span class="lineNum">    1039 </span><span class="lineCov">        188 :     mstime_t latency;</span>
<span class="lineNum">    1040 </span><span class="lineCov">        188 :     int quit = 0;</span>
<span class="lineNum">    1041 </span>            : 
<span class="lineNum">    1042 </span><span class="lineCov">        188 :     if (server.aof_child_pid!=-1 || server.rdb_child_pid!=-1)</span>
<span class="lineNum">    1043 </span>            :         return; /* Defragging memory while there's a fork will just do damage. */
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :     /* Once a second, check if we the fragmentation justfies starting a scan
<span class="lineNum">    1046 </span>            :      * or making it more aggressive. */
<span class="lineNum">    1047 </span><span class="lineCov">        188 :     run_with_period(1000) {</span>
<span class="lineNum">    1048 </span><span class="lineCov">         20 :         computeDefragCycles();</span>
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span><span class="lineCov">        188 :     if (!server.active_defrag_running)</span>
<span class="lineNum">    1051 </span>            :         return;
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :     /* See activeExpireCycle for how timelimit is handled. */
<span class="lineNum">    1054 </span><span class="lineCov">        169 :     start = ustime();</span>
<span class="lineNum">    1055 </span><span class="lineCov">        169 :     timelimit = 1000000*server.active_defrag_running/server.hz/100;</span>
<span class="lineNum">    1056 </span><span class="lineCov">        169 :     if (timelimit &lt;= 0) timelimit = 1;</span>
<span class="lineNum">    1057 </span><span class="lineCov">        169 :     endtime = start + timelimit;</span>
<span class="lineNum">    1058 </span><span class="lineCov">        169 :     latencyStartMonitor(latency);</span>
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineCov">        172 :     do {</span>
<span class="lineNum">    1061 </span>            :         /* if we're not continuing a scan from the last call or loop, start a new one */
<span class="lineNum">    1062 </span><span class="lineCov">        172 :         if (!cursor) {</span>
<span class="lineNum">    1063 </span>            :             /* finish any leftovers from previous db before moving to the next one */
<span class="lineNum">    1064 </span><span class="lineCov">        119 :             if (db &amp;&amp; defragLaterStep(db, endtime)) {</span>
<span class="lineNum">    1065 </span>            :                 quit = 1; /* time is up, we didn't finish all the work */
<span class="lineNum">    1066 </span>            :                 break; /* this will exit the function and we'll continue on the next cycle */
<span class="lineNum">    1067 </span>            :             }
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span>            :             /* Move on to next database, and stop if we reached the last one. */
<span class="lineNum">    1070 </span><span class="lineCov">        119 :             if (++current_db &gt;= server.dbnum) {</span>
<span class="lineNum">    1071 </span>            :                 /* defrag other items not part of the db / keys */
<span class="lineNum">    1072 </span><span class="lineCov">          7 :                 defragOtherGlobals();</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineCov">          7 :                 long long now = ustime();</span>
<span class="lineNum">    1075 </span><span class="lineCov">          7 :                 size_t frag_bytes;</span>
<span class="lineNum">    1076 </span><span class="lineCov">          7 :                 float frag_pct = getAllocatorFragmentation(&amp;frag_bytes);</span>
<span class="lineNum">    1077 </span><span class="lineCov">         21 :                 serverLog(LL_VERBOSE,</span>
<span class="lineNum">    1078 </span>            :                     &quot;Active defrag done in %dms, reallocated=%d, frag=%.0f%%, frag_bytes=%zu&quot;,
<span class="lineNum">    1079 </span><span class="lineCov">          7 :                     (int)((now - start_scan)/1000), (int)(server.stat_active_defrag_hits - start_stat), frag_pct, frag_bytes);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineCov">          7 :                 start_scan = now;</span>
<span class="lineNum">    1082 </span><span class="lineCov">          7 :                 current_db = -1;</span>
<span class="lineNum">    1083 </span><span class="lineCov">          7 :                 cursor = 0;</span>
<span class="lineNum">    1084 </span><span class="lineCov">          7 :                 db = NULL;</span>
<span class="lineNum">    1085 </span><span class="lineCov">          7 :                 server.active_defrag_running = 0;</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineCov">          7 :                 computeDefragCycles(); /* if another scan is needed, start it right away */</span>
<span class="lineNum">    1088 </span><span class="lineCov">          7 :                 if (server.active_defrag_running != 0 &amp;&amp; ustime() &lt; endtime)</span>
<span class="lineNum">    1089 </span><span class="lineCov">          3 :                     continue;</span>
<span class="lineNum">    1090 </span><span class="lineCov">          4 :                 break;</span>
<span class="lineNum">    1091 </span>            :             }
<span class="lineNum">    1092 </span><span class="lineCov">        112 :             else if (current_db==0) {</span>
<span class="lineNum">    1093 </span>            :                 /* Start a scan from the first database. */
<span class="lineNum">    1094 </span><span class="lineCov">          7 :                 start_scan = ustime();</span>
<span class="lineNum">    1095 </span><span class="lineCov">          7 :                 start_stat = server.stat_active_defrag_hits;</span>
<span class="lineNum">    1096 </span>            :             }
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineCov">        112 :             db = &amp;server.db[current_db];</span>
<span class="lineNum">    1099 </span><span class="lineCov">        112 :             cursor = 0;</span>
<span class="lineNum">    1100 </span>            :         }
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineCov">    5243006 :         do {</span>
<span class="lineNum">    1103 </span>            :             /* before scanning the next bucket, see if we have big keys left from the previous bucket to scan */
<span class="lineNum">    1104 </span><span class="lineCov">    5243006 :             if (defragLaterStep(db, endtime)) {</span>
<span class="lineNum">    1105 </span>            :                 quit = 1; /* time is up, we didn't finish all the work */
<span class="lineNum">    1106 </span>            :                 break; /* this will exit the function and we'll continue on the next cycle */
<span class="lineNum">    1107 </span>            :             }
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineCov">    5242985 :             cursor = dictScan(db-&gt;dict, cursor, defragScanCallback, defragDictBucketCallback, db);</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span>            :             /* Once in 16 scan iterations, 512 pointer reallocations. or 64 keys
<span class="lineNum">    1112 </span>            :              * (if we have a lot of pointers in one hash bucket or rehasing),
<span class="lineNum">    1113 </span>            :              * check if we reached the time limit.
<span class="lineNum">    1114 </span>            :              * But regardless, don't start a new db in this loop, this is because after
<span class="lineNum">    1115 </span>            :              * the last db we call defragOtherGlobals, which must be done in once cycle */
<span class="lineNum">    1116 </span><span class="lineCov">    5242985 :             if (!cursor || (++iterations &gt; 16 ||</span>
<span class="lineNum">    1117 </span><span class="lineCov">    4934485 :                             server.stat_active_defrag_hits - prev_defragged &gt; 512 ||</span>
<span class="lineNum">    1118 </span><span class="lineCov">    4934485 :                             server.stat_active_defrag_scanned - prev_scanned &gt; 64)) {</span>
<span class="lineNum">    1119 </span><span class="lineCov">     308500 :                 if (!cursor || ustime() &gt; endtime) {</span>
<span class="lineNum">    1120 </span>            :                     quit = 1;
<span class="lineNum">    1121 </span>            :                     break;
<span class="lineNum">    1122 </span>            :                 }
<span class="lineNum">    1123 </span><span class="lineCov">     308356 :                 iterations = 0;</span>
<span class="lineNum">    1124 </span><span class="lineCov">     308356 :                 prev_defragged = server.stat_active_defrag_hits;</span>
<span class="lineNum">    1125 </span><span class="lineCov">     308356 :                 prev_scanned = server.stat_active_defrag_scanned;</span>
<span class="lineNum">    1126 </span>            :             }
<span class="lineNum">    1127 </span><span class="lineCov">    5242841 :         } while(cursor &amp;&amp; !quit);</span>
<span class="lineNum">    1128 </span><span class="lineCov">        168 :     } while(!quit);</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineCov">        169 :     latencyEndMonitor(latency);</span>
<span class="lineNum">    1131 </span><span class="lineCov">        169 :     latencyAddSampleIfNeeded(&quot;active-defrag-cycle&quot;,latency);</span>
<span class="lineNum">    1132 </span>            : }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            : #else /* HAVE_DEFRAG */
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            : void activeDefragCycle(void) {
<span class="lineNum">    1137 </span>            :     /* Not implemented yet. */
<span class="lineNum">    1138 </span>            : }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
